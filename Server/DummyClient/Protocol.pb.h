// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_BUY_SHOP_ITEM;
struct C_BUY_SHOP_ITEMDefaultTypeInternal;
extern C_BUY_SHOP_ITEMDefaultTypeInternal _C_BUY_SHOP_ITEM_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_CREATEACCOUNT;
struct C_CREATEACCOUNTDefaultTypeInternal;
extern C_CREATEACCOUNTDefaultTypeInternal _C_CREATEACCOUNT_default_instance_;
class C_DROPITEM;
struct C_DROPITEMDefaultTypeInternal;
extern C_DROPITEMDefaultTypeInternal _C_DROPITEM_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_ENTER_ROOM;
struct C_ENTER_ROOMDefaultTypeInternal;
extern C_ENTER_ROOMDefaultTypeInternal _C_ENTER_ROOM_default_instance_;
class C_GOLD;
struct C_GOLDDefaultTypeInternal;
extern C_GOLDDefaultTypeInternal _C_GOLD_default_instance_;
class C_HITDAMAGE;
struct C_HITDAMAGEDefaultTypeInternal;
extern C_HITDAMAGEDefaultTypeInternal _C_HITDAMAGE_default_instance_;
class C_INVENTORY_REMOVE;
struct C_INVENTORY_REMOVEDefaultTypeInternal;
extern C_INVENTORY_REMOVEDefaultTypeInternal _C_INVENTORY_REMOVE_default_instance_;
class C_INVENTORY_UPDATE;
struct C_INVENTORY_UPDATEDefaultTypeInternal;
extern C_INVENTORY_UPDATEDefaultTypeInternal _C_INVENTORY_UPDATE_default_instance_;
class C_LEAVE_GAME;
struct C_LEAVE_GAMEDefaultTypeInternal;
extern C_LEAVE_GAMEDefaultTypeInternal _C_LEAVE_GAME_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_LOGOUT;
struct C_LOGOUTDefaultTypeInternal;
extern C_LOGOUTDefaultTypeInternal _C_LOGOUT_default_instance_;
class C_MAIL_ITEM_RECV;
struct C_MAIL_ITEM_RECVDefaultTypeInternal;
extern C_MAIL_ITEM_RECVDefaultTypeInternal _C_MAIL_ITEM_RECV_default_instance_;
class C_MAIL_LIST;
struct C_MAIL_LISTDefaultTypeInternal;
extern C_MAIL_LISTDefaultTypeInternal _C_MAIL_LIST_default_instance_;
class C_MELEEATTACK;
struct C_MELEEATTACKDefaultTypeInternal;
extern C_MELEEATTACKDefaultTypeInternal _C_MELEEATTACK_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_PATHFINDING;
struct C_PATHFINDINGDefaultTypeInternal;
extern C_PATHFINDINGDefaultTypeInternal _C_PATHFINDING_default_instance_;
class C_REFRESH_ITEM_LIST;
struct C_REFRESH_ITEM_LISTDefaultTypeInternal;
extern C_REFRESH_ITEM_LISTDefaultTypeInternal _C_REFRESH_ITEM_LIST_default_instance_;
class C_SHOOTPROJECTILE;
struct C_SHOOTPROJECTILEDefaultTypeInternal;
extern C_SHOOTPROJECTILEDefaultTypeInternal _C_SHOOTPROJECTILE_default_instance_;
class C_STATUS;
struct C_STATUSDefaultTypeInternal;
extern C_STATUSDefaultTypeInternal _C_STATUS_default_instance_;
class C_SWAP_INVENTORY_TO_INVENTORY;
struct C_SWAP_INVENTORY_TO_INVENTORYDefaultTypeInternal;
extern C_SWAP_INVENTORY_TO_INVENTORYDefaultTypeInternal _C_SWAP_INVENTORY_TO_INVENTORY_default_instance_;
class C_TRY_PICK_ITEM_TO_INVENTORY;
struct C_TRY_PICK_ITEM_TO_INVENTORYDefaultTypeInternal;
extern C_TRY_PICK_ITEM_TO_INVENTORYDefaultTypeInternal _C_TRY_PICK_ITEM_TO_INVENTORY_default_instance_;
class S_BUY_SHOP_ITEM;
struct S_BUY_SHOP_ITEMDefaultTypeInternal;
extern S_BUY_SHOP_ITEMDefaultTypeInternal _S_BUY_SHOP_ITEM_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_CREATEACCOUNT;
struct S_CREATEACCOUNTDefaultTypeInternal;
extern S_CREATEACCOUNTDefaultTypeInternal _S_CREATEACCOUNT_default_instance_;
class S_DEATH;
struct S_DEATHDefaultTypeInternal;
extern S_DEATHDefaultTypeInternal _S_DEATH_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_ENTER_GAME;
struct S_ENTER_GAMEDefaultTypeInternal;
extern S_ENTER_GAMEDefaultTypeInternal _S_ENTER_GAME_default_instance_;
class S_ENTER_ROOM;
struct S_ENTER_ROOMDefaultTypeInternal;
extern S_ENTER_ROOMDefaultTypeInternal _S_ENTER_ROOM_default_instance_;
class S_GOLD;
struct S_GOLDDefaultTypeInternal;
extern S_GOLDDefaultTypeInternal _S_GOLD_default_instance_;
class S_HITDAMAGE;
struct S_HITDAMAGEDefaultTypeInternal;
extern S_HITDAMAGEDefaultTypeInternal _S_HITDAMAGE_default_instance_;
class S_INVENTORY_REMOVE;
struct S_INVENTORY_REMOVEDefaultTypeInternal;
extern S_INVENTORY_REMOVEDefaultTypeInternal _S_INVENTORY_REMOVE_default_instance_;
class S_INVENTORY_UPDATE;
struct S_INVENTORY_UPDATEDefaultTypeInternal;
extern S_INVENTORY_UPDATEDefaultTypeInternal _S_INVENTORY_UPDATE_default_instance_;
class S_LEAVE_GAME;
struct S_LEAVE_GAMEDefaultTypeInternal;
extern S_LEAVE_GAMEDefaultTypeInternal _S_LEAVE_GAME_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_LOGOUT;
struct S_LOGOUTDefaultTypeInternal;
extern S_LOGOUTDefaultTypeInternal _S_LOGOUT_default_instance_;
class S_MAIL_LIST;
struct S_MAIL_LISTDefaultTypeInternal;
extern S_MAIL_LISTDefaultTypeInternal _S_MAIL_LIST_default_instance_;
class S_MAIL_SEND;
struct S_MAIL_SENDDefaultTypeInternal;
extern S_MAIL_SENDDefaultTypeInternal _S_MAIL_SEND_default_instance_;
class S_MELEEATTACK;
struct S_MELEEATTACKDefaultTypeInternal;
extern S_MELEEATTACKDefaultTypeInternal _S_MELEEATTACK_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_PATHFINDING;
struct S_PATHFINDINGDefaultTypeInternal;
extern S_PATHFINDINGDefaultTypeInternal _S_PATHFINDING_default_instance_;
class S_SHOOTPROJECTILE;
struct S_SHOOTPROJECTILEDefaultTypeInternal;
extern S_SHOOTPROJECTILEDefaultTypeInternal _S_SHOOTPROJECTILE_default_instance_;
class S_SHOP_ITEM_LIST;
struct S_SHOP_ITEM_LISTDefaultTypeInternal;
extern S_SHOP_ITEM_LISTDefaultTypeInternal _S_SHOP_ITEM_LIST_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_SPAWNBOX;
struct S_SPAWNBOXDefaultTypeInternal;
extern S_SPAWNBOXDefaultTypeInternal _S_SPAWNBOX_default_instance_;
class S_SPAWNITEM;
struct S_SPAWNITEMDefaultTypeInternal;
extern S_SPAWNITEMDefaultTypeInternal _S_SPAWNITEM_default_instance_;
class S_SPAWNMONSTER;
struct S_SPAWNMONSTERDefaultTypeInternal;
extern S_SPAWNMONSTERDefaultTypeInternal _S_SPAWNMONSTER_default_instance_;
class S_SPAWNPLAYER;
struct S_SPAWNPLAYERDefaultTypeInternal;
extern S_SPAWNPLAYERDefaultTypeInternal _S_SPAWNPLAYER_default_instance_;
class S_STATUS;
struct S_STATUSDefaultTypeInternal;
extern S_STATUSDefaultTypeInternal _S_STATUS_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_BUY_SHOP_ITEM* Arena::CreateMaybeMessage<::Protocol::C_BUY_SHOP_ITEM>(Arena*);
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_CREATEACCOUNT* Arena::CreateMaybeMessage<::Protocol::C_CREATEACCOUNT>(Arena*);
template<> ::Protocol::C_DROPITEM* Arena::CreateMaybeMessage<::Protocol::C_DROPITEM>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::C_ENTER_ROOM>(Arena*);
template<> ::Protocol::C_GOLD* Arena::CreateMaybeMessage<::Protocol::C_GOLD>(Arena*);
template<> ::Protocol::C_HITDAMAGE* Arena::CreateMaybeMessage<::Protocol::C_HITDAMAGE>(Arena*);
template<> ::Protocol::C_INVENTORY_REMOVE* Arena::CreateMaybeMessage<::Protocol::C_INVENTORY_REMOVE>(Arena*);
template<> ::Protocol::C_INVENTORY_UPDATE* Arena::CreateMaybeMessage<::Protocol::C_INVENTORY_UPDATE>(Arena*);
template<> ::Protocol::C_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::C_LEAVE_GAME>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_LOGOUT* Arena::CreateMaybeMessage<::Protocol::C_LOGOUT>(Arena*);
template<> ::Protocol::C_MAIL_ITEM_RECV* Arena::CreateMaybeMessage<::Protocol::C_MAIL_ITEM_RECV>(Arena*);
template<> ::Protocol::C_MAIL_LIST* Arena::CreateMaybeMessage<::Protocol::C_MAIL_LIST>(Arena*);
template<> ::Protocol::C_MELEEATTACK* Arena::CreateMaybeMessage<::Protocol::C_MELEEATTACK>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_PATHFINDING* Arena::CreateMaybeMessage<::Protocol::C_PATHFINDING>(Arena*);
template<> ::Protocol::C_REFRESH_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::C_REFRESH_ITEM_LIST>(Arena*);
template<> ::Protocol::C_SHOOTPROJECTILE* Arena::CreateMaybeMessage<::Protocol::C_SHOOTPROJECTILE>(Arena*);
template<> ::Protocol::C_STATUS* Arena::CreateMaybeMessage<::Protocol::C_STATUS>(Arena*);
template<> ::Protocol::C_SWAP_INVENTORY_TO_INVENTORY* Arena::CreateMaybeMessage<::Protocol::C_SWAP_INVENTORY_TO_INVENTORY>(Arena*);
template<> ::Protocol::C_TRY_PICK_ITEM_TO_INVENTORY* Arena::CreateMaybeMessage<::Protocol::C_TRY_PICK_ITEM_TO_INVENTORY>(Arena*);
template<> ::Protocol::S_BUY_SHOP_ITEM* Arena::CreateMaybeMessage<::Protocol::S_BUY_SHOP_ITEM>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_CREATEACCOUNT* Arena::CreateMaybeMessage<::Protocol::S_CREATEACCOUNT>(Arena*);
template<> ::Protocol::S_DEATH* Arena::CreateMaybeMessage<::Protocol::S_DEATH>(Arena*);
template<> ::Protocol::S_DESPAWN* Arena::CreateMaybeMessage<::Protocol::S_DESPAWN>(Arena*);
template<> ::Protocol::S_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::S_ENTER_GAME>(Arena*);
template<> ::Protocol::S_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::S_ENTER_ROOM>(Arena*);
template<> ::Protocol::S_GOLD* Arena::CreateMaybeMessage<::Protocol::S_GOLD>(Arena*);
template<> ::Protocol::S_HITDAMAGE* Arena::CreateMaybeMessage<::Protocol::S_HITDAMAGE>(Arena*);
template<> ::Protocol::S_INVENTORY_REMOVE* Arena::CreateMaybeMessage<::Protocol::S_INVENTORY_REMOVE>(Arena*);
template<> ::Protocol::S_INVENTORY_UPDATE* Arena::CreateMaybeMessage<::Protocol::S_INVENTORY_UPDATE>(Arena*);
template<> ::Protocol::S_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::S_LEAVE_GAME>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_LOGOUT* Arena::CreateMaybeMessage<::Protocol::S_LOGOUT>(Arena*);
template<> ::Protocol::S_MAIL_LIST* Arena::CreateMaybeMessage<::Protocol::S_MAIL_LIST>(Arena*);
template<> ::Protocol::S_MAIL_SEND* Arena::CreateMaybeMessage<::Protocol::S_MAIL_SEND>(Arena*);
template<> ::Protocol::S_MELEEATTACK* Arena::CreateMaybeMessage<::Protocol::S_MELEEATTACK>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_PATHFINDING* Arena::CreateMaybeMessage<::Protocol::S_PATHFINDING>(Arena*);
template<> ::Protocol::S_SHOOTPROJECTILE* Arena::CreateMaybeMessage<::Protocol::S_SHOOTPROJECTILE>(Arena*);
template<> ::Protocol::S_SHOP_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::S_SHOP_ITEM_LIST>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
template<> ::Protocol::S_SPAWNBOX* Arena::CreateMaybeMessage<::Protocol::S_SPAWNBOX>(Arena*);
template<> ::Protocol::S_SPAWNITEM* Arena::CreateMaybeMessage<::Protocol::S_SPAWNITEM>(Arena*);
template<> ::Protocol::S_SPAWNMONSTER* Arena::CreateMaybeMessage<::Protocol::S_SPAWNMONSTER>(Arena*);
template<> ::Protocol::S_SPAWNPLAYER* Arena::CreateMaybeMessage<::Protocol::S_SPAWNPLAYER>(Arena*);
template<> ::Protocol::S_STATUS* Arena::CreateMaybeMessage<::Protocol::S_STATUS>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_CREATEACCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CREATEACCOUNT) */ {
 public:
  inline C_CREATEACCOUNT() : C_CREATEACCOUNT(nullptr) {}
  ~C_CREATEACCOUNT() override;
  explicit PROTOBUF_CONSTEXPR C_CREATEACCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATEACCOUNT(const C_CREATEACCOUNT& from);
  C_CREATEACCOUNT(C_CREATEACCOUNT&& from) noexcept
    : C_CREATEACCOUNT() {
    *this = ::std::move(from);
  }

  inline C_CREATEACCOUNT& operator=(const C_CREATEACCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATEACCOUNT& operator=(C_CREATEACCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATEACCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATEACCOUNT* internal_default_instance() {
    return reinterpret_cast<const C_CREATEACCOUNT*>(
               &_C_CREATEACCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_CREATEACCOUNT& a, C_CREATEACCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATEACCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATEACCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CREATEACCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CREATEACCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CREATEACCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CREATEACCOUNT& from) {
    C_CREATEACCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CREATEACCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CREATEACCOUNT";
  }
  protected:
  explicit C_CREATEACCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPasswardFieldNumber = 2,
  };
  // string playerId = 1;
  void clear_playerid();
  const std::string& playerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playerid();
  PROTOBUF_NODISCARD std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // string passward = 2;
  void clear_passward();
  const std::string& passward() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passward(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passward();
  PROTOBUF_NODISCARD std::string* release_passward();
  void set_allocated_passward(std::string* passward);
  private:
  const std::string& _internal_passward() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passward(const std::string& value);
  std::string* _internal_mutable_passward();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CREATEACCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passward_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CREATEACCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CREATEACCOUNT) */ {
 public:
  inline S_CREATEACCOUNT() : S_CREATEACCOUNT(nullptr) {}
  ~S_CREATEACCOUNT() override;
  explicit PROTOBUF_CONSTEXPR S_CREATEACCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CREATEACCOUNT(const S_CREATEACCOUNT& from);
  S_CREATEACCOUNT(S_CREATEACCOUNT&& from) noexcept
    : S_CREATEACCOUNT() {
    *this = ::std::move(from);
  }

  inline S_CREATEACCOUNT& operator=(const S_CREATEACCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CREATEACCOUNT& operator=(S_CREATEACCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CREATEACCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CREATEACCOUNT* internal_default_instance() {
    return reinterpret_cast<const S_CREATEACCOUNT*>(
               &_S_CREATEACCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_CREATEACCOUNT& a, S_CREATEACCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CREATEACCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CREATEACCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CREATEACCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CREATEACCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CREATEACCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CREATEACCOUNT& from) {
    S_CREATEACCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CREATEACCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CREATEACCOUNT";
  }
  protected:
  explicit S_CREATEACCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CREATEACCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LOGIN& from) {
    C_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPasswardFieldNumber = 2,
  };
  // string playerId = 1;
  void clear_playerid();
  const std::string& playerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playerid();
  PROTOBUF_NODISCARD std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // string passward = 2;
  void clear_passward();
  const std::string& passward() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passward(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passward();
  PROTOBUF_NODISCARD std::string* release_passward();
  void set_allocated_passward(std::string* passward);
  private:
  const std::string& _internal_passward() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passward(const std::string& value);
  std::string* _internal_mutable_passward();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passward_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOGIN& from) {
    S_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kPlayerIndexFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.PlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // uint64 playerIndex = 3;
  void clear_playerindex();
  uint64_t playerindex() const;
  void set_playerindex(uint64_t value);
  private:
  uint64_t _internal_playerindex() const;
  void _internal_set_playerindex(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    uint64_t playerindex_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOGOUT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGOUT) */ {
 public:
  inline C_LOGOUT() : C_LOGOUT(nullptr) {}
  ~C_LOGOUT() override;
  explicit PROTOBUF_CONSTEXPR C_LOGOUT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGOUT(const C_LOGOUT& from);
  C_LOGOUT(C_LOGOUT&& from) noexcept
    : C_LOGOUT() {
    *this = ::std::move(from);
  }

  inline C_LOGOUT& operator=(const C_LOGOUT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGOUT& operator=(C_LOGOUT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGOUT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGOUT* internal_default_instance() {
    return reinterpret_cast<const C_LOGOUT*>(
               &_C_LOGOUT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_LOGOUT& a, C_LOGOUT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGOUT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGOUT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGOUT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGOUT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGOUT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LOGOUT& from) {
    C_LOGOUT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGOUT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGOUT";
  }
  protected:
  explicit C_LOGOUT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // string playerId = 1;
  void clear_playerid();
  const std::string& playerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playerid();
  PROTOBUF_NODISCARD std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGOUT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGOUT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGOUT) */ {
 public:
  inline S_LOGOUT() : S_LOGOUT(nullptr) {}
  ~S_LOGOUT() override;
  explicit PROTOBUF_CONSTEXPR S_LOGOUT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGOUT(const S_LOGOUT& from);
  S_LOGOUT(S_LOGOUT&& from) noexcept
    : S_LOGOUT() {
    *this = ::std::move(from);
  }

  inline S_LOGOUT& operator=(const S_LOGOUT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGOUT& operator=(S_LOGOUT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGOUT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGOUT* internal_default_instance() {
    return reinterpret_cast<const S_LOGOUT*>(
               &_S_LOGOUT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_LOGOUT& a, S_LOGOUT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGOUT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGOUT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGOUT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGOUT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGOUT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOGOUT& from) {
    S_LOGOUT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGOUT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGOUT";
  }
  protected:
  explicit S_LOGOUT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIndexFieldNumber = 1,
  };
  // uint64 playerIndex = 1;
  void clear_playerindex();
  uint64_t playerindex() const;
  void set_playerindex(uint64_t value);
  private:
  uint64_t _internal_playerindex() const;
  void _internal_set_playerindex(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGOUT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_GAME& from) {
    C_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIndexFieldNumber = 1,
  };
  // uint64 playerIndex = 1;
  void clear_playerindex();
  uint64_t playerindex() const;
  void set_playerindex(uint64_t value);
  private:
  uint64_t _internal_playerindex() const;
  void _internal_set_playerindex(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_GAME) */ {
 public:
  inline S_ENTER_GAME() : S_ENTER_GAME(nullptr) {}
  ~S_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_GAME(const S_ENTER_GAME& from);
  S_ENTER_GAME(S_ENTER_GAME&& from) noexcept
    : S_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline S_ENTER_GAME& operator=(const S_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_GAME& operator=(S_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_GAME*>(
               &_S_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_ENTER_GAME& a, S_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER_GAME& from) {
    S_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_GAME";
  }
  protected:
  explicit S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .Protocol.PlayerInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::PlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_player();
  ::Protocol::PlayerInfo* mutable_player();
  void set_allocated_player(::Protocol::PlayerInfo* player);
  private:
  const ::Protocol::PlayerInfo& _internal_player() const;
  ::Protocol::PlayerInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::PlayerInfo* player);
  ::Protocol::PlayerInfo* unsafe_arena_release_player();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* player_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_ROOM) */ {
 public:
  inline C_ENTER_ROOM() : C_ENTER_ROOM(nullptr) {}
  ~C_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_ROOM(const C_ENTER_ROOM& from);
  C_ENTER_ROOM(C_ENTER_ROOM&& from) noexcept
    : C_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline C_ENTER_ROOM& operator=(const C_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_ROOM& operator=(C_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_ROOM*>(
               &_C_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(C_ENTER_ROOM& a, C_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_ROOM& from) {
    C_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_ROOM";
  }
  protected:
  explicit C_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kPlayerFieldNumber = 2,
  };
  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // .Protocol.PlayerInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::PlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_player();
  ::Protocol::PlayerInfo* mutable_player();
  void set_allocated_player(::Protocol::PlayerInfo* player);
  private:
  const ::Protocol::PlayerInfo& _internal_player() const;
  ::Protocol::PlayerInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::PlayerInfo* player);
  ::Protocol::PlayerInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::Protocol::PlayerInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_ROOM) */ {
 public:
  inline S_ENTER_ROOM() : S_ENTER_ROOM(nullptr) {}
  ~S_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_ROOM(const S_ENTER_ROOM& from);
  S_ENTER_ROOM(S_ENTER_ROOM&& from) noexcept
    : S_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline S_ENTER_ROOM& operator=(const S_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_ROOM& operator=(S_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_ROOM*>(
               &_S_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_ENTER_ROOM& a, S_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER_ROOM& from) {
    S_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_ROOM";
  }
  protected:
  explicit S_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .Protocol.PlayerInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::PlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_player();
  ::Protocol::PlayerInfo* mutable_player();
  void set_allocated_player(::Protocol::PlayerInfo* player);
  private:
  const ::Protocol::PlayerInfo& _internal_player() const;
  ::Protocol::PlayerInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::PlayerInfo* player);
  ::Protocol::PlayerInfo* unsafe_arena_release_player();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* player_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LEAVE_GAME) */ {
 public:
  inline C_LEAVE_GAME() : C_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE_GAME(const C_LEAVE_GAME& from);
  C_LEAVE_GAME(C_LEAVE_GAME&& from) noexcept
    : C_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline C_LEAVE_GAME& operator=(const C_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE_GAME& operator=(C_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE_GAME*>(
               &_C_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_LEAVE_GAME& a, C_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEAVE_GAME";
  }
  protected:
  explicit C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE_GAME) */ {
 public:
  inline S_LEAVE_GAME() : S_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_GAME(const S_LEAVE_GAME& from);
  S_LEAVE_GAME(S_LEAVE_GAME&& from) noexcept
    : S_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_GAME& operator=(const S_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_GAME& operator=(S_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_GAME*>(
               &_S_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_LEAVE_GAME& a, S_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE_GAME";
  }
  protected:
  explicit S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWN& from) {
    S_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kMonstersFieldNumber = 2,
  };
  // repeated .Protocol.ObjectInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::ObjectInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_players();
  private:
  const ::Protocol::ObjectInfo& _internal_players(int index) const;
  ::Protocol::ObjectInfo* _internal_add_players();
  public:
  const ::Protocol::ObjectInfo& players(int index) const;
  ::Protocol::ObjectInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      players() const;

  // repeated .Protocol.ObjectInfo monsters = 2;
  int monsters_size() const;
  private:
  int _internal_monsters_size() const;
  public:
  void clear_monsters();
  ::Protocol::ObjectInfo* mutable_monsters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_monsters();
  private:
  const ::Protocol::ObjectInfo& _internal_monsters(int index) const;
  ::Protocol::ObjectInfo* _internal_add_monsters();
  public:
  const ::Protocol::ObjectInfo& monsters(int index) const;
  ::Protocol::ObjectInfo* add_monsters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      monsters() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > players_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > monsters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWNPLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWNPLAYER) */ {
 public:
  inline S_SPAWNPLAYER() : S_SPAWNPLAYER(nullptr) {}
  ~S_SPAWNPLAYER() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWNPLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWNPLAYER(const S_SPAWNPLAYER& from);
  S_SPAWNPLAYER(S_SPAWNPLAYER&& from) noexcept
    : S_SPAWNPLAYER() {
    *this = ::std::move(from);
  }

  inline S_SPAWNPLAYER& operator=(const S_SPAWNPLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWNPLAYER& operator=(S_SPAWNPLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWNPLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWNPLAYER* internal_default_instance() {
    return reinterpret_cast<const S_SPAWNPLAYER*>(
               &_S_SPAWNPLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_SPAWNPLAYER& a, S_SPAWNPLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWNPLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWNPLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWNPLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWNPLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWNPLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWNPLAYER& from) {
    S_SPAWNPLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWNPLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWNPLAYER";
  }
  protected:
  explicit S_SPAWNPLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Protocol.PlayerInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWNPLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWNMONSTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWNMONSTER) */ {
 public:
  inline S_SPAWNMONSTER() : S_SPAWNMONSTER(nullptr) {}
  ~S_SPAWNMONSTER() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWNMONSTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWNMONSTER(const S_SPAWNMONSTER& from);
  S_SPAWNMONSTER(S_SPAWNMONSTER&& from) noexcept
    : S_SPAWNMONSTER() {
    *this = ::std::move(from);
  }

  inline S_SPAWNMONSTER& operator=(const S_SPAWNMONSTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWNMONSTER& operator=(S_SPAWNMONSTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWNMONSTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWNMONSTER* internal_default_instance() {
    return reinterpret_cast<const S_SPAWNMONSTER*>(
               &_S_SPAWNMONSTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_SPAWNMONSTER& a, S_SPAWNMONSTER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWNMONSTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWNMONSTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWNMONSTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWNMONSTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWNMONSTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWNMONSTER& from) {
    S_SPAWNMONSTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWNMONSTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWNMONSTER";
  }
  protected:
  explicit S_SPAWNMONSTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonstersFieldNumber = 1,
  };
  // repeated .Protocol.MonsterInfo monsters = 1;
  int monsters_size() const;
  private:
  int _internal_monsters_size() const;
  public:
  void clear_monsters();
  ::Protocol::MonsterInfo* mutable_monsters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MonsterInfo >*
      mutable_monsters();
  private:
  const ::Protocol::MonsterInfo& _internal_monsters(int index) const;
  ::Protocol::MonsterInfo* _internal_add_monsters();
  public:
  const ::Protocol::MonsterInfo& monsters(int index) const;
  ::Protocol::MonsterInfo* add_monsters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MonsterInfo >&
      monsters() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWNMONSTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MonsterInfo > monsters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_DROPITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_DROPITEM) */ {
 public:
  inline C_DROPITEM() : C_DROPITEM(nullptr) {}
  ~C_DROPITEM() override;
  explicit PROTOBUF_CONSTEXPR C_DROPITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_DROPITEM(const C_DROPITEM& from);
  C_DROPITEM(C_DROPITEM&& from) noexcept
    : C_DROPITEM() {
    *this = ::std::move(from);
  }

  inline C_DROPITEM& operator=(const C_DROPITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_DROPITEM& operator=(C_DROPITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_DROPITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_DROPITEM* internal_default_instance() {
    return reinterpret_cast<const C_DROPITEM*>(
               &_C_DROPITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_DROPITEM& a, C_DROPITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_DROPITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_DROPITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_DROPITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_DROPITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_DROPITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_DROPITEM& from) {
    C_DROPITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_DROPITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_DROPITEM";
  }
  protected:
  explicit C_DROPITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.C_DROPITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_INVENTORY_UPDATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_INVENTORY_UPDATE) */ {
 public:
  inline C_INVENTORY_UPDATE() : C_INVENTORY_UPDATE(nullptr) {}
  ~C_INVENTORY_UPDATE() override;
  explicit PROTOBUF_CONSTEXPR C_INVENTORY_UPDATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_INVENTORY_UPDATE(const C_INVENTORY_UPDATE& from);
  C_INVENTORY_UPDATE(C_INVENTORY_UPDATE&& from) noexcept
    : C_INVENTORY_UPDATE() {
    *this = ::std::move(from);
  }

  inline C_INVENTORY_UPDATE& operator=(const C_INVENTORY_UPDATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_INVENTORY_UPDATE& operator=(C_INVENTORY_UPDATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_INVENTORY_UPDATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_INVENTORY_UPDATE* internal_default_instance() {
    return reinterpret_cast<const C_INVENTORY_UPDATE*>(
               &_C_INVENTORY_UPDATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(C_INVENTORY_UPDATE& a, C_INVENTORY_UPDATE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_INVENTORY_UPDATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_INVENTORY_UPDATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_INVENTORY_UPDATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_INVENTORY_UPDATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_INVENTORY_UPDATE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_INVENTORY_UPDATE& from) {
    C_INVENTORY_UPDATE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_INVENTORY_UPDATE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_INVENTORY_UPDATE";
  }
  protected:
  explicit C_INVENTORY_UPDATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kItemsFieldNumber = 2,
  };
  // repeated uint32 index = 1;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  uint32_t _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_index() const;
  void _internal_add_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_index();
  public:
  uint32_t index(int index) const;
  void set_index(int index, uint32_t value);
  void add_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_index();

  // repeated .Protocol.ItemInfo items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.C_INVENTORY_UPDATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > index_;
    mutable std::atomic<int> _index_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_INVENTORY_UPDATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_INVENTORY_UPDATE) */ {
 public:
  inline S_INVENTORY_UPDATE() : S_INVENTORY_UPDATE(nullptr) {}
  ~S_INVENTORY_UPDATE() override;
  explicit PROTOBUF_CONSTEXPR S_INVENTORY_UPDATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_INVENTORY_UPDATE(const S_INVENTORY_UPDATE& from);
  S_INVENTORY_UPDATE(S_INVENTORY_UPDATE&& from) noexcept
    : S_INVENTORY_UPDATE() {
    *this = ::std::move(from);
  }

  inline S_INVENTORY_UPDATE& operator=(const S_INVENTORY_UPDATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_INVENTORY_UPDATE& operator=(S_INVENTORY_UPDATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_INVENTORY_UPDATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_INVENTORY_UPDATE* internal_default_instance() {
    return reinterpret_cast<const S_INVENTORY_UPDATE*>(
               &_S_INVENTORY_UPDATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_INVENTORY_UPDATE& a, S_INVENTORY_UPDATE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_INVENTORY_UPDATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_INVENTORY_UPDATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_INVENTORY_UPDATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_INVENTORY_UPDATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_INVENTORY_UPDATE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_INVENTORY_UPDATE& from) {
    S_INVENTORY_UPDATE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_INVENTORY_UPDATE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_INVENTORY_UPDATE";
  }
  protected:
  explicit S_INVENTORY_UPDATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
    kItemsFieldNumber = 3,
    kObjectIdFieldNumber = 1,
  };
  // repeated uint32 index = 2;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  uint32_t _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_index() const;
  void _internal_add_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_index();
  public:
  uint32_t index(int index) const;
  void set_index(int index, uint32_t value);
  void add_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_index();

  // repeated .Protocol.ItemInfo items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_INVENTORY_UPDATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > index_;
    mutable std::atomic<int> _index_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_INVENTORY_REMOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_INVENTORY_REMOVE) */ {
 public:
  inline C_INVENTORY_REMOVE() : C_INVENTORY_REMOVE(nullptr) {}
  ~C_INVENTORY_REMOVE() override;
  explicit PROTOBUF_CONSTEXPR C_INVENTORY_REMOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_INVENTORY_REMOVE(const C_INVENTORY_REMOVE& from);
  C_INVENTORY_REMOVE(C_INVENTORY_REMOVE&& from) noexcept
    : C_INVENTORY_REMOVE() {
    *this = ::std::move(from);
  }

  inline C_INVENTORY_REMOVE& operator=(const C_INVENTORY_REMOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_INVENTORY_REMOVE& operator=(C_INVENTORY_REMOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_INVENTORY_REMOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_INVENTORY_REMOVE* internal_default_instance() {
    return reinterpret_cast<const C_INVENTORY_REMOVE*>(
               &_C_INVENTORY_REMOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(C_INVENTORY_REMOVE& a, C_INVENTORY_REMOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_INVENTORY_REMOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_INVENTORY_REMOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_INVENTORY_REMOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_INVENTORY_REMOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_INVENTORY_REMOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_INVENTORY_REMOVE& from) {
    C_INVENTORY_REMOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_INVENTORY_REMOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_INVENTORY_REMOVE";
  }
  protected:
  explicit C_INVENTORY_REMOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kCountItemsFieldNumber = 2,
  };
  // repeated uint32 index = 1;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  uint32_t _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_index() const;
  void _internal_add_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_index();
  public:
  uint32_t index(int index) const;
  void set_index(int index, uint32_t value);
  void add_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_index();

  // repeated uint32 count_items = 2;
  int count_items_size() const;
  private:
  int _internal_count_items_size() const;
  public:
  void clear_count_items();
  private:
  uint32_t _internal_count_items(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_count_items() const;
  void _internal_add_count_items(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_count_items();
  public:
  uint32_t count_items(int index) const;
  void set_count_items(int index, uint32_t value);
  void add_count_items(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      count_items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_count_items();

  // @@protoc_insertion_point(class_scope:Protocol.C_INVENTORY_REMOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > index_;
    mutable std::atomic<int> _index_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > count_items_;
    mutable std::atomic<int> _count_items_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_INVENTORY_REMOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_INVENTORY_REMOVE) */ {
 public:
  inline S_INVENTORY_REMOVE() : S_INVENTORY_REMOVE(nullptr) {}
  ~S_INVENTORY_REMOVE() override;
  explicit PROTOBUF_CONSTEXPR S_INVENTORY_REMOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_INVENTORY_REMOVE(const S_INVENTORY_REMOVE& from);
  S_INVENTORY_REMOVE(S_INVENTORY_REMOVE&& from) noexcept
    : S_INVENTORY_REMOVE() {
    *this = ::std::move(from);
  }

  inline S_INVENTORY_REMOVE& operator=(const S_INVENTORY_REMOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_INVENTORY_REMOVE& operator=(S_INVENTORY_REMOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_INVENTORY_REMOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_INVENTORY_REMOVE* internal_default_instance() {
    return reinterpret_cast<const S_INVENTORY_REMOVE*>(
               &_S_INVENTORY_REMOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_INVENTORY_REMOVE& a, S_INVENTORY_REMOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_INVENTORY_REMOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_INVENTORY_REMOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_INVENTORY_REMOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_INVENTORY_REMOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_INVENTORY_REMOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_INVENTORY_REMOVE& from) {
    S_INVENTORY_REMOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_INVENTORY_REMOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_INVENTORY_REMOVE";
  }
  protected:
  explicit S_INVENTORY_REMOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
    kCountItemsFieldNumber = 3,
    kObjectIdFieldNumber = 1,
  };
  // repeated uint32 index = 2;
  int index_size() const;
  private:
  int _internal_index_size() const;
  public:
  void clear_index();
  private:
  uint32_t _internal_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_index() const;
  void _internal_add_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_index();
  public:
  uint32_t index(int index) const;
  void set_index(int index, uint32_t value);
  void add_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_index();

  // repeated uint32 count_items = 3;
  int count_items_size() const;
  private:
  int _internal_count_items_size() const;
  public:
  void clear_count_items();
  private:
  uint32_t _internal_count_items(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_count_items() const;
  void _internal_add_count_items(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_count_items();
  public:
  uint32_t count_items(int index) const;
  void set_count_items(int index, uint32_t value);
  void add_count_items(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      count_items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_count_items();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_INVENTORY_REMOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > index_;
    mutable std::atomic<int> _index_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > count_items_;
    mutable std::atomic<int> _count_items_cached_byte_size_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SWAP_INVENTORY_TO_INVENTORY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SWAP_INVENTORY_TO_INVENTORY) */ {
 public:
  inline C_SWAP_INVENTORY_TO_INVENTORY() : C_SWAP_INVENTORY_TO_INVENTORY(nullptr) {}
  ~C_SWAP_INVENTORY_TO_INVENTORY() override;
  explicit PROTOBUF_CONSTEXPR C_SWAP_INVENTORY_TO_INVENTORY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SWAP_INVENTORY_TO_INVENTORY(const C_SWAP_INVENTORY_TO_INVENTORY& from);
  C_SWAP_INVENTORY_TO_INVENTORY(C_SWAP_INVENTORY_TO_INVENTORY&& from) noexcept
    : C_SWAP_INVENTORY_TO_INVENTORY() {
    *this = ::std::move(from);
  }

  inline C_SWAP_INVENTORY_TO_INVENTORY& operator=(const C_SWAP_INVENTORY_TO_INVENTORY& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SWAP_INVENTORY_TO_INVENTORY& operator=(C_SWAP_INVENTORY_TO_INVENTORY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SWAP_INVENTORY_TO_INVENTORY& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SWAP_INVENTORY_TO_INVENTORY* internal_default_instance() {
    return reinterpret_cast<const C_SWAP_INVENTORY_TO_INVENTORY*>(
               &_C_SWAP_INVENTORY_TO_INVENTORY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(C_SWAP_INVENTORY_TO_INVENTORY& a, C_SWAP_INVENTORY_TO_INVENTORY& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SWAP_INVENTORY_TO_INVENTORY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SWAP_INVENTORY_TO_INVENTORY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SWAP_INVENTORY_TO_INVENTORY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SWAP_INVENTORY_TO_INVENTORY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SWAP_INVENTORY_TO_INVENTORY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SWAP_INVENTORY_TO_INVENTORY& from) {
    C_SWAP_INVENTORY_TO_INVENTORY::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SWAP_INVENTORY_TO_INVENTORY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SWAP_INVENTORY_TO_INVENTORY";
  }
  protected:
  explicit C_SWAP_INVENTORY_TO_INVENTORY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromObjectIdFieldNumber = 1,
    kFromIndexFieldNumber = 2,
    kFromCountFieldNumber = 3,
    kToObjectIdFieldNumber = 4,
    kToIndexFieldNumber = 5,
  };
  // uint64 from_object_id = 1;
  void clear_from_object_id();
  uint64_t from_object_id() const;
  void set_from_object_id(uint64_t value);
  private:
  uint64_t _internal_from_object_id() const;
  void _internal_set_from_object_id(uint64_t value);
  public:

  // uint32 from_index = 2;
  void clear_from_index();
  uint32_t from_index() const;
  void set_from_index(uint32_t value);
  private:
  uint32_t _internal_from_index() const;
  void _internal_set_from_index(uint32_t value);
  public:

  // uint32 from_count = 3;
  void clear_from_count();
  uint32_t from_count() const;
  void set_from_count(uint32_t value);
  private:
  uint32_t _internal_from_count() const;
  void _internal_set_from_count(uint32_t value);
  public:

  // uint64 to_object_id = 4;
  void clear_to_object_id();
  uint64_t to_object_id() const;
  void set_to_object_id(uint64_t value);
  private:
  uint64_t _internal_to_object_id() const;
  void _internal_set_to_object_id(uint64_t value);
  public:

  // uint32 to_index = 5;
  void clear_to_index();
  uint32_t to_index() const;
  void set_to_index(uint32_t value);
  private:
  uint32_t _internal_to_index() const;
  void _internal_set_to_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SWAP_INVENTORY_TO_INVENTORY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t from_object_id_;
    uint32_t from_index_;
    uint32_t from_count_;
    uint64_t to_object_id_;
    uint32_t to_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_TRY_PICK_ITEM_TO_INVENTORY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY) */ {
 public:
  inline C_TRY_PICK_ITEM_TO_INVENTORY() : C_TRY_PICK_ITEM_TO_INVENTORY(nullptr) {}
  ~C_TRY_PICK_ITEM_TO_INVENTORY() override;
  explicit PROTOBUF_CONSTEXPR C_TRY_PICK_ITEM_TO_INVENTORY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_TRY_PICK_ITEM_TO_INVENTORY(const C_TRY_PICK_ITEM_TO_INVENTORY& from);
  C_TRY_PICK_ITEM_TO_INVENTORY(C_TRY_PICK_ITEM_TO_INVENTORY&& from) noexcept
    : C_TRY_PICK_ITEM_TO_INVENTORY() {
    *this = ::std::move(from);
  }

  inline C_TRY_PICK_ITEM_TO_INVENTORY& operator=(const C_TRY_PICK_ITEM_TO_INVENTORY& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_TRY_PICK_ITEM_TO_INVENTORY& operator=(C_TRY_PICK_ITEM_TO_INVENTORY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_TRY_PICK_ITEM_TO_INVENTORY& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_TRY_PICK_ITEM_TO_INVENTORY* internal_default_instance() {
    return reinterpret_cast<const C_TRY_PICK_ITEM_TO_INVENTORY*>(
               &_C_TRY_PICK_ITEM_TO_INVENTORY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_TRY_PICK_ITEM_TO_INVENTORY& a, C_TRY_PICK_ITEM_TO_INVENTORY& b) {
    a.Swap(&b);
  }
  inline void Swap(C_TRY_PICK_ITEM_TO_INVENTORY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_TRY_PICK_ITEM_TO_INVENTORY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_TRY_PICK_ITEM_TO_INVENTORY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_TRY_PICK_ITEM_TO_INVENTORY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_TRY_PICK_ITEM_TO_INVENTORY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_TRY_PICK_ITEM_TO_INVENTORY& from) {
    C_TRY_PICK_ITEM_TO_INVENTORY::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_TRY_PICK_ITEM_TO_INVENTORY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_TRY_PICK_ITEM_TO_INVENTORY";
  }
  protected:
  explicit C_TRY_PICK_ITEM_TO_INVENTORY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kToObjectIdFieldNumber = 2,
    kToIndexFieldNumber = 3,
  };
  // uint64 item_id = 1;
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // uint64 to_object_id = 2;
  void clear_to_object_id();
  uint64_t to_object_id() const;
  void set_to_object_id(uint64_t value);
  private:
  uint64_t _internal_to_object_id() const;
  void _internal_set_to_object_id(uint64_t value);
  public:

  // uint32 to_index = 3;
  void clear_to_index();
  uint32_t to_index() const;
  void set_to_index(uint32_t value);
  private:
  uint32_t _internal_to_index() const;
  void _internal_set_to_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t item_id_;
    uint64_t to_object_id_;
    uint32_t to_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWNITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWNITEM) */ {
 public:
  inline S_SPAWNITEM() : S_SPAWNITEM(nullptr) {}
  ~S_SPAWNITEM() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWNITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWNITEM(const S_SPAWNITEM& from);
  S_SPAWNITEM(S_SPAWNITEM&& from) noexcept
    : S_SPAWNITEM() {
    *this = ::std::move(from);
  }

  inline S_SPAWNITEM& operator=(const S_SPAWNITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWNITEM& operator=(S_SPAWNITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWNITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWNITEM* internal_default_instance() {
    return reinterpret_cast<const S_SPAWNITEM*>(
               &_S_SPAWNITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_SPAWNITEM& a, S_SPAWNITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWNITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWNITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWNITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWNITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWNITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWNITEM& from) {
    S_SPAWNITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWNITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWNITEM";
  }
  protected:
  explicit S_SPAWNITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ObjectItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ObjectItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ObjectItemInfo& _internal_items(int index) const;
  ::Protocol::ObjectItemInfo* _internal_add_items();
  public:
  const ::Protocol::ObjectItemInfo& items(int index) const;
  ::Protocol::ObjectItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWNITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWNBOX final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWNBOX) */ {
 public:
  inline S_SPAWNBOX() : S_SPAWNBOX(nullptr) {}
  ~S_SPAWNBOX() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWNBOX(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWNBOX(const S_SPAWNBOX& from);
  S_SPAWNBOX(S_SPAWNBOX&& from) noexcept
    : S_SPAWNBOX() {
    *this = ::std::move(from);
  }

  inline S_SPAWNBOX& operator=(const S_SPAWNBOX& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWNBOX& operator=(S_SPAWNBOX&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWNBOX& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWNBOX* internal_default_instance() {
    return reinterpret_cast<const S_SPAWNBOX*>(
               &_S_SPAWNBOX_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_SPAWNBOX& a, S_SPAWNBOX& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWNBOX* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWNBOX* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWNBOX* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWNBOX>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWNBOX& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWNBOX& from) {
    S_SPAWNBOX::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWNBOX* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWNBOX";
  }
  protected:
  explicit S_SPAWNBOX(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 1,
  };
  // repeated .Protocol.ItemBoxInfo box = 1;
  int box_size() const;
  private:
  int _internal_box_size() const;
  public:
  void clear_box();
  ::Protocol::ItemBoxInfo* mutable_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemBoxInfo >*
      mutable_box();
  private:
  const ::Protocol::ItemBoxInfo& _internal_box(int index) const;
  ::Protocol::ItemBoxInfo* _internal_add_box();
  public:
  const ::Protocol::ItemBoxInfo& box(int index) const;
  ::Protocol::ItemBoxInfo* add_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemBoxInfo >&
      box() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWNBOX)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemBoxInfo > box_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DESPAWN& from) {
    S_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  uint64_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_object_ids();
  public:
  uint64_t object_ids(int index) const;
  void set_object_ids(int index, uint64_t value);
  void add_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > object_ids_;
    mutable std::atomic<int> _object_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DEATH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DEATH) */ {
 public:
  inline S_DEATH() : S_DEATH(nullptr) {}
  ~S_DEATH() override;
  explicit PROTOBUF_CONSTEXPR S_DEATH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DEATH(const S_DEATH& from);
  S_DEATH(S_DEATH&& from) noexcept
    : S_DEATH() {
    *this = ::std::move(from);
  }

  inline S_DEATH& operator=(const S_DEATH& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DEATH& operator=(S_DEATH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DEATH& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DEATH* internal_default_instance() {
    return reinterpret_cast<const S_DEATH*>(
               &_S_DEATH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(S_DEATH& a, S_DEATH& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DEATH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DEATH* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DEATH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DEATH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DEATH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DEATH& from) {
    S_DEATH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DEATH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DEATH";
  }
  protected:
  explicit S_DEATH(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // uint64 object_ids = 1;
  void clear_object_ids();
  uint64_t object_ids() const;
  void set_object_ids(uint64_t value);
  private:
  uint64_t _internal_object_ids() const;
  void _internal_set_object_ids(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DEATH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MOVE& from) {
    C_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.PosInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::PosInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_info();
  ::Protocol::PosInfo* mutable_info();
  void set_allocated_info(::Protocol::PosInfo* info);
  private:
  const ::Protocol::PosInfo& _internal_info() const;
  ::Protocol::PosInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::PosInfo* info);
  ::Protocol::PosInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MOVE& from) {
    S_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.PosInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::PosInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_info();
  ::Protocol::PosInfo* mutable_info();
  void set_allocated_info(::Protocol::PosInfo* info);
  private:
  const ::Protocol::PosInfo& _internal_info() const;
  ::Protocol::PosInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::PosInfo* info);
  ::Protocol::PosInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_STATUS) */ {
 public:
  inline C_STATUS() : C_STATUS(nullptr) {}
  ~C_STATUS() override;
  explicit PROTOBUF_CONSTEXPR C_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_STATUS(const C_STATUS& from);
  C_STATUS(C_STATUS&& from) noexcept
    : C_STATUS() {
    *this = ::std::move(from);
  }

  inline C_STATUS& operator=(const C_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_STATUS& operator=(C_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_STATUS* internal_default_instance() {
    return reinterpret_cast<const C_STATUS*>(
               &_C_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(C_STATUS& a, C_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(C_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_STATUS& from) {
    C_STATUS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_STATUS";
  }
  protected:
  explicit C_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.StatusInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::StatusInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::StatusInfo* release_info();
  ::Protocol::StatusInfo* mutable_info();
  void set_allocated_info(::Protocol::StatusInfo* info);
  private:
  const ::Protocol::StatusInfo& _internal_info() const;
  ::Protocol::StatusInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::StatusInfo* info);
  ::Protocol::StatusInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::StatusInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_STATUS) */ {
 public:
  inline S_STATUS() : S_STATUS(nullptr) {}
  ~S_STATUS() override;
  explicit PROTOBUF_CONSTEXPR S_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_STATUS(const S_STATUS& from);
  S_STATUS(S_STATUS&& from) noexcept
    : S_STATUS() {
    *this = ::std::move(from);
  }

  inline S_STATUS& operator=(const S_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_STATUS& operator=(S_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_STATUS* internal_default_instance() {
    return reinterpret_cast<const S_STATUS*>(
               &_S_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_STATUS& a, S_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(S_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_STATUS& from) {
    S_STATUS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_STATUS";
  }
  protected:
  explicit S_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.StatusInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::StatusInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::StatusInfo* release_info();
  ::Protocol::StatusInfo* mutable_info();
  void set_allocated_info(::Protocol::StatusInfo* info);
  private:
  const ::Protocol::StatusInfo& _internal_info() const;
  ::Protocol::StatusInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::StatusInfo* info);
  ::Protocol::StatusInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::StatusInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHAT& from) {
    C_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint64_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHAT& from) {
    S_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MELEEATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MELEEATTACK) */ {
 public:
  inline S_MELEEATTACK() : S_MELEEATTACK(nullptr) {}
  ~S_MELEEATTACK() override;
  explicit PROTOBUF_CONSTEXPR S_MELEEATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MELEEATTACK(const S_MELEEATTACK& from);
  S_MELEEATTACK(S_MELEEATTACK&& from) noexcept
    : S_MELEEATTACK() {
    *this = ::std::move(from);
  }

  inline S_MELEEATTACK& operator=(const S_MELEEATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MELEEATTACK& operator=(S_MELEEATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MELEEATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MELEEATTACK* internal_default_instance() {
    return reinterpret_cast<const S_MELEEATTACK*>(
               &_S_MELEEATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(S_MELEEATTACK& a, S_MELEEATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MELEEATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MELEEATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MELEEATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MELEEATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MELEEATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MELEEATTACK& from) {
    S_MELEEATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MELEEATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MELEEATTACK";
  }
  protected:
  explicit S_MELEEATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityFieldNumber = 1,
  };
  // .Protocol.MeleeAttackInfo ability = 1;
  bool has_ability() const;
  private:
  bool _internal_has_ability() const;
  public:
  void clear_ability();
  const ::Protocol::MeleeAttackInfo& ability() const;
  PROTOBUF_NODISCARD ::Protocol::MeleeAttackInfo* release_ability();
  ::Protocol::MeleeAttackInfo* mutable_ability();
  void set_allocated_ability(::Protocol::MeleeAttackInfo* ability);
  private:
  const ::Protocol::MeleeAttackInfo& _internal_ability() const;
  ::Protocol::MeleeAttackInfo* _internal_mutable_ability();
  public:
  void unsafe_arena_set_allocated_ability(
      ::Protocol::MeleeAttackInfo* ability);
  ::Protocol::MeleeAttackInfo* unsafe_arena_release_ability();

  // @@protoc_insertion_point(class_scope:Protocol.S_MELEEATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::MeleeAttackInfo* ability_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MELEEATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MELEEATTACK) */ {
 public:
  inline C_MELEEATTACK() : C_MELEEATTACK(nullptr) {}
  ~C_MELEEATTACK() override;
  explicit PROTOBUF_CONSTEXPR C_MELEEATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MELEEATTACK(const C_MELEEATTACK& from);
  C_MELEEATTACK(C_MELEEATTACK&& from) noexcept
    : C_MELEEATTACK() {
    *this = ::std::move(from);
  }

  inline C_MELEEATTACK& operator=(const C_MELEEATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MELEEATTACK& operator=(C_MELEEATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MELEEATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MELEEATTACK* internal_default_instance() {
    return reinterpret_cast<const C_MELEEATTACK*>(
               &_C_MELEEATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(C_MELEEATTACK& a, C_MELEEATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MELEEATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MELEEATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MELEEATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MELEEATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MELEEATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MELEEATTACK& from) {
    C_MELEEATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MELEEATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MELEEATTACK";
  }
  protected:
  explicit C_MELEEATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityFieldNumber = 1,
  };
  // .Protocol.MeleeAttackInfo ability = 1;
  bool has_ability() const;
  private:
  bool _internal_has_ability() const;
  public:
  void clear_ability();
  const ::Protocol::MeleeAttackInfo& ability() const;
  PROTOBUF_NODISCARD ::Protocol::MeleeAttackInfo* release_ability();
  ::Protocol::MeleeAttackInfo* mutable_ability();
  void set_allocated_ability(::Protocol::MeleeAttackInfo* ability);
  private:
  const ::Protocol::MeleeAttackInfo& _internal_ability() const;
  ::Protocol::MeleeAttackInfo* _internal_mutable_ability();
  public:
  void unsafe_arena_set_allocated_ability(
      ::Protocol::MeleeAttackInfo* ability);
  ::Protocol::MeleeAttackInfo* unsafe_arena_release_ability();

  // @@protoc_insertion_point(class_scope:Protocol.C_MELEEATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::MeleeAttackInfo* ability_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PATHFINDING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PATHFINDING) */ {
 public:
  inline C_PATHFINDING() : C_PATHFINDING(nullptr) {}
  ~C_PATHFINDING() override;
  explicit PROTOBUF_CONSTEXPR C_PATHFINDING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PATHFINDING(const C_PATHFINDING& from);
  C_PATHFINDING(C_PATHFINDING&& from) noexcept
    : C_PATHFINDING() {
    *this = ::std::move(from);
  }

  inline C_PATHFINDING& operator=(const C_PATHFINDING& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PATHFINDING& operator=(C_PATHFINDING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PATHFINDING& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PATHFINDING* internal_default_instance() {
    return reinterpret_cast<const C_PATHFINDING*>(
               &_C_PATHFINDING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_PATHFINDING& a, C_PATHFINDING& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PATHFINDING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PATHFINDING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PATHFINDING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PATHFINDING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PATHFINDING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PATHFINDING& from) {
    C_PATHFINDING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PATHFINDING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PATHFINDING";
  }
  protected:
  explicit C_PATHFINDING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Protocol.PosInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Protocol::PosInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >*
      mutable_info();
  private:
  const ::Protocol::PosInfo& _internal_info(int index) const;
  ::Protocol::PosInfo* _internal_add_info();
  public:
  const ::Protocol::PosInfo& info(int index) const;
  ::Protocol::PosInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:Protocol.C_PATHFINDING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PATHFINDING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PATHFINDING) */ {
 public:
  inline S_PATHFINDING() : S_PATHFINDING(nullptr) {}
  ~S_PATHFINDING() override;
  explicit PROTOBUF_CONSTEXPR S_PATHFINDING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PATHFINDING(const S_PATHFINDING& from);
  S_PATHFINDING(S_PATHFINDING&& from) noexcept
    : S_PATHFINDING() {
    *this = ::std::move(from);
  }

  inline S_PATHFINDING& operator=(const S_PATHFINDING& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PATHFINDING& operator=(S_PATHFINDING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PATHFINDING& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PATHFINDING* internal_default_instance() {
    return reinterpret_cast<const S_PATHFINDING*>(
               &_S_PATHFINDING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(S_PATHFINDING& a, S_PATHFINDING& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PATHFINDING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PATHFINDING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PATHFINDING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PATHFINDING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PATHFINDING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PATHFINDING& from) {
    S_PATHFINDING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PATHFINDING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PATHFINDING";
  }
  protected:
  explicit S_PATHFINDING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Protocol.PosInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Protocol::PosInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >*
      mutable_info();
  private:
  const ::Protocol::PosInfo& _internal_info(int index) const;
  ::Protocol::PosInfo* _internal_add_info();
  public:
  const ::Protocol::PosInfo& info(int index) const;
  ::Protocol::PosInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_PATHFINDING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SHOOTPROJECTILE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SHOOTPROJECTILE) */ {
 public:
  inline C_SHOOTPROJECTILE() : C_SHOOTPROJECTILE(nullptr) {}
  ~C_SHOOTPROJECTILE() override;
  explicit PROTOBUF_CONSTEXPR C_SHOOTPROJECTILE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SHOOTPROJECTILE(const C_SHOOTPROJECTILE& from);
  C_SHOOTPROJECTILE(C_SHOOTPROJECTILE&& from) noexcept
    : C_SHOOTPROJECTILE() {
    *this = ::std::move(from);
  }

  inline C_SHOOTPROJECTILE& operator=(const C_SHOOTPROJECTILE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SHOOTPROJECTILE& operator=(C_SHOOTPROJECTILE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SHOOTPROJECTILE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SHOOTPROJECTILE* internal_default_instance() {
    return reinterpret_cast<const C_SHOOTPROJECTILE*>(
               &_C_SHOOTPROJECTILE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(C_SHOOTPROJECTILE& a, C_SHOOTPROJECTILE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SHOOTPROJECTILE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SHOOTPROJECTILE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SHOOTPROJECTILE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SHOOTPROJECTILE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SHOOTPROJECTILE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SHOOTPROJECTILE& from) {
    C_SHOOTPROJECTILE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SHOOTPROJECTILE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SHOOTPROJECTILE";
  }
  protected:
  explicit C_SHOOTPROJECTILE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kShooterYawFieldNumber = 2,
  };
  // repeated .Protocol.ProjectileInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Protocol::ProjectileInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >*
      mutable_info();
  private:
  const ::Protocol::ProjectileInfo& _internal_info(int index) const;
  ::Protocol::ProjectileInfo* _internal_add_info();
  public:
  const ::Protocol::ProjectileInfo& info(int index) const;
  ::Protocol::ProjectileInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >&
      info() const;

  // float shooter_yaw = 2;
  void clear_shooter_yaw();
  float shooter_yaw() const;
  void set_shooter_yaw(float value);
  private:
  float _internal_shooter_yaw() const;
  void _internal_set_shooter_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SHOOTPROJECTILE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo > info_;
    float shooter_yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SHOOTPROJECTILE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SHOOTPROJECTILE) */ {
 public:
  inline S_SHOOTPROJECTILE() : S_SHOOTPROJECTILE(nullptr) {}
  ~S_SHOOTPROJECTILE() override;
  explicit PROTOBUF_CONSTEXPR S_SHOOTPROJECTILE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SHOOTPROJECTILE(const S_SHOOTPROJECTILE& from);
  S_SHOOTPROJECTILE(S_SHOOTPROJECTILE&& from) noexcept
    : S_SHOOTPROJECTILE() {
    *this = ::std::move(from);
  }

  inline S_SHOOTPROJECTILE& operator=(const S_SHOOTPROJECTILE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SHOOTPROJECTILE& operator=(S_SHOOTPROJECTILE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SHOOTPROJECTILE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SHOOTPROJECTILE* internal_default_instance() {
    return reinterpret_cast<const S_SHOOTPROJECTILE*>(
               &_S_SHOOTPROJECTILE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(S_SHOOTPROJECTILE& a, S_SHOOTPROJECTILE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SHOOTPROJECTILE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SHOOTPROJECTILE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SHOOTPROJECTILE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SHOOTPROJECTILE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SHOOTPROJECTILE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SHOOTPROJECTILE& from) {
    S_SHOOTPROJECTILE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SHOOTPROJECTILE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SHOOTPROJECTILE";
  }
  protected:
  explicit S_SHOOTPROJECTILE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kShooteridFieldNumber = 1,
    kShooterYawFieldNumber = 3,
  };
  // repeated .Protocol.ProjectileInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Protocol::ProjectileInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >*
      mutable_info();
  private:
  const ::Protocol::ProjectileInfo& _internal_info(int index) const;
  ::Protocol::ProjectileInfo* _internal_add_info();
  public:
  const ::Protocol::ProjectileInfo& info(int index) const;
  ::Protocol::ProjectileInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >&
      info() const;

  // uint64 shooterid = 1;
  void clear_shooterid();
  uint64_t shooterid() const;
  void set_shooterid(uint64_t value);
  private:
  uint64_t _internal_shooterid() const;
  void _internal_set_shooterid(uint64_t value);
  public:

  // float shooter_yaw = 3;
  void clear_shooter_yaw();
  float shooter_yaw() const;
  void set_shooter_yaw(float value);
  private:
  float _internal_shooter_yaw() const;
  void _internal_set_shooter_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SHOOTPROJECTILE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo > info_;
    uint64_t shooterid_;
    float shooter_yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_HITDAMAGE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_HITDAMAGE) */ {
 public:
  inline C_HITDAMAGE() : C_HITDAMAGE(nullptr) {}
  ~C_HITDAMAGE() override;
  explicit PROTOBUF_CONSTEXPR C_HITDAMAGE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_HITDAMAGE(const C_HITDAMAGE& from);
  C_HITDAMAGE(C_HITDAMAGE&& from) noexcept
    : C_HITDAMAGE() {
    *this = ::std::move(from);
  }

  inline C_HITDAMAGE& operator=(const C_HITDAMAGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_HITDAMAGE& operator=(C_HITDAMAGE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_HITDAMAGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_HITDAMAGE* internal_default_instance() {
    return reinterpret_cast<const C_HITDAMAGE*>(
               &_C_HITDAMAGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(C_HITDAMAGE& a, C_HITDAMAGE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_HITDAMAGE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_HITDAMAGE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_HITDAMAGE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_HITDAMAGE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_HITDAMAGE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_HITDAMAGE& from) {
    C_HITDAMAGE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_HITDAMAGE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_HITDAMAGE";
  }
  protected:
  explicit C_HITDAMAGE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.HitInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::HitInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::HitInfo* release_info();
  ::Protocol::HitInfo* mutable_info();
  void set_allocated_info(::Protocol::HitInfo* info);
  private:
  const ::Protocol::HitInfo& _internal_info() const;
  ::Protocol::HitInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::HitInfo* info);
  ::Protocol::HitInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_HITDAMAGE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::HitInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_HITDAMAGE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_HITDAMAGE) */ {
 public:
  inline S_HITDAMAGE() : S_HITDAMAGE(nullptr) {}
  ~S_HITDAMAGE() override;
  explicit PROTOBUF_CONSTEXPR S_HITDAMAGE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_HITDAMAGE(const S_HITDAMAGE& from);
  S_HITDAMAGE(S_HITDAMAGE&& from) noexcept
    : S_HITDAMAGE() {
    *this = ::std::move(from);
  }

  inline S_HITDAMAGE& operator=(const S_HITDAMAGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_HITDAMAGE& operator=(S_HITDAMAGE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_HITDAMAGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_HITDAMAGE* internal_default_instance() {
    return reinterpret_cast<const S_HITDAMAGE*>(
               &_S_HITDAMAGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(S_HITDAMAGE& a, S_HITDAMAGE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_HITDAMAGE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_HITDAMAGE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_HITDAMAGE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_HITDAMAGE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_HITDAMAGE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_HITDAMAGE& from) {
    S_HITDAMAGE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_HITDAMAGE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_HITDAMAGE";
  }
  protected:
  explicit S_HITDAMAGE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.HitInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::HitInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::HitInfo* release_info();
  ::Protocol::HitInfo* mutable_info();
  void set_allocated_info(::Protocol::HitInfo* info);
  private:
  const ::Protocol::HitInfo& _internal_info() const;
  ::Protocol::HitInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::HitInfo* info);
  ::Protocol::HitInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_HITDAMAGE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::HitInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SHOP_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SHOP_ITEM_LIST) */ {
 public:
  inline S_SHOP_ITEM_LIST() : S_SHOP_ITEM_LIST(nullptr) {}
  ~S_SHOP_ITEM_LIST() override;
  explicit PROTOBUF_CONSTEXPR S_SHOP_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SHOP_ITEM_LIST(const S_SHOP_ITEM_LIST& from);
  S_SHOP_ITEM_LIST(S_SHOP_ITEM_LIST&& from) noexcept
    : S_SHOP_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline S_SHOP_ITEM_LIST& operator=(const S_SHOP_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SHOP_ITEM_LIST& operator=(S_SHOP_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SHOP_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SHOP_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const S_SHOP_ITEM_LIST*>(
               &_S_SHOP_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(S_SHOP_ITEM_LIST& a, S_SHOP_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SHOP_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SHOP_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SHOP_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SHOP_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SHOP_ITEM_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SHOP_ITEM_LIST& from) {
    S_SHOP_ITEM_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SHOP_ITEM_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SHOP_ITEM_LIST";
  }
  protected:
  explicit S_SHOP_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.ShopInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ShopInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ShopInfo* release_info();
  ::Protocol::ShopInfo* mutable_info();
  void set_allocated_info(::Protocol::ShopInfo* info);
  private:
  const ::Protocol::ShopInfo& _internal_info() const;
  ::Protocol::ShopInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ShopInfo* info);
  ::Protocol::ShopInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_SHOP_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ShopInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_REFRESH_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_REFRESH_ITEM_LIST) */ {
 public:
  inline C_REFRESH_ITEM_LIST() : C_REFRESH_ITEM_LIST(nullptr) {}
  ~C_REFRESH_ITEM_LIST() override;
  explicit PROTOBUF_CONSTEXPR C_REFRESH_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REFRESH_ITEM_LIST(const C_REFRESH_ITEM_LIST& from);
  C_REFRESH_ITEM_LIST(C_REFRESH_ITEM_LIST&& from) noexcept
    : C_REFRESH_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline C_REFRESH_ITEM_LIST& operator=(const C_REFRESH_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REFRESH_ITEM_LIST& operator=(C_REFRESH_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REFRESH_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REFRESH_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const C_REFRESH_ITEM_LIST*>(
               &_C_REFRESH_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(C_REFRESH_ITEM_LIST& a, C_REFRESH_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REFRESH_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REFRESH_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REFRESH_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REFRESH_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_REFRESH_ITEM_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_REFRESH_ITEM_LIST& from) {
    C_REFRESH_ITEM_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_REFRESH_ITEM_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_REFRESH_ITEM_LIST";
  }
  protected:
  explicit C_REFRESH_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_REFRESH_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_BUY_SHOP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_BUY_SHOP_ITEM) */ {
 public:
  inline C_BUY_SHOP_ITEM() : C_BUY_SHOP_ITEM(nullptr) {}
  ~C_BUY_SHOP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR C_BUY_SHOP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_BUY_SHOP_ITEM(const C_BUY_SHOP_ITEM& from);
  C_BUY_SHOP_ITEM(C_BUY_SHOP_ITEM&& from) noexcept
    : C_BUY_SHOP_ITEM() {
    *this = ::std::move(from);
  }

  inline C_BUY_SHOP_ITEM& operator=(const C_BUY_SHOP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_BUY_SHOP_ITEM& operator=(C_BUY_SHOP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_BUY_SHOP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_BUY_SHOP_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_BUY_SHOP_ITEM*>(
               &_C_BUY_SHOP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(C_BUY_SHOP_ITEM& a, C_BUY_SHOP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_BUY_SHOP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_BUY_SHOP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_BUY_SHOP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_BUY_SHOP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_BUY_SHOP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_BUY_SHOP_ITEM& from) {
    C_BUY_SHOP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_BUY_SHOP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_BUY_SHOP_ITEM";
  }
  protected:
  explicit C_BUY_SHOP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIndexFieldNumber = 1,
    kFullInventoryFieldNumber = 2,
    kInventoryIndexFieldNumber = 3,
  };
  // uint32 item_index = 1;
  void clear_item_index();
  uint32_t item_index() const;
  void set_item_index(uint32_t value);
  private:
  uint32_t _internal_item_index() const;
  void _internal_set_item_index(uint32_t value);
  public:

  // bool full_inventory = 2;
  void clear_full_inventory();
  bool full_inventory() const;
  void set_full_inventory(bool value);
  private:
  bool _internal_full_inventory() const;
  void _internal_set_full_inventory(bool value);
  public:

  // uint32 inventory_index = 3;
  void clear_inventory_index();
  uint32_t inventory_index() const;
  void set_inventory_index(uint32_t value);
  private:
  uint32_t _internal_inventory_index() const;
  void _internal_set_inventory_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_BUY_SHOP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t item_index_;
    bool full_inventory_;
    uint32_t inventory_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BUY_SHOP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BUY_SHOP_ITEM) */ {
 public:
  inline S_BUY_SHOP_ITEM() : S_BUY_SHOP_ITEM(nullptr) {}
  ~S_BUY_SHOP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR S_BUY_SHOP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BUY_SHOP_ITEM(const S_BUY_SHOP_ITEM& from);
  S_BUY_SHOP_ITEM(S_BUY_SHOP_ITEM&& from) noexcept
    : S_BUY_SHOP_ITEM() {
    *this = ::std::move(from);
  }

  inline S_BUY_SHOP_ITEM& operator=(const S_BUY_SHOP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BUY_SHOP_ITEM& operator=(S_BUY_SHOP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BUY_SHOP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BUY_SHOP_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_BUY_SHOP_ITEM*>(
               &_S_BUY_SHOP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(S_BUY_SHOP_ITEM& a, S_BUY_SHOP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BUY_SHOP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BUY_SHOP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BUY_SHOP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BUY_SHOP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BUY_SHOP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BUY_SHOP_ITEM& from) {
    S_BUY_SHOP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BUY_SHOP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BUY_SHOP_ITEM";
  }
  protected:
  explicit S_BUY_SHOP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kItemIndexFieldNumber = 2,
  };
  // .Protocol.ShopItemInfo info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ShopItemInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ShopItemInfo* release_info();
  ::Protocol::ShopItemInfo* mutable_info();
  void set_allocated_info(::Protocol::ShopItemInfo* info);
  private:
  const ::Protocol::ShopItemInfo& _internal_info() const;
  ::Protocol::ShopItemInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ShopItemInfo* info);
  ::Protocol::ShopItemInfo* unsafe_arena_release_info();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 item_index = 2;
  void clear_item_index();
  uint32_t item_index() const;
  void set_item_index(uint32_t value);
  private:
  uint32_t _internal_item_index() const;
  void _internal_set_item_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BUY_SHOP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ShopItemInfo* info_;
    bool success_;
    uint32_t item_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MAIL_SEND final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MAIL_SEND) */ {
 public:
  inline S_MAIL_SEND() : S_MAIL_SEND(nullptr) {}
  ~S_MAIL_SEND() override;
  explicit PROTOBUF_CONSTEXPR S_MAIL_SEND(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MAIL_SEND(const S_MAIL_SEND& from);
  S_MAIL_SEND(S_MAIL_SEND&& from) noexcept
    : S_MAIL_SEND() {
    *this = ::std::move(from);
  }

  inline S_MAIL_SEND& operator=(const S_MAIL_SEND& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MAIL_SEND& operator=(S_MAIL_SEND&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MAIL_SEND& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MAIL_SEND* internal_default_instance() {
    return reinterpret_cast<const S_MAIL_SEND*>(
               &_S_MAIL_SEND_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(S_MAIL_SEND& a, S_MAIL_SEND& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MAIL_SEND* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MAIL_SEND* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MAIL_SEND* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MAIL_SEND>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MAIL_SEND& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MAIL_SEND& from) {
    S_MAIL_SEND::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MAIL_SEND* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MAIL_SEND";
  }
  protected:
  explicit S_MAIL_SEND(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailFieldNumber = 1,
  };
  // .Protocol.MailInfo mail = 1;
  bool has_mail() const;
  private:
  bool _internal_has_mail() const;
  public:
  void clear_mail();
  const ::Protocol::MailInfo& mail() const;
  PROTOBUF_NODISCARD ::Protocol::MailInfo* release_mail();
  ::Protocol::MailInfo* mutable_mail();
  void set_allocated_mail(::Protocol::MailInfo* mail);
  private:
  const ::Protocol::MailInfo& _internal_mail() const;
  ::Protocol::MailInfo* _internal_mutable_mail();
  public:
  void unsafe_arena_set_allocated_mail(
      ::Protocol::MailInfo* mail);
  ::Protocol::MailInfo* unsafe_arena_release_mail();

  // @@protoc_insertion_point(class_scope:Protocol.S_MAIL_SEND)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::MailInfo* mail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MAIL_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MAIL_LIST) */ {
 public:
  inline S_MAIL_LIST() : S_MAIL_LIST(nullptr) {}
  ~S_MAIL_LIST() override;
  explicit PROTOBUF_CONSTEXPR S_MAIL_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MAIL_LIST(const S_MAIL_LIST& from);
  S_MAIL_LIST(S_MAIL_LIST&& from) noexcept
    : S_MAIL_LIST() {
    *this = ::std::move(from);
  }

  inline S_MAIL_LIST& operator=(const S_MAIL_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MAIL_LIST& operator=(S_MAIL_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MAIL_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MAIL_LIST* internal_default_instance() {
    return reinterpret_cast<const S_MAIL_LIST*>(
               &_S_MAIL_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(S_MAIL_LIST& a, S_MAIL_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MAIL_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MAIL_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MAIL_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MAIL_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MAIL_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MAIL_LIST& from) {
    S_MAIL_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MAIL_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MAIL_LIST";
  }
  protected:
  explicit S_MAIL_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailboxFieldNumber = 1,
  };
  // .Protocol.MailBoxInfo mailbox = 1;
  bool has_mailbox() const;
  private:
  bool _internal_has_mailbox() const;
  public:
  void clear_mailbox();
  const ::Protocol::MailBoxInfo& mailbox() const;
  PROTOBUF_NODISCARD ::Protocol::MailBoxInfo* release_mailbox();
  ::Protocol::MailBoxInfo* mutable_mailbox();
  void set_allocated_mailbox(::Protocol::MailBoxInfo* mailbox);
  private:
  const ::Protocol::MailBoxInfo& _internal_mailbox() const;
  ::Protocol::MailBoxInfo* _internal_mutable_mailbox();
  public:
  void unsafe_arena_set_allocated_mailbox(
      ::Protocol::MailBoxInfo* mailbox);
  ::Protocol::MailBoxInfo* unsafe_arena_release_mailbox();

  // @@protoc_insertion_point(class_scope:Protocol.S_MAIL_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::MailBoxInfo* mailbox_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MAIL_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MAIL_LIST) */ {
 public:
  inline C_MAIL_LIST() : C_MAIL_LIST(nullptr) {}
  ~C_MAIL_LIST() override;
  explicit PROTOBUF_CONSTEXPR C_MAIL_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MAIL_LIST(const C_MAIL_LIST& from);
  C_MAIL_LIST(C_MAIL_LIST&& from) noexcept
    : C_MAIL_LIST() {
    *this = ::std::move(from);
  }

  inline C_MAIL_LIST& operator=(const C_MAIL_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MAIL_LIST& operator=(C_MAIL_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MAIL_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MAIL_LIST* internal_default_instance() {
    return reinterpret_cast<const C_MAIL_LIST*>(
               &_C_MAIL_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(C_MAIL_LIST& a, C_MAIL_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MAIL_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MAIL_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MAIL_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MAIL_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MAIL_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MAIL_LIST& from) {
    C_MAIL_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MAIL_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MAIL_LIST";
  }
  protected:
  explicit C_MAIL_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_MAIL_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MAIL_ITEM_RECV final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MAIL_ITEM_RECV) */ {
 public:
  inline C_MAIL_ITEM_RECV() : C_MAIL_ITEM_RECV(nullptr) {}
  ~C_MAIL_ITEM_RECV() override;
  explicit PROTOBUF_CONSTEXPR C_MAIL_ITEM_RECV(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MAIL_ITEM_RECV(const C_MAIL_ITEM_RECV& from);
  C_MAIL_ITEM_RECV(C_MAIL_ITEM_RECV&& from) noexcept
    : C_MAIL_ITEM_RECV() {
    *this = ::std::move(from);
  }

  inline C_MAIL_ITEM_RECV& operator=(const C_MAIL_ITEM_RECV& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MAIL_ITEM_RECV& operator=(C_MAIL_ITEM_RECV&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MAIL_ITEM_RECV& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MAIL_ITEM_RECV* internal_default_instance() {
    return reinterpret_cast<const C_MAIL_ITEM_RECV*>(
               &_C_MAIL_ITEM_RECV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(C_MAIL_ITEM_RECV& a, C_MAIL_ITEM_RECV& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MAIL_ITEM_RECV* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MAIL_ITEM_RECV* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MAIL_ITEM_RECV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MAIL_ITEM_RECV>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MAIL_ITEM_RECV& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MAIL_ITEM_RECV& from) {
    C_MAIL_ITEM_RECV::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MAIL_ITEM_RECV* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MAIL_ITEM_RECV";
  }
  protected:
  explicit C_MAIL_ITEM_RECV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailIndexFieldNumber = 1,
  };
  // uint32 mailIndex = 1;
  void clear_mailindex();
  uint32_t mailindex() const;
  void set_mailindex(uint32_t value);
  private:
  uint32_t _internal_mailindex() const;
  void _internal_set_mailindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_MAIL_ITEM_RECV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t mailindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GOLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GOLD) */ {
 public:
  inline S_GOLD() : S_GOLD(nullptr) {}
  ~S_GOLD() override;
  explicit PROTOBUF_CONSTEXPR S_GOLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GOLD(const S_GOLD& from);
  S_GOLD(S_GOLD&& from) noexcept
    : S_GOLD() {
    *this = ::std::move(from);
  }

  inline S_GOLD& operator=(const S_GOLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GOLD& operator=(S_GOLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GOLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GOLD* internal_default_instance() {
    return reinterpret_cast<const S_GOLD*>(
               &_S_GOLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(S_GOLD& a, S_GOLD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GOLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GOLD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GOLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GOLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_GOLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_GOLD& from) {
    S_GOLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GOLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GOLD";
  }
  protected:
  explicit S_GOLD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_GOLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_GOLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_GOLD) */ {
 public:
  inline C_GOLD() : C_GOLD(nullptr) {}
  ~C_GOLD() override;
  explicit PROTOBUF_CONSTEXPR C_GOLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_GOLD(const C_GOLD& from);
  C_GOLD(C_GOLD&& from) noexcept
    : C_GOLD() {
    *this = ::std::move(from);
  }

  inline C_GOLD& operator=(const C_GOLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_GOLD& operator=(C_GOLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_GOLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_GOLD* internal_default_instance() {
    return reinterpret_cast<const C_GOLD*>(
               &_C_GOLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(C_GOLD& a, C_GOLD& b) {
    a.Swap(&b);
  }
  inline void Swap(C_GOLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_GOLD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_GOLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_GOLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_GOLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_GOLD& from) {
    C_GOLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_GOLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_GOLD";
  }
  protected:
  explicit C_GOLD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_GOLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_CREATEACCOUNT

// string playerId = 1;
inline void C_CREATEACCOUNT::clear_playerid() {
  _impl_.playerid_.ClearToEmpty();
}
inline const std::string& C_CREATEACCOUNT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATEACCOUNT.playerId)
  return _internal_playerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CREATEACCOUNT::set_playerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CREATEACCOUNT.playerId)
}
inline std::string* C_CREATEACCOUNT::mutable_playerid() {
  std::string* _s = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CREATEACCOUNT.playerId)
  return _s;
}
inline const std::string& C_CREATEACCOUNT::_internal_playerid() const {
  return _impl_.playerid_.Get();
}
inline void C_CREATEACCOUNT::_internal_set_playerid(const std::string& value) {
  
  _impl_.playerid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CREATEACCOUNT::_internal_mutable_playerid() {
  
  return _impl_.playerid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CREATEACCOUNT::release_playerid() {
  // @@protoc_insertion_point(field_release:Protocol.C_CREATEACCOUNT.playerId)
  return _impl_.playerid_.Release();
}
inline void C_CREATEACCOUNT::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    
  } else {
    
  }
  _impl_.playerid_.SetAllocated(playerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playerid_.IsDefault()) {
    _impl_.playerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CREATEACCOUNT.playerId)
}

// string passward = 2;
inline void C_CREATEACCOUNT::clear_passward() {
  _impl_.passward_.ClearToEmpty();
}
inline const std::string& C_CREATEACCOUNT::passward() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATEACCOUNT.passward)
  return _internal_passward();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CREATEACCOUNT::set_passward(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passward_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CREATEACCOUNT.passward)
}
inline std::string* C_CREATEACCOUNT::mutable_passward() {
  std::string* _s = _internal_mutable_passward();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CREATEACCOUNT.passward)
  return _s;
}
inline const std::string& C_CREATEACCOUNT::_internal_passward() const {
  return _impl_.passward_.Get();
}
inline void C_CREATEACCOUNT::_internal_set_passward(const std::string& value) {
  
  _impl_.passward_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CREATEACCOUNT::_internal_mutable_passward() {
  
  return _impl_.passward_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CREATEACCOUNT::release_passward() {
  // @@protoc_insertion_point(field_release:Protocol.C_CREATEACCOUNT.passward)
  return _impl_.passward_.Release();
}
inline void C_CREATEACCOUNT::set_allocated_passward(std::string* passward) {
  if (passward != nullptr) {
    
  } else {
    
  }
  _impl_.passward_.SetAllocated(passward, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passward_.IsDefault()) {
    _impl_.passward_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CREATEACCOUNT.passward)
}

// -------------------------------------------------------------------

// S_CREATEACCOUNT

// bool success = 1;
inline void S_CREATEACCOUNT::clear_success() {
  _impl_.success_ = false;
}
inline bool S_CREATEACCOUNT::_internal_success() const {
  return _impl_.success_;
}
inline bool S_CREATEACCOUNT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATEACCOUNT.success)
  return _internal_success();
}
inline void S_CREATEACCOUNT::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_CREATEACCOUNT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CREATEACCOUNT.success)
}

// -------------------------------------------------------------------

// C_LOGIN

// string playerId = 1;
inline void C_LOGIN::clear_playerid() {
  _impl_.playerid_.ClearToEmpty();
}
inline const std::string& C_LOGIN::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.playerId)
  return _internal_playerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_playerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.playerId)
}
inline std::string* C_LOGIN::mutable_playerid() {
  std::string* _s = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.playerId)
  return _s;
}
inline const std::string& C_LOGIN::_internal_playerid() const {
  return _impl_.playerid_.Get();
}
inline void C_LOGIN::_internal_set_playerid(const std::string& value) {
  
  _impl_.playerid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_playerid() {
  
  return _impl_.playerid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_playerid() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.playerId)
  return _impl_.playerid_.Release();
}
inline void C_LOGIN::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    
  } else {
    
  }
  _impl_.playerid_.SetAllocated(playerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playerid_.IsDefault()) {
    _impl_.playerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.playerId)
}

// string passward = 2;
inline void C_LOGIN::clear_passward() {
  _impl_.passward_.ClearToEmpty();
}
inline const std::string& C_LOGIN::passward() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.passward)
  return _internal_passward();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_passward(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passward_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.passward)
}
inline std::string* C_LOGIN::mutable_passward() {
  std::string* _s = _internal_mutable_passward();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.passward)
  return _s;
}
inline const std::string& C_LOGIN::_internal_passward() const {
  return _impl_.passward_.Get();
}
inline void C_LOGIN::_internal_set_passward(const std::string& value) {
  
  _impl_.passward_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_passward() {
  
  return _impl_.passward_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_passward() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.passward)
  return _impl_.passward_.Release();
}
inline void C_LOGIN::set_allocated_passward(std::string* passward) {
  if (passward != nullptr) {
    
  } else {
    
  }
  _impl_.passward_.SetAllocated(passward, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passward_.IsDefault()) {
    _impl_.passward_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.passward)
}

// -------------------------------------------------------------------

// S_LOGIN

// bool success = 1;
inline void S_LOGIN::clear_success() {
  _impl_.success_ = false;
}
inline bool S_LOGIN::_internal_success() const {
  return _impl_.success_;
}
inline bool S_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.success)
  return _internal_success();
}
inline void S_LOGIN::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.success)
}

// repeated .Protocol.PlayerInfo players = 2;
inline int S_LOGIN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_LOGIN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::PlayerInfo* S_LOGIN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOGIN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
S_LOGIN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOGIN.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& S_LOGIN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& S_LOGIN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* S_LOGIN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* S_LOGIN::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_LOGIN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
S_LOGIN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOGIN.players)
  return _impl_.players_;
}

// uint64 playerIndex = 3;
inline void S_LOGIN::clear_playerindex() {
  _impl_.playerindex_ = uint64_t{0u};
}
inline uint64_t S_LOGIN::_internal_playerindex() const {
  return _impl_.playerindex_;
}
inline uint64_t S_LOGIN::playerindex() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.playerIndex)
  return _internal_playerindex();
}
inline void S_LOGIN::_internal_set_playerindex(uint64_t value) {
  
  _impl_.playerindex_ = value;
}
inline void S_LOGIN::set_playerindex(uint64_t value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.playerIndex)
}

// -------------------------------------------------------------------

// C_LOGOUT

// string playerId = 1;
inline void C_LOGOUT::clear_playerid() {
  _impl_.playerid_.ClearToEmpty();
}
inline const std::string& C_LOGOUT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGOUT.playerId)
  return _internal_playerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGOUT::set_playerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGOUT.playerId)
}
inline std::string* C_LOGOUT::mutable_playerid() {
  std::string* _s = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGOUT.playerId)
  return _s;
}
inline const std::string& C_LOGOUT::_internal_playerid() const {
  return _impl_.playerid_.Get();
}
inline void C_LOGOUT::_internal_set_playerid(const std::string& value) {
  
  _impl_.playerid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGOUT::_internal_mutable_playerid() {
  
  return _impl_.playerid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGOUT::release_playerid() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGOUT.playerId)
  return _impl_.playerid_.Release();
}
inline void C_LOGOUT::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    
  } else {
    
  }
  _impl_.playerid_.SetAllocated(playerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playerid_.IsDefault()) {
    _impl_.playerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGOUT.playerId)
}

// -------------------------------------------------------------------

// S_LOGOUT

// uint64 playerIndex = 1;
inline void S_LOGOUT::clear_playerindex() {
  _impl_.playerindex_ = uint64_t{0u};
}
inline uint64_t S_LOGOUT::_internal_playerindex() const {
  return _impl_.playerindex_;
}
inline uint64_t S_LOGOUT::playerindex() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGOUT.playerIndex)
  return _internal_playerindex();
}
inline void S_LOGOUT::_internal_set_playerindex(uint64_t value) {
  
  _impl_.playerindex_ = value;
}
inline void S_LOGOUT::set_playerindex(uint64_t value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGOUT.playerIndex)
}

// -------------------------------------------------------------------

// C_ENTER_GAME

// uint64 playerIndex = 1;
inline void C_ENTER_GAME::clear_playerindex() {
  _impl_.playerindex_ = uint64_t{0u};
}
inline uint64_t C_ENTER_GAME::_internal_playerindex() const {
  return _impl_.playerindex_;
}
inline uint64_t C_ENTER_GAME::playerindex() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.playerIndex)
  return _internal_playerindex();
}
inline void C_ENTER_GAME::_internal_set_playerindex(uint64_t value) {
  
  _impl_.playerindex_ = value;
}
inline void C_ENTER_GAME::set_playerindex(uint64_t value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.playerIndex)
}

// -------------------------------------------------------------------

// S_ENTER_GAME

// bool success = 1;
inline void S_ENTER_GAME::clear_success() {
  _impl_.success_ = false;
}
inline bool S_ENTER_GAME::_internal_success() const {
  return _impl_.success_;
}
inline bool S_ENTER_GAME::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.success)
  return _internal_success();
}
inline void S_ENTER_GAME::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_ENTER_GAME::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.success)
}

// .Protocol.PlayerInfo player = 2;
inline bool S_ENTER_GAME::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_ENTER_GAME::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::PlayerInfo& S_ENTER_GAME::_internal_player() const {
  const ::Protocol::PlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& S_ENTER_GAME::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.player)
  return _internal_player();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_player(
    ::Protocol::PlayerInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.player)
}
inline ::Protocol::PlayerInfo* S_ENTER_GAME::release_player() {
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* S_ENTER_GAME::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.player)
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* S_ENTER_GAME::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::PlayerInfo* S_ENTER_GAME::mutable_player() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.player)
  return _msg;
}
inline void S_ENTER_GAME::set_allocated_player(::Protocol::PlayerInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.player)
}

// -------------------------------------------------------------------

// C_ENTER_ROOM

// string room_name = 1;
inline void C_ENTER_ROOM::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& C_ENTER_ROOM::room_name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_ROOM.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_ENTER_ROOM::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_ROOM.room_name)
}
inline std::string* C_ENTER_ROOM::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER_ROOM.room_name)
  return _s;
}
inline const std::string& C_ENTER_ROOM::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void C_ENTER_ROOM::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_ENTER_ROOM::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_ENTER_ROOM::release_room_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER_ROOM.room_name)
  return _impl_.room_name_.Release();
}
inline void C_ENTER_ROOM::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER_ROOM.room_name)
}

// .Protocol.PlayerInfo player = 2;
inline bool C_ENTER_ROOM::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool C_ENTER_ROOM::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::PlayerInfo& C_ENTER_ROOM::_internal_player() const {
  const ::Protocol::PlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& C_ENTER_ROOM::player() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_ROOM.player)
  return _internal_player();
}
inline void C_ENTER_ROOM::unsafe_arena_set_allocated_player(
    ::Protocol::PlayerInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_ENTER_ROOM.player)
}
inline ::Protocol::PlayerInfo* C_ENTER_ROOM::release_player() {
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* C_ENTER_ROOM::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER_ROOM.player)
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* C_ENTER_ROOM::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::PlayerInfo* C_ENTER_ROOM::mutable_player() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER_ROOM.player)
  return _msg;
}
inline void C_ENTER_ROOM::set_allocated_player(::Protocol::PlayerInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER_ROOM.player)
}

// -------------------------------------------------------------------

// S_ENTER_ROOM

// bool success = 1;
inline void S_ENTER_ROOM::clear_success() {
  _impl_.success_ = false;
}
inline bool S_ENTER_ROOM::_internal_success() const {
  return _impl_.success_;
}
inline bool S_ENTER_ROOM::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_ROOM.success)
  return _internal_success();
}
inline void S_ENTER_ROOM::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_ENTER_ROOM::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_ROOM.success)
}

// .Protocol.PlayerInfo player = 2;
inline bool S_ENTER_ROOM::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_ENTER_ROOM::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::PlayerInfo& S_ENTER_ROOM::_internal_player() const {
  const ::Protocol::PlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& S_ENTER_ROOM::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_ROOM.player)
  return _internal_player();
}
inline void S_ENTER_ROOM::unsafe_arena_set_allocated_player(
    ::Protocol::PlayerInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_ROOM.player)
}
inline ::Protocol::PlayerInfo* S_ENTER_ROOM::release_player() {
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* S_ENTER_ROOM::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_ROOM.player)
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* S_ENTER_ROOM::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::PlayerInfo* S_ENTER_ROOM::mutable_player() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_ROOM.player)
  return _msg;
}
inline void S_ENTER_ROOM::set_allocated_player(::Protocol::PlayerInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_ROOM.player)
}

// -------------------------------------------------------------------

// C_LEAVE_GAME

// -------------------------------------------------------------------

// S_LEAVE_GAME

// -------------------------------------------------------------------

// S_SPAWN

// repeated .Protocol.ObjectInfo players = 1;
inline int S_SPAWN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_SPAWN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.players)
  return &_impl_.players_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.players)
  return _internal_players(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_players() {
  ::Protocol::ObjectInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.players)
  return _impl_.players_;
}

// repeated .Protocol.ObjectInfo monsters = 2;
inline int S_SPAWN::_internal_monsters_size() const {
  return _impl_.monsters_.size();
}
inline int S_SPAWN::monsters_size() const {
  return _internal_monsters_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_monsters(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.monsters)
  return _impl_.monsters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_monsters() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.monsters)
  return &_impl_.monsters_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_monsters(int index) const {
  return _impl_.monsters_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::monsters(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.monsters)
  return _internal_monsters(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_monsters() {
  return _impl_.monsters_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_monsters() {
  ::Protocol::ObjectInfo* _add = _internal_add_monsters();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.monsters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::monsters() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.monsters)
  return _impl_.monsters_;
}

// -------------------------------------------------------------------

// S_SPAWNPLAYER

// repeated .Protocol.PlayerInfo players = 1;
inline int S_SPAWNPLAYER::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_SPAWNPLAYER::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::PlayerInfo* S_SPAWNPLAYER::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWNPLAYER.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
S_SPAWNPLAYER::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWNPLAYER.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& S_SPAWNPLAYER::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& S_SPAWNPLAYER::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWNPLAYER.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* S_SPAWNPLAYER::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* S_SPAWNPLAYER::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWNPLAYER.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
S_SPAWNPLAYER::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWNPLAYER.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// S_SPAWNMONSTER

// repeated .Protocol.MonsterInfo monsters = 1;
inline int S_SPAWNMONSTER::_internal_monsters_size() const {
  return _impl_.monsters_.size();
}
inline int S_SPAWNMONSTER::monsters_size() const {
  return _internal_monsters_size();
}
inline ::Protocol::MonsterInfo* S_SPAWNMONSTER::mutable_monsters(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWNMONSTER.monsters)
  return _impl_.monsters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MonsterInfo >*
S_SPAWNMONSTER::mutable_monsters() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWNMONSTER.monsters)
  return &_impl_.monsters_;
}
inline const ::Protocol::MonsterInfo& S_SPAWNMONSTER::_internal_monsters(int index) const {
  return _impl_.monsters_.Get(index);
}
inline const ::Protocol::MonsterInfo& S_SPAWNMONSTER::monsters(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWNMONSTER.monsters)
  return _internal_monsters(index);
}
inline ::Protocol::MonsterInfo* S_SPAWNMONSTER::_internal_add_monsters() {
  return _impl_.monsters_.Add();
}
inline ::Protocol::MonsterInfo* S_SPAWNMONSTER::add_monsters() {
  ::Protocol::MonsterInfo* _add = _internal_add_monsters();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWNMONSTER.monsters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MonsterInfo >&
S_SPAWNMONSTER::monsters() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWNMONSTER.monsters)
  return _impl_.monsters_;
}

// -------------------------------------------------------------------

// C_DROPITEM

// repeated .Protocol.ItemInfo items = 1;
inline int C_DROPITEM::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int C_DROPITEM::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* C_DROPITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_DROPITEM.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
C_DROPITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_DROPITEM.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& C_DROPITEM::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& C_DROPITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_DROPITEM.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* C_DROPITEM::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* C_DROPITEM::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.C_DROPITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
C_DROPITEM::items() const {
  // @@protoc_insertion_point(field_list:Protocol.C_DROPITEM.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// C_INVENTORY_UPDATE

// repeated uint32 index = 1;
inline int C_INVENTORY_UPDATE::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int C_INVENTORY_UPDATE::index_size() const {
  return _internal_index_size();
}
inline void C_INVENTORY_UPDATE::clear_index() {
  _impl_.index_.Clear();
}
inline uint32_t C_INVENTORY_UPDATE::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline uint32_t C_INVENTORY_UPDATE::index(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_INVENTORY_UPDATE.index)
  return _internal_index(index);
}
inline void C_INVENTORY_UPDATE::set_index(int index, uint32_t value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_INVENTORY_UPDATE.index)
}
inline void C_INVENTORY_UPDATE::_internal_add_index(uint32_t value) {
  _impl_.index_.Add(value);
}
inline void C_INVENTORY_UPDATE::add_index(uint32_t value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:Protocol.C_INVENTORY_UPDATE.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
C_INVENTORY_UPDATE::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
C_INVENTORY_UPDATE::index() const {
  // @@protoc_insertion_point(field_list:Protocol.C_INVENTORY_UPDATE.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
C_INVENTORY_UPDATE::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
C_INVENTORY_UPDATE::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_INVENTORY_UPDATE.index)
  return _internal_mutable_index();
}

// repeated .Protocol.ItemInfo items = 2;
inline int C_INVENTORY_UPDATE::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int C_INVENTORY_UPDATE::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* C_INVENTORY_UPDATE::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_INVENTORY_UPDATE.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
C_INVENTORY_UPDATE::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_INVENTORY_UPDATE.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& C_INVENTORY_UPDATE::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& C_INVENTORY_UPDATE::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_INVENTORY_UPDATE.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* C_INVENTORY_UPDATE::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* C_INVENTORY_UPDATE::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.C_INVENTORY_UPDATE.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
C_INVENTORY_UPDATE::items() const {
  // @@protoc_insertion_point(field_list:Protocol.C_INVENTORY_UPDATE.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// S_INVENTORY_UPDATE

// uint64 object_id = 1;
inline void S_INVENTORY_UPDATE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_INVENTORY_UPDATE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_INVENTORY_UPDATE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_INVENTORY_UPDATE.object_id)
  return _internal_object_id();
}
inline void S_INVENTORY_UPDATE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_INVENTORY_UPDATE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_INVENTORY_UPDATE.object_id)
}

// repeated uint32 index = 2;
inline int S_INVENTORY_UPDATE::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int S_INVENTORY_UPDATE::index_size() const {
  return _internal_index_size();
}
inline void S_INVENTORY_UPDATE::clear_index() {
  _impl_.index_.Clear();
}
inline uint32_t S_INVENTORY_UPDATE::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline uint32_t S_INVENTORY_UPDATE::index(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_INVENTORY_UPDATE.index)
  return _internal_index(index);
}
inline void S_INVENTORY_UPDATE::set_index(int index, uint32_t value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_INVENTORY_UPDATE.index)
}
inline void S_INVENTORY_UPDATE::_internal_add_index(uint32_t value) {
  _impl_.index_.Add(value);
}
inline void S_INVENTORY_UPDATE::add_index(uint32_t value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:Protocol.S_INVENTORY_UPDATE.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_INVENTORY_UPDATE::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_INVENTORY_UPDATE::index() const {
  // @@protoc_insertion_point(field_list:Protocol.S_INVENTORY_UPDATE.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_INVENTORY_UPDATE::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_INVENTORY_UPDATE::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_INVENTORY_UPDATE.index)
  return _internal_mutable_index();
}

// repeated .Protocol.ItemInfo items = 3;
inline int S_INVENTORY_UPDATE::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_INVENTORY_UPDATE::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* S_INVENTORY_UPDATE::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_INVENTORY_UPDATE.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_INVENTORY_UPDATE::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_INVENTORY_UPDATE.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_INVENTORY_UPDATE::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_INVENTORY_UPDATE::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_INVENTORY_UPDATE.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_INVENTORY_UPDATE::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_INVENTORY_UPDATE::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_INVENTORY_UPDATE.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_INVENTORY_UPDATE::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_INVENTORY_UPDATE.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// C_INVENTORY_REMOVE

// repeated uint32 index = 1;
inline int C_INVENTORY_REMOVE::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int C_INVENTORY_REMOVE::index_size() const {
  return _internal_index_size();
}
inline void C_INVENTORY_REMOVE::clear_index() {
  _impl_.index_.Clear();
}
inline uint32_t C_INVENTORY_REMOVE::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline uint32_t C_INVENTORY_REMOVE::index(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_INVENTORY_REMOVE.index)
  return _internal_index(index);
}
inline void C_INVENTORY_REMOVE::set_index(int index, uint32_t value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_INVENTORY_REMOVE.index)
}
inline void C_INVENTORY_REMOVE::_internal_add_index(uint32_t value) {
  _impl_.index_.Add(value);
}
inline void C_INVENTORY_REMOVE::add_index(uint32_t value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:Protocol.C_INVENTORY_REMOVE.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
C_INVENTORY_REMOVE::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
C_INVENTORY_REMOVE::index() const {
  // @@protoc_insertion_point(field_list:Protocol.C_INVENTORY_REMOVE.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
C_INVENTORY_REMOVE::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
C_INVENTORY_REMOVE::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_INVENTORY_REMOVE.index)
  return _internal_mutable_index();
}

// repeated uint32 count_items = 2;
inline int C_INVENTORY_REMOVE::_internal_count_items_size() const {
  return _impl_.count_items_.size();
}
inline int C_INVENTORY_REMOVE::count_items_size() const {
  return _internal_count_items_size();
}
inline void C_INVENTORY_REMOVE::clear_count_items() {
  _impl_.count_items_.Clear();
}
inline uint32_t C_INVENTORY_REMOVE::_internal_count_items(int index) const {
  return _impl_.count_items_.Get(index);
}
inline uint32_t C_INVENTORY_REMOVE::count_items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_INVENTORY_REMOVE.count_items)
  return _internal_count_items(index);
}
inline void C_INVENTORY_REMOVE::set_count_items(int index, uint32_t value) {
  _impl_.count_items_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_INVENTORY_REMOVE.count_items)
}
inline void C_INVENTORY_REMOVE::_internal_add_count_items(uint32_t value) {
  _impl_.count_items_.Add(value);
}
inline void C_INVENTORY_REMOVE::add_count_items(uint32_t value) {
  _internal_add_count_items(value);
  // @@protoc_insertion_point(field_add:Protocol.C_INVENTORY_REMOVE.count_items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
C_INVENTORY_REMOVE::_internal_count_items() const {
  return _impl_.count_items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
C_INVENTORY_REMOVE::count_items() const {
  // @@protoc_insertion_point(field_list:Protocol.C_INVENTORY_REMOVE.count_items)
  return _internal_count_items();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
C_INVENTORY_REMOVE::_internal_mutable_count_items() {
  return &_impl_.count_items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
C_INVENTORY_REMOVE::mutable_count_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_INVENTORY_REMOVE.count_items)
  return _internal_mutable_count_items();
}

// -------------------------------------------------------------------

// S_INVENTORY_REMOVE

// uint64 object_id = 1;
inline void S_INVENTORY_REMOVE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_INVENTORY_REMOVE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_INVENTORY_REMOVE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_INVENTORY_REMOVE.object_id)
  return _internal_object_id();
}
inline void S_INVENTORY_REMOVE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_INVENTORY_REMOVE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_INVENTORY_REMOVE.object_id)
}

// repeated uint32 index = 2;
inline int S_INVENTORY_REMOVE::_internal_index_size() const {
  return _impl_.index_.size();
}
inline int S_INVENTORY_REMOVE::index_size() const {
  return _internal_index_size();
}
inline void S_INVENTORY_REMOVE::clear_index() {
  _impl_.index_.Clear();
}
inline uint32_t S_INVENTORY_REMOVE::_internal_index(int index) const {
  return _impl_.index_.Get(index);
}
inline uint32_t S_INVENTORY_REMOVE::index(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_INVENTORY_REMOVE.index)
  return _internal_index(index);
}
inline void S_INVENTORY_REMOVE::set_index(int index, uint32_t value) {
  _impl_.index_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_INVENTORY_REMOVE.index)
}
inline void S_INVENTORY_REMOVE::_internal_add_index(uint32_t value) {
  _impl_.index_.Add(value);
}
inline void S_INVENTORY_REMOVE::add_index(uint32_t value) {
  _internal_add_index(value);
  // @@protoc_insertion_point(field_add:Protocol.S_INVENTORY_REMOVE.index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_INVENTORY_REMOVE::_internal_index() const {
  return _impl_.index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_INVENTORY_REMOVE::index() const {
  // @@protoc_insertion_point(field_list:Protocol.S_INVENTORY_REMOVE.index)
  return _internal_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_INVENTORY_REMOVE::_internal_mutable_index() {
  return &_impl_.index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_INVENTORY_REMOVE::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_INVENTORY_REMOVE.index)
  return _internal_mutable_index();
}

// repeated uint32 count_items = 3;
inline int S_INVENTORY_REMOVE::_internal_count_items_size() const {
  return _impl_.count_items_.size();
}
inline int S_INVENTORY_REMOVE::count_items_size() const {
  return _internal_count_items_size();
}
inline void S_INVENTORY_REMOVE::clear_count_items() {
  _impl_.count_items_.Clear();
}
inline uint32_t S_INVENTORY_REMOVE::_internal_count_items(int index) const {
  return _impl_.count_items_.Get(index);
}
inline uint32_t S_INVENTORY_REMOVE::count_items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_INVENTORY_REMOVE.count_items)
  return _internal_count_items(index);
}
inline void S_INVENTORY_REMOVE::set_count_items(int index, uint32_t value) {
  _impl_.count_items_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_INVENTORY_REMOVE.count_items)
}
inline void S_INVENTORY_REMOVE::_internal_add_count_items(uint32_t value) {
  _impl_.count_items_.Add(value);
}
inline void S_INVENTORY_REMOVE::add_count_items(uint32_t value) {
  _internal_add_count_items(value);
  // @@protoc_insertion_point(field_add:Protocol.S_INVENTORY_REMOVE.count_items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_INVENTORY_REMOVE::_internal_count_items() const {
  return _impl_.count_items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_INVENTORY_REMOVE::count_items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_INVENTORY_REMOVE.count_items)
  return _internal_count_items();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_INVENTORY_REMOVE::_internal_mutable_count_items() {
  return &_impl_.count_items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_INVENTORY_REMOVE::mutable_count_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_INVENTORY_REMOVE.count_items)
  return _internal_mutable_count_items();
}

// -------------------------------------------------------------------

// C_SWAP_INVENTORY_TO_INVENTORY

// uint64 from_object_id = 1;
inline void C_SWAP_INVENTORY_TO_INVENTORY::clear_from_object_id() {
  _impl_.from_object_id_ = uint64_t{0u};
}
inline uint64_t C_SWAP_INVENTORY_TO_INVENTORY::_internal_from_object_id() const {
  return _impl_.from_object_id_;
}
inline uint64_t C_SWAP_INVENTORY_TO_INVENTORY::from_object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.from_object_id)
  return _internal_from_object_id();
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::_internal_set_from_object_id(uint64_t value) {
  
  _impl_.from_object_id_ = value;
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::set_from_object_id(uint64_t value) {
  _internal_set_from_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.from_object_id)
}

// uint32 from_index = 2;
inline void C_SWAP_INVENTORY_TO_INVENTORY::clear_from_index() {
  _impl_.from_index_ = 0u;
}
inline uint32_t C_SWAP_INVENTORY_TO_INVENTORY::_internal_from_index() const {
  return _impl_.from_index_;
}
inline uint32_t C_SWAP_INVENTORY_TO_INVENTORY::from_index() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.from_index)
  return _internal_from_index();
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::_internal_set_from_index(uint32_t value) {
  
  _impl_.from_index_ = value;
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::set_from_index(uint32_t value) {
  _internal_set_from_index(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.from_index)
}

// uint32 from_count = 3;
inline void C_SWAP_INVENTORY_TO_INVENTORY::clear_from_count() {
  _impl_.from_count_ = 0u;
}
inline uint32_t C_SWAP_INVENTORY_TO_INVENTORY::_internal_from_count() const {
  return _impl_.from_count_;
}
inline uint32_t C_SWAP_INVENTORY_TO_INVENTORY::from_count() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.from_count)
  return _internal_from_count();
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::_internal_set_from_count(uint32_t value) {
  
  _impl_.from_count_ = value;
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::set_from_count(uint32_t value) {
  _internal_set_from_count(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.from_count)
}

// uint64 to_object_id = 4;
inline void C_SWAP_INVENTORY_TO_INVENTORY::clear_to_object_id() {
  _impl_.to_object_id_ = uint64_t{0u};
}
inline uint64_t C_SWAP_INVENTORY_TO_INVENTORY::_internal_to_object_id() const {
  return _impl_.to_object_id_;
}
inline uint64_t C_SWAP_INVENTORY_TO_INVENTORY::to_object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.to_object_id)
  return _internal_to_object_id();
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::_internal_set_to_object_id(uint64_t value) {
  
  _impl_.to_object_id_ = value;
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::set_to_object_id(uint64_t value) {
  _internal_set_to_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.to_object_id)
}

// uint32 to_index = 5;
inline void C_SWAP_INVENTORY_TO_INVENTORY::clear_to_index() {
  _impl_.to_index_ = 0u;
}
inline uint32_t C_SWAP_INVENTORY_TO_INVENTORY::_internal_to_index() const {
  return _impl_.to_index_;
}
inline uint32_t C_SWAP_INVENTORY_TO_INVENTORY::to_index() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.to_index)
  return _internal_to_index();
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::_internal_set_to_index(uint32_t value) {
  
  _impl_.to_index_ = value;
}
inline void C_SWAP_INVENTORY_TO_INVENTORY::set_to_index(uint32_t value) {
  _internal_set_to_index(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_INVENTORY_TO_INVENTORY.to_index)
}

// -------------------------------------------------------------------

// C_TRY_PICK_ITEM_TO_INVENTORY

// uint64 item_id = 1;
inline void C_TRY_PICK_ITEM_TO_INVENTORY::clear_item_id() {
  _impl_.item_id_ = uint64_t{0u};
}
inline uint64_t C_TRY_PICK_ITEM_TO_INVENTORY::_internal_item_id() const {
  return _impl_.item_id_;
}
inline uint64_t C_TRY_PICK_ITEM_TO_INVENTORY::item_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY.item_id)
  return _internal_item_id();
}
inline void C_TRY_PICK_ITEM_TO_INVENTORY::_internal_set_item_id(uint64_t value) {
  
  _impl_.item_id_ = value;
}
inline void C_TRY_PICK_ITEM_TO_INVENTORY::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY.item_id)
}

// uint64 to_object_id = 2;
inline void C_TRY_PICK_ITEM_TO_INVENTORY::clear_to_object_id() {
  _impl_.to_object_id_ = uint64_t{0u};
}
inline uint64_t C_TRY_PICK_ITEM_TO_INVENTORY::_internal_to_object_id() const {
  return _impl_.to_object_id_;
}
inline uint64_t C_TRY_PICK_ITEM_TO_INVENTORY::to_object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY.to_object_id)
  return _internal_to_object_id();
}
inline void C_TRY_PICK_ITEM_TO_INVENTORY::_internal_set_to_object_id(uint64_t value) {
  
  _impl_.to_object_id_ = value;
}
inline void C_TRY_PICK_ITEM_TO_INVENTORY::set_to_object_id(uint64_t value) {
  _internal_set_to_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY.to_object_id)
}

// uint32 to_index = 3;
inline void C_TRY_PICK_ITEM_TO_INVENTORY::clear_to_index() {
  _impl_.to_index_ = 0u;
}
inline uint32_t C_TRY_PICK_ITEM_TO_INVENTORY::_internal_to_index() const {
  return _impl_.to_index_;
}
inline uint32_t C_TRY_PICK_ITEM_TO_INVENTORY::to_index() const {
  // @@protoc_insertion_point(field_get:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY.to_index)
  return _internal_to_index();
}
inline void C_TRY_PICK_ITEM_TO_INVENTORY::_internal_set_to_index(uint32_t value) {
  
  _impl_.to_index_ = value;
}
inline void C_TRY_PICK_ITEM_TO_INVENTORY::set_to_index(uint32_t value) {
  _internal_set_to_index(value);
  // @@protoc_insertion_point(field_set:Protocol.C_TRY_PICK_ITEM_TO_INVENTORY.to_index)
}

// -------------------------------------------------------------------

// S_SPAWNITEM

// repeated .Protocol.ObjectItemInfo items = 1;
inline int S_SPAWNITEM::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_SPAWNITEM::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ObjectItemInfo* S_SPAWNITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWNITEM.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectItemInfo >*
S_SPAWNITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWNITEM.items)
  return &_impl_.items_;
}
inline const ::Protocol::ObjectItemInfo& S_SPAWNITEM::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ObjectItemInfo& S_SPAWNITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWNITEM.items)
  return _internal_items(index);
}
inline ::Protocol::ObjectItemInfo* S_SPAWNITEM::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ObjectItemInfo* S_SPAWNITEM::add_items() {
  ::Protocol::ObjectItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWNITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectItemInfo >&
S_SPAWNITEM::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWNITEM.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// S_SPAWNBOX

// repeated .Protocol.ItemBoxInfo box = 1;
inline int S_SPAWNBOX::_internal_box_size() const {
  return _impl_.box_.size();
}
inline int S_SPAWNBOX::box_size() const {
  return _internal_box_size();
}
inline ::Protocol::ItemBoxInfo* S_SPAWNBOX::mutable_box(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWNBOX.box)
  return _impl_.box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemBoxInfo >*
S_SPAWNBOX::mutable_box() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWNBOX.box)
  return &_impl_.box_;
}
inline const ::Protocol::ItemBoxInfo& S_SPAWNBOX::_internal_box(int index) const {
  return _impl_.box_.Get(index);
}
inline const ::Protocol::ItemBoxInfo& S_SPAWNBOX::box(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWNBOX.box)
  return _internal_box(index);
}
inline ::Protocol::ItemBoxInfo* S_SPAWNBOX::_internal_add_box() {
  return _impl_.box_.Add();
}
inline ::Protocol::ItemBoxInfo* S_SPAWNBOX::add_box() {
  ::Protocol::ItemBoxInfo* _add = _internal_add_box();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWNBOX.box)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemBoxInfo >&
S_SPAWNBOX::box() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWNBOX.box)
  return _impl_.box_;
}

// -------------------------------------------------------------------

// S_DESPAWN

// repeated uint64 object_ids = 1;
inline int S_DESPAWN::_internal_object_ids_size() const {
  return _impl_.object_ids_.size();
}
inline int S_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void S_DESPAWN::clear_object_ids() {
  _impl_.object_ids_.Clear();
}
inline uint64_t S_DESPAWN::_internal_object_ids(int index) const {
  return _impl_.object_ids_.Get(index);
}
inline uint64_t S_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void S_DESPAWN::set_object_ids(int index, uint64_t value) {
  _impl_.object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_DESPAWN.object_ids)
}
inline void S_DESPAWN::_internal_add_object_ids(uint64_t value) {
  _impl_.object_ids_.Add(value);
}
inline void S_DESPAWN::add_object_ids(uint64_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_DESPAWN::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_DESPAWN::_internal_mutable_object_ids() {
  return &_impl_.object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// S_DEATH

// uint64 object_ids = 1;
inline void S_DEATH::clear_object_ids() {
  _impl_.object_ids_ = uint64_t{0u};
}
inline uint64_t S_DEATH::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline uint64_t S_DEATH::object_ids() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DEATH.object_ids)
  return _internal_object_ids();
}
inline void S_DEATH::_internal_set_object_ids(uint64_t value) {
  
  _impl_.object_ids_ = value;
}
inline void S_DEATH::set_object_ids(uint64_t value) {
  _internal_set_object_ids(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DEATH.object_ids)
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.PosInfo info = 1;
inline bool C_MOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_MOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::PosInfo& C_MOVE::_internal_info() const {
  const ::Protocol::PosInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& C_MOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.info)
  return _internal_info();
}
inline void C_MOVE::unsafe_arena_set_allocated_info(
    ::Protocol::PosInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.info)
}
inline ::Protocol::PosInfo* C_MOVE::release_info() {
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* C_MOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.info)
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* C_MOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::PosInfo* C_MOVE::mutable_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.info)
  return _msg;
}
inline void C_MOVE::set_allocated_info(::Protocol::PosInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.info)
}

// -------------------------------------------------------------------

// S_MOVE

// .Protocol.PosInfo info = 1;
inline bool S_MOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_MOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::PosInfo& S_MOVE::_internal_info() const {
  const ::Protocol::PosInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& S_MOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.info)
  return _internal_info();
}
inline void S_MOVE::unsafe_arena_set_allocated_info(
    ::Protocol::PosInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.info)
}
inline ::Protocol::PosInfo* S_MOVE::release_info() {
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* S_MOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.info)
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* S_MOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::PosInfo* S_MOVE::mutable_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.info)
  return _msg;
}
inline void S_MOVE::set_allocated_info(::Protocol::PosInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.info)
}

// -------------------------------------------------------------------

// C_STATUS

// .Protocol.StatusInfo info = 1;
inline bool C_STATUS::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_STATUS::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::StatusInfo& C_STATUS::_internal_info() const {
  const ::Protocol::StatusInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatusInfo&>(
      ::Protocol::_StatusInfo_default_instance_);
}
inline const ::Protocol::StatusInfo& C_STATUS::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_STATUS.info)
  return _internal_info();
}
inline void C_STATUS::unsafe_arena_set_allocated_info(
    ::Protocol::StatusInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_STATUS.info)
}
inline ::Protocol::StatusInfo* C_STATUS::release_info() {
  
  ::Protocol::StatusInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatusInfo* C_STATUS::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_STATUS.info)
  
  ::Protocol::StatusInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::StatusInfo* C_STATUS::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatusInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::StatusInfo* C_STATUS::mutable_info() {
  ::Protocol::StatusInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_STATUS.info)
  return _msg;
}
inline void C_STATUS::set_allocated_info(::Protocol::StatusInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_STATUS.info)
}

// -------------------------------------------------------------------

// S_STATUS

// .Protocol.StatusInfo info = 1;
inline bool S_STATUS::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_STATUS::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::StatusInfo& S_STATUS::_internal_info() const {
  const ::Protocol::StatusInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatusInfo&>(
      ::Protocol::_StatusInfo_default_instance_);
}
inline const ::Protocol::StatusInfo& S_STATUS::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STATUS.info)
  return _internal_info();
}
inline void S_STATUS::unsafe_arena_set_allocated_info(
    ::Protocol::StatusInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_STATUS.info)
}
inline ::Protocol::StatusInfo* S_STATUS::release_info() {
  
  ::Protocol::StatusInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatusInfo* S_STATUS::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_STATUS.info)
  
  ::Protocol::StatusInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::StatusInfo* S_STATUS::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatusInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::StatusInfo* S_STATUS::mutable_info() {
  ::Protocol::StatusInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_STATUS.info)
  return _msg;
}
inline void S_STATUS::set_allocated_info(::Protocol::StatusInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_STATUS.info)
}

// -------------------------------------------------------------------

// C_CHAT

// uint64 playerId = 1;
inline void C_CHAT::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t C_CHAT::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t C_CHAT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.playerId)
  return _internal_playerid();
}
inline void C_CHAT::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void C_CHAT::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.playerId)
}

// string msg = 2;
inline void C_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& C_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.msg)
}
inline std::string* C_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.msg)
  return _s;
}
inline const std::string& C_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void C_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void C_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.msg)
}

// -------------------------------------------------------------------

// S_CHAT

// string msg = 1;
inline void S_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& S_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.msg)
}
inline std::string* S_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.msg)
  return _s;
}
inline const std::string& S_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void S_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void S_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.msg)
}

// -------------------------------------------------------------------

// S_MELEEATTACK

// .Protocol.MeleeAttackInfo ability = 1;
inline bool S_MELEEATTACK::_internal_has_ability() const {
  return this != internal_default_instance() && _impl_.ability_ != nullptr;
}
inline bool S_MELEEATTACK::has_ability() const {
  return _internal_has_ability();
}
inline const ::Protocol::MeleeAttackInfo& S_MELEEATTACK::_internal_ability() const {
  const ::Protocol::MeleeAttackInfo* p = _impl_.ability_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::MeleeAttackInfo&>(
      ::Protocol::_MeleeAttackInfo_default_instance_);
}
inline const ::Protocol::MeleeAttackInfo& S_MELEEATTACK::ability() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MELEEATTACK.ability)
  return _internal_ability();
}
inline void S_MELEEATTACK::unsafe_arena_set_allocated_ability(
    ::Protocol::MeleeAttackInfo* ability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ability_);
  }
  _impl_.ability_ = ability;
  if (ability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MELEEATTACK.ability)
}
inline ::Protocol::MeleeAttackInfo* S_MELEEATTACK::release_ability() {
  
  ::Protocol::MeleeAttackInfo* temp = _impl_.ability_;
  _impl_.ability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::MeleeAttackInfo* S_MELEEATTACK::unsafe_arena_release_ability() {
  // @@protoc_insertion_point(field_release:Protocol.S_MELEEATTACK.ability)
  
  ::Protocol::MeleeAttackInfo* temp = _impl_.ability_;
  _impl_.ability_ = nullptr;
  return temp;
}
inline ::Protocol::MeleeAttackInfo* S_MELEEATTACK::_internal_mutable_ability() {
  
  if (_impl_.ability_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::MeleeAttackInfo>(GetArenaForAllocation());
    _impl_.ability_ = p;
  }
  return _impl_.ability_;
}
inline ::Protocol::MeleeAttackInfo* S_MELEEATTACK::mutable_ability() {
  ::Protocol::MeleeAttackInfo* _msg = _internal_mutable_ability();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MELEEATTACK.ability)
  return _msg;
}
inline void S_MELEEATTACK::set_allocated_ability(::Protocol::MeleeAttackInfo* ability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ability_);
  }
  if (ability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ability));
    if (message_arena != submessage_arena) {
      ability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ability, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ability_ = ability;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MELEEATTACK.ability)
}

// -------------------------------------------------------------------

// C_MELEEATTACK

// .Protocol.MeleeAttackInfo ability = 1;
inline bool C_MELEEATTACK::_internal_has_ability() const {
  return this != internal_default_instance() && _impl_.ability_ != nullptr;
}
inline bool C_MELEEATTACK::has_ability() const {
  return _internal_has_ability();
}
inline const ::Protocol::MeleeAttackInfo& C_MELEEATTACK::_internal_ability() const {
  const ::Protocol::MeleeAttackInfo* p = _impl_.ability_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::MeleeAttackInfo&>(
      ::Protocol::_MeleeAttackInfo_default_instance_);
}
inline const ::Protocol::MeleeAttackInfo& C_MELEEATTACK::ability() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MELEEATTACK.ability)
  return _internal_ability();
}
inline void C_MELEEATTACK::unsafe_arena_set_allocated_ability(
    ::Protocol::MeleeAttackInfo* ability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ability_);
  }
  _impl_.ability_ = ability;
  if (ability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MELEEATTACK.ability)
}
inline ::Protocol::MeleeAttackInfo* C_MELEEATTACK::release_ability() {
  
  ::Protocol::MeleeAttackInfo* temp = _impl_.ability_;
  _impl_.ability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::MeleeAttackInfo* C_MELEEATTACK::unsafe_arena_release_ability() {
  // @@protoc_insertion_point(field_release:Protocol.C_MELEEATTACK.ability)
  
  ::Protocol::MeleeAttackInfo* temp = _impl_.ability_;
  _impl_.ability_ = nullptr;
  return temp;
}
inline ::Protocol::MeleeAttackInfo* C_MELEEATTACK::_internal_mutable_ability() {
  
  if (_impl_.ability_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::MeleeAttackInfo>(GetArenaForAllocation());
    _impl_.ability_ = p;
  }
  return _impl_.ability_;
}
inline ::Protocol::MeleeAttackInfo* C_MELEEATTACK::mutable_ability() {
  ::Protocol::MeleeAttackInfo* _msg = _internal_mutable_ability();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MELEEATTACK.ability)
  return _msg;
}
inline void C_MELEEATTACK::set_allocated_ability(::Protocol::MeleeAttackInfo* ability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ability_);
  }
  if (ability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ability));
    if (message_arena != submessage_arena) {
      ability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ability, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ability_ = ability;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MELEEATTACK.ability)
}

// -------------------------------------------------------------------

// C_PATHFINDING

// repeated .Protocol.PosInfo info = 1;
inline int C_PATHFINDING::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int C_PATHFINDING::info_size() const {
  return _internal_info_size();
}
inline ::Protocol::PosInfo* C_PATHFINDING::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_PATHFINDING.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >*
C_PATHFINDING::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_PATHFINDING.info)
  return &_impl_.info_;
}
inline const ::Protocol::PosInfo& C_PATHFINDING::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Protocol::PosInfo& C_PATHFINDING::info(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_PATHFINDING.info)
  return _internal_info(index);
}
inline ::Protocol::PosInfo* C_PATHFINDING::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Protocol::PosInfo* C_PATHFINDING::add_info() {
  ::Protocol::PosInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Protocol.C_PATHFINDING.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >&
C_PATHFINDING::info() const {
  // @@protoc_insertion_point(field_list:Protocol.C_PATHFINDING.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// S_PATHFINDING

// repeated .Protocol.PosInfo info = 1;
inline int S_PATHFINDING::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int S_PATHFINDING::info_size() const {
  return _internal_info_size();
}
inline ::Protocol::PosInfo* S_PATHFINDING::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_PATHFINDING.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >*
S_PATHFINDING::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_PATHFINDING.info)
  return &_impl_.info_;
}
inline const ::Protocol::PosInfo& S_PATHFINDING::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Protocol::PosInfo& S_PATHFINDING::info(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_PATHFINDING.info)
  return _internal_info(index);
}
inline ::Protocol::PosInfo* S_PATHFINDING::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Protocol::PosInfo* S_PATHFINDING::add_info() {
  ::Protocol::PosInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Protocol.S_PATHFINDING.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PosInfo >&
S_PATHFINDING::info() const {
  // @@protoc_insertion_point(field_list:Protocol.S_PATHFINDING.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// C_SHOOTPROJECTILE

// repeated .Protocol.ProjectileInfo info = 1;
inline int C_SHOOTPROJECTILE::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int C_SHOOTPROJECTILE::info_size() const {
  return _internal_info_size();
}
inline ::Protocol::ProjectileInfo* C_SHOOTPROJECTILE::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.C_SHOOTPROJECTILE.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >*
C_SHOOTPROJECTILE::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_SHOOTPROJECTILE.info)
  return &_impl_.info_;
}
inline const ::Protocol::ProjectileInfo& C_SHOOTPROJECTILE::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Protocol::ProjectileInfo& C_SHOOTPROJECTILE::info(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_SHOOTPROJECTILE.info)
  return _internal_info(index);
}
inline ::Protocol::ProjectileInfo* C_SHOOTPROJECTILE::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Protocol::ProjectileInfo* C_SHOOTPROJECTILE::add_info() {
  ::Protocol::ProjectileInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Protocol.C_SHOOTPROJECTILE.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >&
C_SHOOTPROJECTILE::info() const {
  // @@protoc_insertion_point(field_list:Protocol.C_SHOOTPROJECTILE.info)
  return _impl_.info_;
}

// float shooter_yaw = 2;
inline void C_SHOOTPROJECTILE::clear_shooter_yaw() {
  _impl_.shooter_yaw_ = 0;
}
inline float C_SHOOTPROJECTILE::_internal_shooter_yaw() const {
  return _impl_.shooter_yaw_;
}
inline float C_SHOOTPROJECTILE::shooter_yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SHOOTPROJECTILE.shooter_yaw)
  return _internal_shooter_yaw();
}
inline void C_SHOOTPROJECTILE::_internal_set_shooter_yaw(float value) {
  
  _impl_.shooter_yaw_ = value;
}
inline void C_SHOOTPROJECTILE::set_shooter_yaw(float value) {
  _internal_set_shooter_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SHOOTPROJECTILE.shooter_yaw)
}

// -------------------------------------------------------------------

// S_SHOOTPROJECTILE

// uint64 shooterid = 1;
inline void S_SHOOTPROJECTILE::clear_shooterid() {
  _impl_.shooterid_ = uint64_t{0u};
}
inline uint64_t S_SHOOTPROJECTILE::_internal_shooterid() const {
  return _impl_.shooterid_;
}
inline uint64_t S_SHOOTPROJECTILE::shooterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SHOOTPROJECTILE.shooterid)
  return _internal_shooterid();
}
inline void S_SHOOTPROJECTILE::_internal_set_shooterid(uint64_t value) {
  
  _impl_.shooterid_ = value;
}
inline void S_SHOOTPROJECTILE::set_shooterid(uint64_t value) {
  _internal_set_shooterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SHOOTPROJECTILE.shooterid)
}

// repeated .Protocol.ProjectileInfo info = 2;
inline int S_SHOOTPROJECTILE::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int S_SHOOTPROJECTILE::info_size() const {
  return _internal_info_size();
}
inline ::Protocol::ProjectileInfo* S_SHOOTPROJECTILE::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SHOOTPROJECTILE.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >*
S_SHOOTPROJECTILE::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SHOOTPROJECTILE.info)
  return &_impl_.info_;
}
inline const ::Protocol::ProjectileInfo& S_SHOOTPROJECTILE::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Protocol::ProjectileInfo& S_SHOOTPROJECTILE::info(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SHOOTPROJECTILE.info)
  return _internal_info(index);
}
inline ::Protocol::ProjectileInfo* S_SHOOTPROJECTILE::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Protocol::ProjectileInfo* S_SHOOTPROJECTILE::add_info() {
  ::Protocol::ProjectileInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Protocol.S_SHOOTPROJECTILE.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ProjectileInfo >&
S_SHOOTPROJECTILE::info() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SHOOTPROJECTILE.info)
  return _impl_.info_;
}

// float shooter_yaw = 3;
inline void S_SHOOTPROJECTILE::clear_shooter_yaw() {
  _impl_.shooter_yaw_ = 0;
}
inline float S_SHOOTPROJECTILE::_internal_shooter_yaw() const {
  return _impl_.shooter_yaw_;
}
inline float S_SHOOTPROJECTILE::shooter_yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SHOOTPROJECTILE.shooter_yaw)
  return _internal_shooter_yaw();
}
inline void S_SHOOTPROJECTILE::_internal_set_shooter_yaw(float value) {
  
  _impl_.shooter_yaw_ = value;
}
inline void S_SHOOTPROJECTILE::set_shooter_yaw(float value) {
  _internal_set_shooter_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SHOOTPROJECTILE.shooter_yaw)
}

// -------------------------------------------------------------------

// C_HITDAMAGE

// .Protocol.HitInfo info = 1;
inline bool C_HITDAMAGE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_HITDAMAGE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::HitInfo& C_HITDAMAGE::_internal_info() const {
  const ::Protocol::HitInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::HitInfo&>(
      ::Protocol::_HitInfo_default_instance_);
}
inline const ::Protocol::HitInfo& C_HITDAMAGE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_HITDAMAGE.info)
  return _internal_info();
}
inline void C_HITDAMAGE::unsafe_arena_set_allocated_info(
    ::Protocol::HitInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_HITDAMAGE.info)
}
inline ::Protocol::HitInfo* C_HITDAMAGE::release_info() {
  
  ::Protocol::HitInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::HitInfo* C_HITDAMAGE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_HITDAMAGE.info)
  
  ::Protocol::HitInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::HitInfo* C_HITDAMAGE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::HitInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::HitInfo* C_HITDAMAGE::mutable_info() {
  ::Protocol::HitInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_HITDAMAGE.info)
  return _msg;
}
inline void C_HITDAMAGE::set_allocated_info(::Protocol::HitInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_HITDAMAGE.info)
}

// -------------------------------------------------------------------

// S_HITDAMAGE

// .Protocol.HitInfo info = 1;
inline bool S_HITDAMAGE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_HITDAMAGE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::HitInfo& S_HITDAMAGE::_internal_info() const {
  const ::Protocol::HitInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::HitInfo&>(
      ::Protocol::_HitInfo_default_instance_);
}
inline const ::Protocol::HitInfo& S_HITDAMAGE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_HITDAMAGE.info)
  return _internal_info();
}
inline void S_HITDAMAGE::unsafe_arena_set_allocated_info(
    ::Protocol::HitInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_HITDAMAGE.info)
}
inline ::Protocol::HitInfo* S_HITDAMAGE::release_info() {
  
  ::Protocol::HitInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::HitInfo* S_HITDAMAGE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_HITDAMAGE.info)
  
  ::Protocol::HitInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::HitInfo* S_HITDAMAGE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::HitInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::HitInfo* S_HITDAMAGE::mutable_info() {
  ::Protocol::HitInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_HITDAMAGE.info)
  return _msg;
}
inline void S_HITDAMAGE::set_allocated_info(::Protocol::HitInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_HITDAMAGE.info)
}

// -------------------------------------------------------------------

// S_SHOP_ITEM_LIST

// .Protocol.ShopInfo info = 1;
inline bool S_SHOP_ITEM_LIST::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_SHOP_ITEM_LIST::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ShopInfo& S_SHOP_ITEM_LIST::_internal_info() const {
  const ::Protocol::ShopInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ShopInfo&>(
      ::Protocol::_ShopInfo_default_instance_);
}
inline const ::Protocol::ShopInfo& S_SHOP_ITEM_LIST::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SHOP_ITEM_LIST.info)
  return _internal_info();
}
inline void S_SHOP_ITEM_LIST::unsafe_arena_set_allocated_info(
    ::Protocol::ShopInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_SHOP_ITEM_LIST.info)
}
inline ::Protocol::ShopInfo* S_SHOP_ITEM_LIST::release_info() {
  
  ::Protocol::ShopInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ShopInfo* S_SHOP_ITEM_LIST::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_SHOP_ITEM_LIST.info)
  
  ::Protocol::ShopInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ShopInfo* S_SHOP_ITEM_LIST::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ShopInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ShopInfo* S_SHOP_ITEM_LIST::mutable_info() {
  ::Protocol::ShopInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SHOP_ITEM_LIST.info)
  return _msg;
}
inline void S_SHOP_ITEM_LIST::set_allocated_info(::Protocol::ShopInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SHOP_ITEM_LIST.info)
}

// -------------------------------------------------------------------

// C_REFRESH_ITEM_LIST

// bool success = 1;
inline void C_REFRESH_ITEM_LIST::clear_success() {
  _impl_.success_ = false;
}
inline bool C_REFRESH_ITEM_LIST::_internal_success() const {
  return _impl_.success_;
}
inline bool C_REFRESH_ITEM_LIST::success() const {
  // @@protoc_insertion_point(field_get:Protocol.C_REFRESH_ITEM_LIST.success)
  return _internal_success();
}
inline void C_REFRESH_ITEM_LIST::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void C_REFRESH_ITEM_LIST::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.C_REFRESH_ITEM_LIST.success)
}

// -------------------------------------------------------------------

// C_BUY_SHOP_ITEM

// uint32 item_index = 1;
inline void C_BUY_SHOP_ITEM::clear_item_index() {
  _impl_.item_index_ = 0u;
}
inline uint32_t C_BUY_SHOP_ITEM::_internal_item_index() const {
  return _impl_.item_index_;
}
inline uint32_t C_BUY_SHOP_ITEM::item_index() const {
  // @@protoc_insertion_point(field_get:Protocol.C_BUY_SHOP_ITEM.item_index)
  return _internal_item_index();
}
inline void C_BUY_SHOP_ITEM::_internal_set_item_index(uint32_t value) {
  
  _impl_.item_index_ = value;
}
inline void C_BUY_SHOP_ITEM::set_item_index(uint32_t value) {
  _internal_set_item_index(value);
  // @@protoc_insertion_point(field_set:Protocol.C_BUY_SHOP_ITEM.item_index)
}

// bool full_inventory = 2;
inline void C_BUY_SHOP_ITEM::clear_full_inventory() {
  _impl_.full_inventory_ = false;
}
inline bool C_BUY_SHOP_ITEM::_internal_full_inventory() const {
  return _impl_.full_inventory_;
}
inline bool C_BUY_SHOP_ITEM::full_inventory() const {
  // @@protoc_insertion_point(field_get:Protocol.C_BUY_SHOP_ITEM.full_inventory)
  return _internal_full_inventory();
}
inline void C_BUY_SHOP_ITEM::_internal_set_full_inventory(bool value) {
  
  _impl_.full_inventory_ = value;
}
inline void C_BUY_SHOP_ITEM::set_full_inventory(bool value) {
  _internal_set_full_inventory(value);
  // @@protoc_insertion_point(field_set:Protocol.C_BUY_SHOP_ITEM.full_inventory)
}

// uint32 inventory_index = 3;
inline void C_BUY_SHOP_ITEM::clear_inventory_index() {
  _impl_.inventory_index_ = 0u;
}
inline uint32_t C_BUY_SHOP_ITEM::_internal_inventory_index() const {
  return _impl_.inventory_index_;
}
inline uint32_t C_BUY_SHOP_ITEM::inventory_index() const {
  // @@protoc_insertion_point(field_get:Protocol.C_BUY_SHOP_ITEM.inventory_index)
  return _internal_inventory_index();
}
inline void C_BUY_SHOP_ITEM::_internal_set_inventory_index(uint32_t value) {
  
  _impl_.inventory_index_ = value;
}
inline void C_BUY_SHOP_ITEM::set_inventory_index(uint32_t value) {
  _internal_set_inventory_index(value);
  // @@protoc_insertion_point(field_set:Protocol.C_BUY_SHOP_ITEM.inventory_index)
}

// -------------------------------------------------------------------

// S_BUY_SHOP_ITEM

// bool success = 1;
inline void S_BUY_SHOP_ITEM::clear_success() {
  _impl_.success_ = false;
}
inline bool S_BUY_SHOP_ITEM::_internal_success() const {
  return _impl_.success_;
}
inline bool S_BUY_SHOP_ITEM::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BUY_SHOP_ITEM.success)
  return _internal_success();
}
inline void S_BUY_SHOP_ITEM::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_BUY_SHOP_ITEM::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BUY_SHOP_ITEM.success)
}

// uint32 item_index = 2;
inline void S_BUY_SHOP_ITEM::clear_item_index() {
  _impl_.item_index_ = 0u;
}
inline uint32_t S_BUY_SHOP_ITEM::_internal_item_index() const {
  return _impl_.item_index_;
}
inline uint32_t S_BUY_SHOP_ITEM::item_index() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BUY_SHOP_ITEM.item_index)
  return _internal_item_index();
}
inline void S_BUY_SHOP_ITEM::_internal_set_item_index(uint32_t value) {
  
  _impl_.item_index_ = value;
}
inline void S_BUY_SHOP_ITEM::set_item_index(uint32_t value) {
  _internal_set_item_index(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BUY_SHOP_ITEM.item_index)
}

// .Protocol.ShopItemInfo info = 3;
inline bool S_BUY_SHOP_ITEM::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_BUY_SHOP_ITEM::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ShopItemInfo& S_BUY_SHOP_ITEM::_internal_info() const {
  const ::Protocol::ShopItemInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ShopItemInfo&>(
      ::Protocol::_ShopItemInfo_default_instance_);
}
inline const ::Protocol::ShopItemInfo& S_BUY_SHOP_ITEM::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BUY_SHOP_ITEM.info)
  return _internal_info();
}
inline void S_BUY_SHOP_ITEM::unsafe_arena_set_allocated_info(
    ::Protocol::ShopItemInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_BUY_SHOP_ITEM.info)
}
inline ::Protocol::ShopItemInfo* S_BUY_SHOP_ITEM::release_info() {
  
  ::Protocol::ShopItemInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ShopItemInfo* S_BUY_SHOP_ITEM::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_BUY_SHOP_ITEM.info)
  
  ::Protocol::ShopItemInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ShopItemInfo* S_BUY_SHOP_ITEM::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ShopItemInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ShopItemInfo* S_BUY_SHOP_ITEM::mutable_info() {
  ::Protocol::ShopItemInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BUY_SHOP_ITEM.info)
  return _msg;
}
inline void S_BUY_SHOP_ITEM::set_allocated_info(::Protocol::ShopItemInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BUY_SHOP_ITEM.info)
}

// -------------------------------------------------------------------

// S_MAIL_SEND

// .Protocol.MailInfo mail = 1;
inline bool S_MAIL_SEND::_internal_has_mail() const {
  return this != internal_default_instance() && _impl_.mail_ != nullptr;
}
inline bool S_MAIL_SEND::has_mail() const {
  return _internal_has_mail();
}
inline const ::Protocol::MailInfo& S_MAIL_SEND::_internal_mail() const {
  const ::Protocol::MailInfo* p = _impl_.mail_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::MailInfo&>(
      ::Protocol::_MailInfo_default_instance_);
}
inline const ::Protocol::MailInfo& S_MAIL_SEND::mail() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MAIL_SEND.mail)
  return _internal_mail();
}
inline void S_MAIL_SEND::unsafe_arena_set_allocated_mail(
    ::Protocol::MailInfo* mail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mail_);
  }
  _impl_.mail_ = mail;
  if (mail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MAIL_SEND.mail)
}
inline ::Protocol::MailInfo* S_MAIL_SEND::release_mail() {
  
  ::Protocol::MailInfo* temp = _impl_.mail_;
  _impl_.mail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::MailInfo* S_MAIL_SEND::unsafe_arena_release_mail() {
  // @@protoc_insertion_point(field_release:Protocol.S_MAIL_SEND.mail)
  
  ::Protocol::MailInfo* temp = _impl_.mail_;
  _impl_.mail_ = nullptr;
  return temp;
}
inline ::Protocol::MailInfo* S_MAIL_SEND::_internal_mutable_mail() {
  
  if (_impl_.mail_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::MailInfo>(GetArenaForAllocation());
    _impl_.mail_ = p;
  }
  return _impl_.mail_;
}
inline ::Protocol::MailInfo* S_MAIL_SEND::mutable_mail() {
  ::Protocol::MailInfo* _msg = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MAIL_SEND.mail)
  return _msg;
}
inline void S_MAIL_SEND::set_allocated_mail(::Protocol::MailInfo* mail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mail_);
  }
  if (mail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mail));
    if (message_arena != submessage_arena) {
      mail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mail, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mail_ = mail;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MAIL_SEND.mail)
}

// -------------------------------------------------------------------

// S_MAIL_LIST

// .Protocol.MailBoxInfo mailbox = 1;
inline bool S_MAIL_LIST::_internal_has_mailbox() const {
  return this != internal_default_instance() && _impl_.mailbox_ != nullptr;
}
inline bool S_MAIL_LIST::has_mailbox() const {
  return _internal_has_mailbox();
}
inline const ::Protocol::MailBoxInfo& S_MAIL_LIST::_internal_mailbox() const {
  const ::Protocol::MailBoxInfo* p = _impl_.mailbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::MailBoxInfo&>(
      ::Protocol::_MailBoxInfo_default_instance_);
}
inline const ::Protocol::MailBoxInfo& S_MAIL_LIST::mailbox() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MAIL_LIST.mailbox)
  return _internal_mailbox();
}
inline void S_MAIL_LIST::unsafe_arena_set_allocated_mailbox(
    ::Protocol::MailBoxInfo* mailbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_);
  }
  _impl_.mailbox_ = mailbox;
  if (mailbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MAIL_LIST.mailbox)
}
inline ::Protocol::MailBoxInfo* S_MAIL_LIST::release_mailbox() {
  
  ::Protocol::MailBoxInfo* temp = _impl_.mailbox_;
  _impl_.mailbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::MailBoxInfo* S_MAIL_LIST::unsafe_arena_release_mailbox() {
  // @@protoc_insertion_point(field_release:Protocol.S_MAIL_LIST.mailbox)
  
  ::Protocol::MailBoxInfo* temp = _impl_.mailbox_;
  _impl_.mailbox_ = nullptr;
  return temp;
}
inline ::Protocol::MailBoxInfo* S_MAIL_LIST::_internal_mutable_mailbox() {
  
  if (_impl_.mailbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::MailBoxInfo>(GetArenaForAllocation());
    _impl_.mailbox_ = p;
  }
  return _impl_.mailbox_;
}
inline ::Protocol::MailBoxInfo* S_MAIL_LIST::mutable_mailbox() {
  ::Protocol::MailBoxInfo* _msg = _internal_mutable_mailbox();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MAIL_LIST.mailbox)
  return _msg;
}
inline void S_MAIL_LIST::set_allocated_mailbox(::Protocol::MailBoxInfo* mailbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_);
  }
  if (mailbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mailbox));
    if (message_arena != submessage_arena) {
      mailbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_ = mailbox;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MAIL_LIST.mailbox)
}

// -------------------------------------------------------------------

// C_MAIL_LIST

// bool success = 1;
inline void C_MAIL_LIST::clear_success() {
  _impl_.success_ = false;
}
inline bool C_MAIL_LIST::_internal_success() const {
  return _impl_.success_;
}
inline bool C_MAIL_LIST::success() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MAIL_LIST.success)
  return _internal_success();
}
inline void C_MAIL_LIST::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void C_MAIL_LIST::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MAIL_LIST.success)
}

// -------------------------------------------------------------------

// C_MAIL_ITEM_RECV

// uint32 mailIndex = 1;
inline void C_MAIL_ITEM_RECV::clear_mailindex() {
  _impl_.mailindex_ = 0u;
}
inline uint32_t C_MAIL_ITEM_RECV::_internal_mailindex() const {
  return _impl_.mailindex_;
}
inline uint32_t C_MAIL_ITEM_RECV::mailindex() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MAIL_ITEM_RECV.mailIndex)
  return _internal_mailindex();
}
inline void C_MAIL_ITEM_RECV::_internal_set_mailindex(uint32_t value) {
  
  _impl_.mailindex_ = value;
}
inline void C_MAIL_ITEM_RECV::set_mailindex(uint32_t value) {
  _internal_set_mailindex(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MAIL_ITEM_RECV.mailIndex)
}

// -------------------------------------------------------------------

// S_GOLD

// uint64 value = 1;
inline void S_GOLD::clear_value() {
  _impl_.value_ = uint64_t{0u};
}
inline uint64_t S_GOLD::_internal_value() const {
  return _impl_.value_;
}
inline uint64_t S_GOLD::value() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GOLD.value)
  return _internal_value();
}
inline void S_GOLD::_internal_set_value(uint64_t value) {
  
  _impl_.value_ = value;
}
inline void S_GOLD::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GOLD.value)
}

// -------------------------------------------------------------------

// C_GOLD

// uint64 value = 1;
inline void C_GOLD::clear_value() {
  _impl_.value_ = uint64_t{0u};
}
inline uint64_t C_GOLD::_internal_value() const {
  return _impl_.value_;
}
inline uint64_t C_GOLD::value() const {
  // @@protoc_insertion_point(field_get:Protocol.C_GOLD.value)
  return _internal_value();
}
inline void C_GOLD::_internal_set_value(uint64_t value) {
  
  _impl_.value_ = value;
}
inline void C_GOLD::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Protocol.C_GOLD.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

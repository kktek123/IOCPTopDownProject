// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Enum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Enum_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Enum_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum ObjectType : int {
  OBJECT_TYPE_NONE = 0,
  OBJECT_TYPE_CREATURE = 1,
  OBJECT_TYPE_PROJECTILE = 2,
  OBJECT_TYPE_ENV = 3,
  ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObjectType_IsValid(int value);
constexpr ObjectType ObjectType_MIN = OBJECT_TYPE_NONE;
constexpr ObjectType ObjectType_MAX = OBJECT_TYPE_ENV;
constexpr int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectType_descriptor();
template<typename T>
inline const std::string& ObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjectType_descriptor(), enum_t_value);
}
inline bool ObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
enum CreatureType : int {
  CREATURE_TYPE_NONE = 0,
  CREATURE_TYPE_PLAYER = 1,
  CREATURE_TYPE_MONSTER = 2,
  CREATURE_TYPE_NPC = 3,
  CreatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CreatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CreatureType_IsValid(int value);
constexpr CreatureType CreatureType_MIN = CREATURE_TYPE_NONE;
constexpr CreatureType CreatureType_MAX = CREATURE_TYPE_NPC;
constexpr int CreatureType_ARRAYSIZE = CreatureType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreatureType_descriptor();
template<typename T>
inline const std::string& CreatureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreatureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreatureType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreatureType_descriptor(), enum_t_value);
}
inline bool CreatureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CreatureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreatureType>(
    CreatureType_descriptor(), name, value);
}
enum PlayerType : int {
  PLAYER_TYPE_NONE = 0,
  PLAYER_TYPE_FIGHTER = 1,
  PLAYER_TYPE_SWORDMASTER = 2,
  PLAYER_TYPE_BABARIAN = 3,
  PLAYER_TYPE_WIZARD = 4,
  PLAYER_TYPE_ARCHER = 5,
  PlayerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerType_IsValid(int value);
constexpr PlayerType PlayerType_MIN = PLAYER_TYPE_NONE;
constexpr PlayerType PlayerType_MAX = PLAYER_TYPE_ARCHER;
constexpr int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor();
template<typename T>
inline const std::string& PlayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerType_descriptor(), enum_t_value);
}
inline bool PlayerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum MonsterType : int {
  MONSTER_TYPE_NONE = 0,
  MONSTER_TYPE_GRUDGE = 1,
  MONSTER_TYPE_BRAGHEST = 2,
  MONSTER_TYPE_DRAGON = 3,
  MonsterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MonsterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MonsterType_IsValid(int value);
constexpr MonsterType MonsterType_MIN = MONSTER_TYPE_NONE;
constexpr MonsterType MonsterType_MAX = MONSTER_TYPE_DRAGON;
constexpr int MonsterType_ARRAYSIZE = MonsterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MonsterType_descriptor();
template<typename T>
inline const std::string& MonsterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MonsterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MonsterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MonsterType_descriptor(), enum_t_value);
}
inline bool MonsterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MonsterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MonsterType>(
    MonsterType_descriptor(), name, value);
}
enum MoveState : int {
  MOVE_STATE_NONE = 0,
  MOVE_STATE_IDLE = 1,
  MOVE_STATE_RUN = 2,
  MOVE_STATE_JUMP = 3,
  MOVE_STATE_SKILL = 4,
  MoveState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MoveState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MoveState_IsValid(int value);
constexpr MoveState MoveState_MIN = MOVE_STATE_NONE;
constexpr MoveState MoveState_MAX = MOVE_STATE_SKILL;
constexpr int MoveState_ARRAYSIZE = MoveState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveState_descriptor();
template<typename T>
inline const std::string& MoveState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveState_descriptor(), enum_t_value);
}
inline bool MoveState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveState>(
    MoveState_descriptor(), name, value);
}
enum SkillState : int {
  SKILL_STATE_NONE = 0,
  SKILL_STATE_ATTACK = 1,
  SKILL_STATE_DASH = 2,
  SKILL_STATE_SKILL1 = 3,
  SkillState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SkillState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SkillState_IsValid(int value);
constexpr SkillState SkillState_MIN = SKILL_STATE_NONE;
constexpr SkillState SkillState_MAX = SKILL_STATE_SKILL1;
constexpr int SkillState_ARRAYSIZE = SkillState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SkillState_descriptor();
template<typename T>
inline const std::string& SkillState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkillState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkillState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SkillState_descriptor(), enum_t_value);
}
inline bool SkillState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SkillState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SkillState>(
    SkillState_descriptor(), name, value);
}
enum InputState : int {
  INPUT_STARTED = 0,
  INPUT_PRESSED = 1,
  INPUT_RELEASED = 2,
  InputState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InputState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InputState_IsValid(int value);
constexpr InputState InputState_MIN = INPUT_STARTED;
constexpr InputState InputState_MAX = INPUT_RELEASED;
constexpr int InputState_ARRAYSIZE = InputState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputState_descriptor();
template<typename T>
inline const std::string& InputState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputState_descriptor(), enum_t_value);
}
inline bool InputState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InputState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputState>(
    InputState_descriptor(), name, value);
}
enum DeathState : int {
  NotDead = 0,
  DeathStarted = 1,
  DeathFinished = 2,
  DeathState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeathState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeathState_IsValid(int value);
constexpr DeathState DeathState_MIN = NotDead;
constexpr DeathState DeathState_MAX = DeathFinished;
constexpr int DeathState_ARRAYSIZE = DeathState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeathState_descriptor();
template<typename T>
inline const std::string& DeathState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeathState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeathState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeathState_descriptor(), enum_t_value);
}
inline bool DeathState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeathState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeathState>(
    DeathState_descriptor(), name, value);
}
enum ItemBoxState : int {
  BOX_STATE_OPEN = 0,
  BOX_STATE_CLOSE = 1,
  ItemBoxState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemBoxState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemBoxState_IsValid(int value);
constexpr ItemBoxState ItemBoxState_MIN = BOX_STATE_OPEN;
constexpr ItemBoxState ItemBoxState_MAX = BOX_STATE_CLOSE;
constexpr int ItemBoxState_ARRAYSIZE = ItemBoxState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemBoxState_descriptor();
template<typename T>
inline const std::string& ItemBoxState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemBoxState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemBoxState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemBoxState_descriptor(), enum_t_value);
}
inline bool ItemBoxState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemBoxState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemBoxState>(
    ItemBoxState_descriptor(), name, value);
}
enum ItemBoxType : int {
  BOX_TYPE_1 = 0,
  BOX_TYPE_2 = 1,
  ItemBoxType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemBoxType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemBoxType_IsValid(int value);
constexpr ItemBoxType ItemBoxType_MIN = BOX_TYPE_1;
constexpr ItemBoxType ItemBoxType_MAX = BOX_TYPE_2;
constexpr int ItemBoxType_ARRAYSIZE = ItemBoxType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemBoxType_descriptor();
template<typename T>
inline const std::string& ItemBoxType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemBoxType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemBoxType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemBoxType_descriptor(), enum_t_value);
}
inline bool ItemBoxType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemBoxType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemBoxType>(
    ItemBoxType_descriptor(), name, value);
}
enum ItemType : int {
  ITEM_TYPE_NONE = 0,
  ITEM_TYPE_WEAPON = 1,
  ITEM_TYPE_ARMOR = 2,
  ITEM_TYPE_COIN = 3,
  ITEM_TYPE_POTION = 4,
  ITEM_TYPE_THROW = 5,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ITEM_TYPE_NONE;
constexpr ItemType ItemType_MAX = ITEM_TYPE_THROW;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum EquipType : int {
  EQUIP_TYPE_NONE = 0,
  EQUIP_TYPE_HELMET = 1,
  EQUIP_TYPE_CHEST = 2,
  EQUIP_TYPE_LEGS = 3,
  EQUIP_TYPE_HANDS = 4,
  EQUIP_TYPE_FOOT = 5,
  EQUIP_TYPE_COUNT = 6,
  EquipType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EquipType_IsValid(int value);
constexpr EquipType EquipType_MIN = EQUIP_TYPE_NONE;
constexpr EquipType EquipType_MAX = EQUIP_TYPE_COUNT;
constexpr int EquipType_ARRAYSIZE = EquipType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipType_descriptor();
template<typename T>
inline const std::string& EquipType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipType_descriptor(), enum_t_value);
}
inline bool EquipType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipType>(
    EquipType_descriptor(), name, value);
}
enum ItemRarity : int {
  ITEM_RARITY_POOR = 0,
  ITEM_RARITY_COMMEN = 1,
  ITEM_RARITY_UNCOMMEN = 2,
  ITEM_RARITY_RARE = 3,
  ITEM_RARITY_LEGENDERY = 4,
  ItemRarity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemRarity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemRarity_IsValid(int value);
constexpr ItemRarity ItemRarity_MIN = ITEM_RARITY_POOR;
constexpr ItemRarity ItemRarity_MAX = ITEM_RARITY_LEGENDERY;
constexpr int ItemRarity_ARRAYSIZE = ItemRarity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemRarity_descriptor();
template<typename T>
inline const std::string& ItemRarity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemRarity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemRarity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemRarity_descriptor(), enum_t_value);
}
inline bool ItemRarity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemRarity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemRarity>(
    ItemRarity_descriptor(), name, value);
}
enum ItemCustomType : int {
  ITEM_CUSTOM_NONE = 0,
  ITEM_CUSTOM_COIN = 1,
  ITEM_CUSTOM_POTION = 2,
  ITEM_CUSTOM_THROW = 3,
  ItemCustomType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemCustomType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemCustomType_IsValid(int value);
constexpr ItemCustomType ItemCustomType_MIN = ITEM_CUSTOM_NONE;
constexpr ItemCustomType ItemCustomType_MAX = ITEM_CUSTOM_THROW;
constexpr int ItemCustomType_ARRAYSIZE = ItemCustomType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemCustomType_descriptor();
template<typename T>
inline const std::string& ItemCustomType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemCustomType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemCustomType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemCustomType_descriptor(), enum_t_value);
}
inline bool ItemCustomType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemCustomType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemCustomType>(
    ItemCustomType_descriptor(), name, value);
}
enum EquipmentSlotType : int {
  UNARMED_LEFTHAND = 0,
  UNARMED_RIGHTHAND = 1,
  PRIMARY_LEFTHAND = 2,
  PRIMARY_RIGHTHAND = 3,
  PRIMARY_TWOHAND = 4,
  SECONDARY_LEFTHAND = 5,
  SECONDARY_RIGHTHAND = 6,
  SECONDARY_TWOHAND = 7,
  UTILITY_PRIMARY = 8,
  UTILITY_SECONDARY = 9,
  UTILITY_TERTIARY = 10,
  UTILITY_QUATERNARY = 11,
  HELMET = 12,
  CHEST = 13,
  LEGS = 14,
  HANDS = 15,
  FOOT = 16,
  COUNT = 17,
  EquipmentSlotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentSlotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EquipmentSlotType_IsValid(int value);
constexpr EquipmentSlotType EquipmentSlotType_MIN = UNARMED_LEFTHAND;
constexpr EquipmentSlotType EquipmentSlotType_MAX = COUNT;
constexpr int EquipmentSlotType_ARRAYSIZE = EquipmentSlotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentSlotType_descriptor();
template<typename T>
inline const std::string& EquipmentSlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentSlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentSlotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentSlotType_descriptor(), enum_t_value);
}
inline bool EquipmentSlotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentSlotType>(
    EquipmentSlotType_descriptor(), name, value);
}
enum ChestState : int {
  CHEST_OPEN = 0,
  CHEST_CLOSE = 1,
  ChestState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChestState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChestState_IsValid(int value);
constexpr ChestState ChestState_MIN = CHEST_OPEN;
constexpr ChestState ChestState_MAX = CHEST_CLOSE;
constexpr int ChestState_ARRAYSIZE = ChestState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChestState_descriptor();
template<typename T>
inline const std::string& ChestState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChestState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChestState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChestState_descriptor(), enum_t_value);
}
inline bool ChestState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChestState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChestState>(
    ChestState_descriptor(), name, value);
}
enum EquipState : int {
  EQUIP_UNARMED = 0,
  EQUIP_WEAPON_PRIMARY = 1,
  EQUIP_WEAPON_SECONDARY = 2,
  EQUIP_UTILITY_PRIMARY = 3,
  EQUIP_UTILITY_SECONDARY = 4,
  EQUIP_UTILITY_TERTIARY = 5,
  EQUIP_UTILITY_QUATERNARY = 6,
  EQUIP_COUNT = 7,
  EquipState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EquipState_IsValid(int value);
constexpr EquipState EquipState_MIN = EQUIP_UNARMED;
constexpr EquipState EquipState_MAX = EQUIP_COUNT;
constexpr int EquipState_ARRAYSIZE = EquipState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipState_descriptor();
template<typename T>
inline const std::string& EquipState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipState_descriptor(), enum_t_value);
}
inline bool EquipState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipState>(
    EquipState_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ObjectType>() {
  return ::Protocol::ObjectType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::CreatureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::CreatureType>() {
  return ::Protocol::CreatureType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::PlayerType>() {
  return ::Protocol::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::MonsterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::MonsterType>() {
  return ::Protocol::MonsterType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::MoveState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::MoveState>() {
  return ::Protocol::MoveState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::SkillState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::SkillState>() {
  return ::Protocol::SkillState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::InputState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::InputState>() {
  return ::Protocol::InputState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::DeathState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::DeathState>() {
  return ::Protocol::DeathState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ItemBoxState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ItemBoxState>() {
  return ::Protocol::ItemBoxState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ItemBoxType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ItemBoxType>() {
  return ::Protocol::ItemBoxType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ItemType>() {
  return ::Protocol::ItemType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EquipType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EquipType>() {
  return ::Protocol::EquipType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ItemRarity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ItemRarity>() {
  return ::Protocol::ItemRarity_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ItemCustomType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ItemCustomType>() {
  return ::Protocol::ItemCustomType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EquipmentSlotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EquipmentSlotType>() {
  return ::Protocol::EquipmentSlotType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ChestState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ChestState>() {
  return ::Protocol::ChestState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EquipState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EquipState>() {
  return ::Protocol::EquipState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto

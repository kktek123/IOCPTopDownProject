// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Struct.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Struct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Struct_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Struct_2eproto;
namespace Protocol {
class AIInfo;
struct AIInfoDefaultTypeInternal;
extern AIInfoDefaultTypeInternal _AIInfo_default_instance_;
class AbilityInputInfo;
struct AbilityInputInfoDefaultTypeInternal;
extern AbilityInputInfoDefaultTypeInternal _AbilityInputInfo_default_instance_;
class ClassInfo;
struct ClassInfoDefaultTypeInternal;
extern ClassInfoDefaultTypeInternal _ClassInfo_default_instance_;
class CreatureInfo;
struct CreatureInfoDefaultTypeInternal;
extern CreatureInfoDefaultTypeInternal _CreatureInfo_default_instance_;
class EquipStateInfo;
struct EquipStateInfoDefaultTypeInternal;
extern EquipStateInfoDefaultTypeInternal _EquipStateInfo_default_instance_;
class EquipmentList;
struct EquipmentListDefaultTypeInternal;
extern EquipmentListDefaultTypeInternal _EquipmentList_default_instance_;
class HitInfo;
struct HitInfoDefaultTypeInternal;
extern HitInfoDefaultTypeInternal _HitInfo_default_instance_;
class InventoryList;
struct InventoryListDefaultTypeInternal;
extern InventoryListDefaultTypeInternal _InventoryList_default_instance_;
class ItemBoxInfo;
struct ItemBoxInfoDefaultTypeInternal;
extern ItemBoxInfoDefaultTypeInternal _ItemBoxInfo_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class LevelPointInfo;
struct LevelPointInfoDefaultTypeInternal;
extern LevelPointInfoDefaultTypeInternal _LevelPointInfo_default_instance_;
class MailBoxInfo;
struct MailBoxInfoDefaultTypeInternal;
extern MailBoxInfoDefaultTypeInternal _MailBoxInfo_default_instance_;
class MailInfo;
struct MailInfoDefaultTypeInternal;
extern MailInfoDefaultTypeInternal _MailInfo_default_instance_;
class MeleeAttackInfo;
struct MeleeAttackInfoDefaultTypeInternal;
extern MeleeAttackInfoDefaultTypeInternal _MeleeAttackInfo_default_instance_;
class MonsterInfo;
struct MonsterInfoDefaultTypeInternal;
extern MonsterInfoDefaultTypeInternal _MonsterInfo_default_instance_;
class ObjectInfo;
struct ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class ObjectItemInfo;
struct ObjectItemInfoDefaultTypeInternal;
extern ObjectItemInfoDefaultTypeInternal _ObjectItemInfo_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PosInfo;
struct PosInfoDefaultTypeInternal;
extern PosInfoDefaultTypeInternal _PosInfo_default_instance_;
class ProjectileInfo;
struct ProjectileInfoDefaultTypeInternal;
extern ProjectileInfoDefaultTypeInternal _ProjectileInfo_default_instance_;
class ShopInfo;
struct ShopInfoDefaultTypeInternal;
extern ShopInfoDefaultTypeInternal _ShopInfo_default_instance_;
class ShopItemInfo;
struct ShopItemInfoDefaultTypeInternal;
extern ShopItemInfoDefaultTypeInternal _ShopItemInfo_default_instance_;
class StatusInfo;
struct StatusInfoDefaultTypeInternal;
extern StatusInfoDefaultTypeInternal _StatusInfo_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::AIInfo* Arena::CreateMaybeMessage<::Protocol::AIInfo>(Arena*);
template<> ::Protocol::AbilityInputInfo* Arena::CreateMaybeMessage<::Protocol::AbilityInputInfo>(Arena*);
template<> ::Protocol::ClassInfo* Arena::CreateMaybeMessage<::Protocol::ClassInfo>(Arena*);
template<> ::Protocol::CreatureInfo* Arena::CreateMaybeMessage<::Protocol::CreatureInfo>(Arena*);
template<> ::Protocol::EquipStateInfo* Arena::CreateMaybeMessage<::Protocol::EquipStateInfo>(Arena*);
template<> ::Protocol::EquipmentList* Arena::CreateMaybeMessage<::Protocol::EquipmentList>(Arena*);
template<> ::Protocol::HitInfo* Arena::CreateMaybeMessage<::Protocol::HitInfo>(Arena*);
template<> ::Protocol::InventoryList* Arena::CreateMaybeMessage<::Protocol::InventoryList>(Arena*);
template<> ::Protocol::ItemBoxInfo* Arena::CreateMaybeMessage<::Protocol::ItemBoxInfo>(Arena*);
template<> ::Protocol::ItemInfo* Arena::CreateMaybeMessage<::Protocol::ItemInfo>(Arena*);
template<> ::Protocol::LevelPointInfo* Arena::CreateMaybeMessage<::Protocol::LevelPointInfo>(Arena*);
template<> ::Protocol::MailBoxInfo* Arena::CreateMaybeMessage<::Protocol::MailBoxInfo>(Arena*);
template<> ::Protocol::MailInfo* Arena::CreateMaybeMessage<::Protocol::MailInfo>(Arena*);
template<> ::Protocol::MeleeAttackInfo* Arena::CreateMaybeMessage<::Protocol::MeleeAttackInfo>(Arena*);
template<> ::Protocol::MonsterInfo* Arena::CreateMaybeMessage<::Protocol::MonsterInfo>(Arena*);
template<> ::Protocol::ObjectInfo* Arena::CreateMaybeMessage<::Protocol::ObjectInfo>(Arena*);
template<> ::Protocol::ObjectItemInfo* Arena::CreateMaybeMessage<::Protocol::ObjectItemInfo>(Arena*);
template<> ::Protocol::PlayerInfo* Arena::CreateMaybeMessage<::Protocol::PlayerInfo>(Arena*);
template<> ::Protocol::PosInfo* Arena::CreateMaybeMessage<::Protocol::PosInfo>(Arena*);
template<> ::Protocol::ProjectileInfo* Arena::CreateMaybeMessage<::Protocol::ProjectileInfo>(Arena*);
template<> ::Protocol::ShopInfo* Arena::CreateMaybeMessage<::Protocol::ShopInfo>(Arena*);
template<> ::Protocol::ShopItemInfo* Arena::CreateMaybeMessage<::Protocol::ShopItemInfo>(Arena*);
template<> ::Protocol::StatusInfo* Arena::CreateMaybeMessage<::Protocol::StatusInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class PosInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PosInfo) */ {
 public:
  inline PosInfo() : PosInfo(nullptr) {}
  ~PosInfo() override;
  explicit PROTOBUF_CONSTEXPR PosInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PosInfo(const PosInfo& from);
  PosInfo(PosInfo&& from) noexcept
    : PosInfo() {
    *this = ::std::move(from);
  }

  inline PosInfo& operator=(const PosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PosInfo& operator=(PosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PosInfo* internal_default_instance() {
    return reinterpret_cast<const PosInfo*>(
               &_PosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PosInfo& a, PosInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PosInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PosInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PosInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PosInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PosInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PosInfo& from) {
    PosInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PosInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PosInfo";
  }
  protected:
  explicit PosInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kYawFieldNumber = 5,
    kPitchFieldNumber = 6,
    kStateFieldNumber = 7,
    kSkillFieldNumber = 8,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 5;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 6;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // .Protocol.MoveState state = 7;
  void clear_state();
  ::Protocol::MoveState state() const;
  void set_state(::Protocol::MoveState value);
  private:
  ::Protocol::MoveState _internal_state() const;
  void _internal_set_state(::Protocol::MoveState value);
  public:

  // .Protocol.SkillState skill = 8;
  void clear_skill();
  ::Protocol::SkillState skill() const;
  void set_skill(::Protocol::SkillState value);
  private:
  ::Protocol::SkillState _internal_skill() const;
  void _internal_set_skill(::Protocol::SkillState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PosInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float x_;
    float y_;
    float z_;
    float yaw_;
    float pitch_;
    int state_;
    int skill_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class HitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.HitInfo) */ {
 public:
  inline HitInfo() : HitInfo(nullptr) {}
  ~HitInfo() override;
  explicit PROTOBUF_CONSTEXPR HitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HitInfo(const HitInfo& from);
  HitInfo(HitInfo&& from) noexcept
    : HitInfo() {
    *this = ::std::move(from);
  }

  inline HitInfo& operator=(const HitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HitInfo& operator=(HitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HitInfo* internal_default_instance() {
    return reinterpret_cast<const HitInfo*>(
               &_HitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HitInfo& a, HitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HitInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HitInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HitInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HitInfo& from) {
    HitInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HitInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.HitInfo";
  }
  protected:
  explicit HitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kCauserIdFieldNumber = 2,
    kDamageFieldNumber = 3,
    kHitYawFieldNumber = 4,
    kHitBackFieldNumber = 5,
    kHitStunFieldNumber = 6,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 causer_id = 2;
  void clear_causer_id();
  uint64_t causer_id() const;
  void set_causer_id(uint64_t value);
  private:
  uint64_t _internal_causer_id() const;
  void _internal_set_causer_id(uint64_t value);
  public:

  // float damage = 3;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // float hit_yaw = 4;
  void clear_hit_yaw();
  float hit_yaw() const;
  void set_hit_yaw(float value);
  private:
  float _internal_hit_yaw() const;
  void _internal_set_hit_yaw(float value);
  public:

  // float hit_back = 5;
  void clear_hit_back();
  float hit_back() const;
  void set_hit_back(float value);
  private:
  float _internal_hit_back() const;
  void _internal_set_hit_back(float value);
  public:

  // float hit_stun = 6;
  void clear_hit_stun();
  float hit_stun() const;
  void set_hit_stun(float value);
  private:
  float _internal_hit_stun() const;
  void _internal_set_hit_stun(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.HitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t causer_id_;
    float damage_;
    float hit_yaw_;
    float hit_back_;
    float hit_stun_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class MeleeAttackInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MeleeAttackInfo) */ {
 public:
  inline MeleeAttackInfo() : MeleeAttackInfo(nullptr) {}
  ~MeleeAttackInfo() override;
  explicit PROTOBUF_CONSTEXPR MeleeAttackInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeleeAttackInfo(const MeleeAttackInfo& from);
  MeleeAttackInfo(MeleeAttackInfo&& from) noexcept
    : MeleeAttackInfo() {
    *this = ::std::move(from);
  }

  inline MeleeAttackInfo& operator=(const MeleeAttackInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeleeAttackInfo& operator=(MeleeAttackInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeleeAttackInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeleeAttackInfo* internal_default_instance() {
    return reinterpret_cast<const MeleeAttackInfo*>(
               &_MeleeAttackInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MeleeAttackInfo& a, MeleeAttackInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MeleeAttackInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeleeAttackInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeleeAttackInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeleeAttackInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeleeAttackInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MeleeAttackInfo& from) {
    MeleeAttackInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeleeAttackInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MeleeAttackInfo";
  }
  protected:
  explicit MeleeAttackInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kDamageFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float damage = 2;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // float yaw = 3;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MeleeAttackInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float damage_;
    float yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ProjectileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ProjectileInfo) */ {
 public:
  inline ProjectileInfo() : ProjectileInfo(nullptr) {}
  ~ProjectileInfo() override;
  explicit PROTOBUF_CONSTEXPR ProjectileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectileInfo(const ProjectileInfo& from);
  ProjectileInfo(ProjectileInfo&& from) noexcept
    : ProjectileInfo() {
    *this = ::std::move(from);
  }

  inline ProjectileInfo& operator=(const ProjectileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectileInfo& operator=(ProjectileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectileInfo* internal_default_instance() {
    return reinterpret_cast<const ProjectileInfo*>(
               &_ProjectileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProjectileInfo& a, ProjectileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProjectileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProjectileInfo& from) {
    ProjectileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ProjectileInfo";
  }
  protected:
  explicit ProjectileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCauserIdFieldNumber = 1,
    kSpawnXFieldNumber = 2,
    kSpawnYFieldNumber = 3,
    kSpawnZFieldNumber = 4,
    kDamageFieldNumber = 5,
    kShootYawFieldNumber = 6,
  };
  // uint64 causer_id = 1;
  void clear_causer_id();
  uint64_t causer_id() const;
  void set_causer_id(uint64_t value);
  private:
  uint64_t _internal_causer_id() const;
  void _internal_set_causer_id(uint64_t value);
  public:

  // float spawn_x = 2;
  void clear_spawn_x();
  float spawn_x() const;
  void set_spawn_x(float value);
  private:
  float _internal_spawn_x() const;
  void _internal_set_spawn_x(float value);
  public:

  // float spawn_y = 3;
  void clear_spawn_y();
  float spawn_y() const;
  void set_spawn_y(float value);
  private:
  float _internal_spawn_y() const;
  void _internal_set_spawn_y(float value);
  public:

  // float spawn_z = 4;
  void clear_spawn_z();
  float spawn_z() const;
  void set_spawn_z(float value);
  private:
  float _internal_spawn_z() const;
  void _internal_set_spawn_z(float value);
  public:

  // float damage = 5;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // float shoot_yaw = 6;
  void clear_shoot_yaw();
  float shoot_yaw() const;
  void set_shoot_yaw(float value);
  private:
  float _internal_shoot_yaw() const;
  void _internal_set_shoot_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ProjectileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t causer_id_;
    float spawn_x_;
    float spawn_y_;
    float spawn_z_;
    float damage_;
    float shoot_yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class StatusInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.StatusInfo) */ {
 public:
  inline StatusInfo() : StatusInfo(nullptr) {}
  ~StatusInfo() override;
  explicit PROTOBUF_CONSTEXPR StatusInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusInfo(const StatusInfo& from);
  StatusInfo(StatusInfo&& from) noexcept
    : StatusInfo() {
    *this = ::std::move(from);
  }

  inline StatusInfo& operator=(const StatusInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusInfo& operator=(StatusInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusInfo* internal_default_instance() {
    return reinterpret_cast<const StatusInfo*>(
               &_StatusInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StatusInfo& a, StatusInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusInfo& from) {
    StatusInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.StatusInfo";
  }
  protected:
  explicit StatusInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kMaxhpFieldNumber = 2,
    kHpFieldNumber = 3,
    kMaxmpFieldNumber = 4,
    kMpFieldNumber = 5,
    kAtkFieldNumber = 6,
    kDefFieldNumber = 7,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float maxhp = 2;
  void clear_maxhp();
  float maxhp() const;
  void set_maxhp(float value);
  private:
  float _internal_maxhp() const;
  void _internal_set_maxhp(float value);
  public:

  // float hp = 3;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float maxmp = 4;
  void clear_maxmp();
  float maxmp() const;
  void set_maxmp(float value);
  private:
  float _internal_maxmp() const;
  void _internal_set_maxmp(float value);
  public:

  // float mp = 5;
  void clear_mp();
  float mp() const;
  void set_mp(float value);
  private:
  float _internal_mp() const;
  void _internal_set_mp(float value);
  public:

  // float atk = 6;
  void clear_atk();
  float atk() const;
  void set_atk(float value);
  private:
  float _internal_atk() const;
  void _internal_set_atk(float value);
  public:

  // float def = 7;
  void clear_def();
  float def() const;
  void set_def(float value);
  private:
  float _internal_def() const;
  void _internal_set_def(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.StatusInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float maxhp_;
    float hp_;
    float maxmp_;
    float mp_;
    float atk_;
    float def_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ClassInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ClassInfo) */ {
 public:
  inline ClassInfo() : ClassInfo(nullptr) {}
  ~ClassInfo() override;
  explicit PROTOBUF_CONSTEXPR ClassInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClassInfo(const ClassInfo& from);
  ClassInfo(ClassInfo&& from) noexcept
    : ClassInfo() {
    *this = ::std::move(from);
  }

  inline ClassInfo& operator=(const ClassInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassInfo& operator=(ClassInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassInfo* internal_default_instance() {
    return reinterpret_cast<const ClassInfo*>(
               &_ClassInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClassInfo& a, ClassInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClassInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClassInfo& from) {
    ClassInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ClassInfo";
  }
  protected:
  explicit ClassInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kPlayerTypeFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // .Protocol.PlayerType player_type = 2;
  void clear_player_type();
  ::Protocol::PlayerType player_type() const;
  void set_player_type(::Protocol::PlayerType value);
  private:
  ::Protocol::PlayerType _internal_player_type() const;
  void _internal_set_player_type(::Protocol::PlayerType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ClassInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int player_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ObjectInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ObjectInfo) */ {
 public:
  inline ObjectInfo() : ObjectInfo(nullptr) {}
  ~ObjectInfo() override;
  explicit PROTOBUF_CONSTEXPR ObjectInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectInfo(const ObjectInfo& from);
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectInfo& from) {
    ObjectInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ObjectInfo";
  }
  protected:
  explicit ObjectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerTypeFieldNumber = 3,
    kPosInfoFieldNumber = 5,
    kStatusInfoFieldNumber = 6,
    kInputInfoFieldNumber = 7,
    kLevelInfoFieldNumber = 8,
    kObjectIdFieldNumber = 1,
    kObjectTypeFieldNumber = 2,
    kCreatureTypeFieldNumber = 4,
  };
  // .Protocol.ClassInfo player_type = 3;
  bool has_player_type() const;
  private:
  bool _internal_has_player_type() const;
  public:
  void clear_player_type();
  const ::Protocol::ClassInfo& player_type() const;
  PROTOBUF_NODISCARD ::Protocol::ClassInfo* release_player_type();
  ::Protocol::ClassInfo* mutable_player_type();
  void set_allocated_player_type(::Protocol::ClassInfo* player_type);
  private:
  const ::Protocol::ClassInfo& _internal_player_type() const;
  ::Protocol::ClassInfo* _internal_mutable_player_type();
  public:
  void unsafe_arena_set_allocated_player_type(
      ::Protocol::ClassInfo* player_type);
  ::Protocol::ClassInfo* unsafe_arena_release_player_type();

  // .Protocol.PosInfo pos_info = 5;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_pos_info();
  ::Protocol::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PosInfo* pos_info);
  private:
  const ::Protocol::PosInfo& _internal_pos_info() const;
  ::Protocol::PosInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PosInfo* pos_info);
  ::Protocol::PosInfo* unsafe_arena_release_pos_info();

  // .Protocol.StatusInfo status_info = 6;
  bool has_status_info() const;
  private:
  bool _internal_has_status_info() const;
  public:
  void clear_status_info();
  const ::Protocol::StatusInfo& status_info() const;
  PROTOBUF_NODISCARD ::Protocol::StatusInfo* release_status_info();
  ::Protocol::StatusInfo* mutable_status_info();
  void set_allocated_status_info(::Protocol::StatusInfo* status_info);
  private:
  const ::Protocol::StatusInfo& _internal_status_info() const;
  ::Protocol::StatusInfo* _internal_mutable_status_info();
  public:
  void unsafe_arena_set_allocated_status_info(
      ::Protocol::StatusInfo* status_info);
  ::Protocol::StatusInfo* unsafe_arena_release_status_info();

  // .Protocol.AbilityInputInfo input_info = 7;
  bool has_input_info() const;
  private:
  bool _internal_has_input_info() const;
  public:
  void clear_input_info();
  const ::Protocol::AbilityInputInfo& input_info() const;
  PROTOBUF_NODISCARD ::Protocol::AbilityInputInfo* release_input_info();
  ::Protocol::AbilityInputInfo* mutable_input_info();
  void set_allocated_input_info(::Protocol::AbilityInputInfo* input_info);
  private:
  const ::Protocol::AbilityInputInfo& _internal_input_info() const;
  ::Protocol::AbilityInputInfo* _internal_mutable_input_info();
  public:
  void unsafe_arena_set_allocated_input_info(
      ::Protocol::AbilityInputInfo* input_info);
  ::Protocol::AbilityInputInfo* unsafe_arena_release_input_info();

  // .Protocol.LevelPointInfo level_info = 8;
  bool has_level_info() const;
  private:
  bool _internal_has_level_info() const;
  public:
  void clear_level_info();
  const ::Protocol::LevelPointInfo& level_info() const;
  PROTOBUF_NODISCARD ::Protocol::LevelPointInfo* release_level_info();
  ::Protocol::LevelPointInfo* mutable_level_info();
  void set_allocated_level_info(::Protocol::LevelPointInfo* level_info);
  private:
  const ::Protocol::LevelPointInfo& _internal_level_info() const;
  ::Protocol::LevelPointInfo* _internal_mutable_level_info();
  public:
  void unsafe_arena_set_allocated_level_info(
      ::Protocol::LevelPointInfo* level_info);
  ::Protocol::LevelPointInfo* unsafe_arena_release_level_info();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // .Protocol.ObjectType object_type = 2;
  void clear_object_type();
  ::Protocol::ObjectType object_type() const;
  void set_object_type(::Protocol::ObjectType value);
  private:
  ::Protocol::ObjectType _internal_object_type() const;
  void _internal_set_object_type(::Protocol::ObjectType value);
  public:

  // .Protocol.CreatureType creature_type = 4;
  void clear_creature_type();
  ::Protocol::CreatureType creature_type() const;
  void set_creature_type(::Protocol::CreatureType value);
  private:
  ::Protocol::CreatureType _internal_creature_type() const;
  void _internal_set_creature_type(::Protocol::CreatureType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ObjectInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ClassInfo* player_type_;
    ::Protocol::PosInfo* pos_info_;
    ::Protocol::StatusInfo* status_info_;
    ::Protocol::AbilityInputInfo* input_info_;
    ::Protocol::LevelPointInfo* level_info_;
    uint64_t object_id_;
    int object_type_;
    int creature_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class CreatureInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CreatureInfo) */ {
 public:
  inline CreatureInfo() : CreatureInfo(nullptr) {}
  ~CreatureInfo() override;
  explicit PROTOBUF_CONSTEXPR CreatureInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureInfo(const CreatureInfo& from);
  CreatureInfo(CreatureInfo&& from) noexcept
    : CreatureInfo() {
    *this = ::std::move(from);
  }

  inline CreatureInfo& operator=(const CreatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureInfo& operator=(CreatureInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureInfo* internal_default_instance() {
    return reinterpret_cast<const CreatureInfo*>(
               &_CreatureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreatureInfo& a, CreatureInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureInfo& from) {
    CreatureInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CreatureInfo";
  }
  protected:
  explicit CreatureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 3,
    kStatusInfoFieldNumber = 4,
    kObjectIdFieldNumber = 1,
    kLevelFieldNumber = 2,
    kCreatureTypeFieldNumber = 5,
  };
  // .Protocol.PosInfo pos_info = 3;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_pos_info();
  ::Protocol::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PosInfo* pos_info);
  private:
  const ::Protocol::PosInfo& _internal_pos_info() const;
  ::Protocol::PosInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PosInfo* pos_info);
  ::Protocol::PosInfo* unsafe_arena_release_pos_info();

  // .Protocol.StatusInfo status_info = 4;
  bool has_status_info() const;
  private:
  bool _internal_has_status_info() const;
  public:
  void clear_status_info();
  const ::Protocol::StatusInfo& status_info() const;
  PROTOBUF_NODISCARD ::Protocol::StatusInfo* release_status_info();
  ::Protocol::StatusInfo* mutable_status_info();
  void set_allocated_status_info(::Protocol::StatusInfo* status_info);
  private:
  const ::Protocol::StatusInfo& _internal_status_info() const;
  ::Protocol::StatusInfo* _internal_mutable_status_info();
  public:
  void unsafe_arena_set_allocated_status_info(
      ::Protocol::StatusInfo* status_info);
  ::Protocol::StatusInfo* unsafe_arena_release_status_info();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // .Protocol.CreatureType creature_type = 5;
  void clear_creature_type();
  ::Protocol::CreatureType creature_type() const;
  void set_creature_type(::Protocol::CreatureType value);
  private:
  ::Protocol::CreatureType _internal_creature_type() const;
  void _internal_set_creature_type(::Protocol::CreatureType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CreatureInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* pos_info_;
    ::Protocol::StatusInfo* status_info_;
    uint64_t object_id_;
    uint32_t level_;
    int creature_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 10,
    kPlayerNameFieldNumber = 11,
    kPlayerTypeFieldNumber = 3,
    kPosInfoFieldNumber = 4,
    kStatusInfoFieldNumber = 5,
    kLevelInfoFieldNumber = 6,
    kInputInfoFieldNumber = 7,
    kInventoryListFieldNumber = 8,
    kEquipmentListFieldNumber = 9,
    kEquipStateFieldNumber = 12,
    kObjectIdFieldNumber = 1,
    kGoldFieldNumber = 13,
    kLevelFieldNumber = 2,
  };
  // string player_id = 10;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // string player_name = 11;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // .Protocol.ClassInfo player_type = 3;
  bool has_player_type() const;
  private:
  bool _internal_has_player_type() const;
  public:
  void clear_player_type();
  const ::Protocol::ClassInfo& player_type() const;
  PROTOBUF_NODISCARD ::Protocol::ClassInfo* release_player_type();
  ::Protocol::ClassInfo* mutable_player_type();
  void set_allocated_player_type(::Protocol::ClassInfo* player_type);
  private:
  const ::Protocol::ClassInfo& _internal_player_type() const;
  ::Protocol::ClassInfo* _internal_mutable_player_type();
  public:
  void unsafe_arena_set_allocated_player_type(
      ::Protocol::ClassInfo* player_type);
  ::Protocol::ClassInfo* unsafe_arena_release_player_type();

  // .Protocol.PosInfo pos_info = 4;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_pos_info();
  ::Protocol::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PosInfo* pos_info);
  private:
  const ::Protocol::PosInfo& _internal_pos_info() const;
  ::Protocol::PosInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PosInfo* pos_info);
  ::Protocol::PosInfo* unsafe_arena_release_pos_info();

  // .Protocol.StatusInfo status_info = 5;
  bool has_status_info() const;
  private:
  bool _internal_has_status_info() const;
  public:
  void clear_status_info();
  const ::Protocol::StatusInfo& status_info() const;
  PROTOBUF_NODISCARD ::Protocol::StatusInfo* release_status_info();
  ::Protocol::StatusInfo* mutable_status_info();
  void set_allocated_status_info(::Protocol::StatusInfo* status_info);
  private:
  const ::Protocol::StatusInfo& _internal_status_info() const;
  ::Protocol::StatusInfo* _internal_mutable_status_info();
  public:
  void unsafe_arena_set_allocated_status_info(
      ::Protocol::StatusInfo* status_info);
  ::Protocol::StatusInfo* unsafe_arena_release_status_info();

  // .Protocol.LevelPointInfo level_info = 6;
  bool has_level_info() const;
  private:
  bool _internal_has_level_info() const;
  public:
  void clear_level_info();
  const ::Protocol::LevelPointInfo& level_info() const;
  PROTOBUF_NODISCARD ::Protocol::LevelPointInfo* release_level_info();
  ::Protocol::LevelPointInfo* mutable_level_info();
  void set_allocated_level_info(::Protocol::LevelPointInfo* level_info);
  private:
  const ::Protocol::LevelPointInfo& _internal_level_info() const;
  ::Protocol::LevelPointInfo* _internal_mutable_level_info();
  public:
  void unsafe_arena_set_allocated_level_info(
      ::Protocol::LevelPointInfo* level_info);
  ::Protocol::LevelPointInfo* unsafe_arena_release_level_info();

  // .Protocol.AbilityInputInfo input_info = 7;
  bool has_input_info() const;
  private:
  bool _internal_has_input_info() const;
  public:
  void clear_input_info();
  const ::Protocol::AbilityInputInfo& input_info() const;
  PROTOBUF_NODISCARD ::Protocol::AbilityInputInfo* release_input_info();
  ::Protocol::AbilityInputInfo* mutable_input_info();
  void set_allocated_input_info(::Protocol::AbilityInputInfo* input_info);
  private:
  const ::Protocol::AbilityInputInfo& _internal_input_info() const;
  ::Protocol::AbilityInputInfo* _internal_mutable_input_info();
  public:
  void unsafe_arena_set_allocated_input_info(
      ::Protocol::AbilityInputInfo* input_info);
  ::Protocol::AbilityInputInfo* unsafe_arena_release_input_info();

  // .Protocol.InventoryList inventory_list = 8;
  bool has_inventory_list() const;
  private:
  bool _internal_has_inventory_list() const;
  public:
  void clear_inventory_list();
  const ::Protocol::InventoryList& inventory_list() const;
  PROTOBUF_NODISCARD ::Protocol::InventoryList* release_inventory_list();
  ::Protocol::InventoryList* mutable_inventory_list();
  void set_allocated_inventory_list(::Protocol::InventoryList* inventory_list);
  private:
  const ::Protocol::InventoryList& _internal_inventory_list() const;
  ::Protocol::InventoryList* _internal_mutable_inventory_list();
  public:
  void unsafe_arena_set_allocated_inventory_list(
      ::Protocol::InventoryList* inventory_list);
  ::Protocol::InventoryList* unsafe_arena_release_inventory_list();

  // .Protocol.EquipmentList equipment_list = 9;
  bool has_equipment_list() const;
  private:
  bool _internal_has_equipment_list() const;
  public:
  void clear_equipment_list();
  const ::Protocol::EquipmentList& equipment_list() const;
  PROTOBUF_NODISCARD ::Protocol::EquipmentList* release_equipment_list();
  ::Protocol::EquipmentList* mutable_equipment_list();
  void set_allocated_equipment_list(::Protocol::EquipmentList* equipment_list);
  private:
  const ::Protocol::EquipmentList& _internal_equipment_list() const;
  ::Protocol::EquipmentList* _internal_mutable_equipment_list();
  public:
  void unsafe_arena_set_allocated_equipment_list(
      ::Protocol::EquipmentList* equipment_list);
  ::Protocol::EquipmentList* unsafe_arena_release_equipment_list();

  // .Protocol.EquipStateInfo equip_state = 12;
  bool has_equip_state() const;
  private:
  bool _internal_has_equip_state() const;
  public:
  void clear_equip_state();
  const ::Protocol::EquipStateInfo& equip_state() const;
  PROTOBUF_NODISCARD ::Protocol::EquipStateInfo* release_equip_state();
  ::Protocol::EquipStateInfo* mutable_equip_state();
  void set_allocated_equip_state(::Protocol::EquipStateInfo* equip_state);
  private:
  const ::Protocol::EquipStateInfo& _internal_equip_state() const;
  ::Protocol::EquipStateInfo* _internal_mutable_equip_state();
  public:
  void unsafe_arena_set_allocated_equip_state(
      ::Protocol::EquipStateInfo* equip_state);
  ::Protocol::EquipStateInfo* unsafe_arena_release_equip_state();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 gold = 13;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
    ::Protocol::ClassInfo* player_type_;
    ::Protocol::PosInfo* pos_info_;
    ::Protocol::StatusInfo* status_info_;
    ::Protocol::LevelPointInfo* level_info_;
    ::Protocol::AbilityInputInfo* input_info_;
    ::Protocol::InventoryList* inventory_list_;
    ::Protocol::EquipmentList* equipment_list_;
    ::Protocol::EquipStateInfo* equip_state_;
    uint64_t object_id_;
    uint64_t gold_;
    uint32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class MonsterInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MonsterInfo) */ {
 public:
  inline MonsterInfo() : MonsterInfo(nullptr) {}
  ~MonsterInfo() override;
  explicit PROTOBUF_CONSTEXPR MonsterInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterInfo(const MonsterInfo& from);
  MonsterInfo(MonsterInfo&& from) noexcept
    : MonsterInfo() {
    *this = ::std::move(from);
  }

  inline MonsterInfo& operator=(const MonsterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterInfo& operator=(MonsterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterInfo* internal_default_instance() {
    return reinterpret_cast<const MonsterInfo*>(
               &_MonsterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MonsterInfo& a, MonsterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonsterInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MonsterInfo& from) {
    MonsterInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonsterInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MonsterInfo";
  }
  protected:
  explicit MonsterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 4,
    kStatusInfoFieldNumber = 5,
    kInputInfoFieldNumber = 6,
    kObjectIdFieldNumber = 1,
    kLevelFieldNumber = 2,
    kTypeFieldNumber = 7,
  };
  // .Protocol.PosInfo pos_info = 4;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_pos_info();
  ::Protocol::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PosInfo* pos_info);
  private:
  const ::Protocol::PosInfo& _internal_pos_info() const;
  ::Protocol::PosInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PosInfo* pos_info);
  ::Protocol::PosInfo* unsafe_arena_release_pos_info();

  // .Protocol.StatusInfo status_info = 5;
  bool has_status_info() const;
  private:
  bool _internal_has_status_info() const;
  public:
  void clear_status_info();
  const ::Protocol::StatusInfo& status_info() const;
  PROTOBUF_NODISCARD ::Protocol::StatusInfo* release_status_info();
  ::Protocol::StatusInfo* mutable_status_info();
  void set_allocated_status_info(::Protocol::StatusInfo* status_info);
  private:
  const ::Protocol::StatusInfo& _internal_status_info() const;
  ::Protocol::StatusInfo* _internal_mutable_status_info();
  public:
  void unsafe_arena_set_allocated_status_info(
      ::Protocol::StatusInfo* status_info);
  ::Protocol::StatusInfo* unsafe_arena_release_status_info();

  // .Protocol.AbilityInputInfo input_info = 6;
  bool has_input_info() const;
  private:
  bool _internal_has_input_info() const;
  public:
  void clear_input_info();
  const ::Protocol::AbilityInputInfo& input_info() const;
  PROTOBUF_NODISCARD ::Protocol::AbilityInputInfo* release_input_info();
  ::Protocol::AbilityInputInfo* mutable_input_info();
  void set_allocated_input_info(::Protocol::AbilityInputInfo* input_info);
  private:
  const ::Protocol::AbilityInputInfo& _internal_input_info() const;
  ::Protocol::AbilityInputInfo* _internal_mutable_input_info();
  public:
  void unsafe_arena_set_allocated_input_info(
      ::Protocol::AbilityInputInfo* input_info);
  ::Protocol::AbilityInputInfo* unsafe_arena_release_input_info();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // .Protocol.MonsterType type = 7;
  void clear_type();
  ::Protocol::MonsterType type() const;
  void set_type(::Protocol::MonsterType value);
  private:
  ::Protocol::MonsterType _internal_type() const;
  void _internal_set_type(::Protocol::MonsterType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MonsterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* pos_info_;
    ::Protocol::StatusInfo* status_info_;
    ::Protocol::AbilityInputInfo* input_info_;
    uint64_t object_id_;
    uint32_t level_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class AbilityInputInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.AbilityInputInfo) */ {
 public:
  inline AbilityInputInfo() : AbilityInputInfo(nullptr) {}
  ~AbilityInputInfo() override;
  explicit PROTOBUF_CONSTEXPR AbilityInputInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbilityInputInfo(const AbilityInputInfo& from);
  AbilityInputInfo(AbilityInputInfo&& from) noexcept
    : AbilityInputInfo() {
    *this = ::std::move(from);
  }

  inline AbilityInputInfo& operator=(const AbilityInputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbilityInputInfo& operator=(AbilityInputInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbilityInputInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbilityInputInfo* internal_default_instance() {
    return reinterpret_cast<const AbilityInputInfo*>(
               &_AbilityInputInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AbilityInputInfo& a, AbilityInputInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AbilityInputInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbilityInputInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbilityInputInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbilityInputInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbilityInputInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AbilityInputInfo& from) {
    AbilityInputInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbilityInputInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.AbilityInputInfo";
  }
  protected:
  explicit AbilityInputInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 2,
    kObjectIdFieldNumber = 1,
    kInputFieldNumber = 3,
  };
  // string tag = 2;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // .Protocol.InputState input = 3;
  void clear_input();
  ::Protocol::InputState input() const;
  void set_input(::Protocol::InputState value);
  private:
  ::Protocol::InputState _internal_input() const;
  void _internal_set_input(::Protocol::InputState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.AbilityInputInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    uint64_t object_id_;
    int input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class EquipStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.EquipStateInfo) */ {
 public:
  inline EquipStateInfo() : EquipStateInfo(nullptr) {}
  ~EquipStateInfo() override;
  explicit PROTOBUF_CONSTEXPR EquipStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipStateInfo(const EquipStateInfo& from);
  EquipStateInfo(EquipStateInfo&& from) noexcept
    : EquipStateInfo() {
    *this = ::std::move(from);
  }

  inline EquipStateInfo& operator=(const EquipStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipStateInfo& operator=(EquipStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipStateInfo* internal_default_instance() {
    return reinterpret_cast<const EquipStateInfo*>(
               &_EquipStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EquipStateInfo& a, EquipStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipStateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EquipStateInfo& from) {
    EquipStateInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipStateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.EquipStateInfo";
  }
  protected:
  explicit EquipStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kEquipStateFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // .Protocol.EquipState equip_state = 2;
  void clear_equip_state();
  ::Protocol::EquipState equip_state() const;
  void set_equip_state(::Protocol::EquipState value);
  private:
  ::Protocol::EquipState _internal_equip_state() const;
  void _internal_set_equip_state(::Protocol::EquipState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.EquipStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int equip_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class AIInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.AIInfo) */ {
 public:
  inline AIInfo() : AIInfo(nullptr) {}
  ~AIInfo() override;
  explicit PROTOBUF_CONSTEXPR AIInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AIInfo(const AIInfo& from);
  AIInfo(AIInfo&& from) noexcept
    : AIInfo() {
    *this = ::std::move(from);
  }

  inline AIInfo& operator=(const AIInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIInfo& operator=(AIInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AIInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AIInfo* internal_default_instance() {
    return reinterpret_cast<const AIInfo*>(
               &_AIInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AIInfo& a, AIInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AIInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AIInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AIInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AIInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AIInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AIInfo& from) {
    AIInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.AIInfo";
  }
  protected:
  explicit AIInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kTargetIdIdFieldNumber = 2,
    kCanAttackFieldNumber = 3,
    kPatrolXFieldNumber = 4,
    kPatrolYFieldNumber = 5,
    kPatrolZFieldNumber = 6,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 targetId_id = 2;
  void clear_targetid_id();
  uint64_t targetid_id() const;
  void set_targetid_id(uint64_t value);
  private:
  uint64_t _internal_targetid_id() const;
  void _internal_set_targetid_id(uint64_t value);
  public:

  // bool can_attack = 3;
  void clear_can_attack();
  bool can_attack() const;
  void set_can_attack(bool value);
  private:
  bool _internal_can_attack() const;
  void _internal_set_can_attack(bool value);
  public:

  // float Patrol_x = 4;
  void clear_patrol_x();
  float patrol_x() const;
  void set_patrol_x(float value);
  private:
  float _internal_patrol_x() const;
  void _internal_set_patrol_x(float value);
  public:

  // float Patrol_y = 5;
  void clear_patrol_y();
  float patrol_y() const;
  void set_patrol_y(float value);
  private:
  float _internal_patrol_y() const;
  void _internal_set_patrol_y(float value);
  public:

  // float Patrol_z = 6;
  void clear_patrol_z();
  float patrol_z() const;
  void set_patrol_z(float value);
  private:
  float _internal_patrol_z() const;
  void _internal_set_patrol_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.AIInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t targetid_id_;
    bool can_attack_;
    float patrol_x_;
    float patrol_y_;
    float patrol_z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class InventoryList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.InventoryList) */ {
 public:
  inline InventoryList() : InventoryList(nullptr) {}
  ~InventoryList() override;
  explicit PROTOBUF_CONSTEXPR InventoryList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryList(const InventoryList& from);
  InventoryList(InventoryList&& from) noexcept
    : InventoryList() {
    *this = ::std::move(from);
  }

  inline InventoryList& operator=(const InventoryList& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryList& operator=(InventoryList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryList& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryList* internal_default_instance() {
    return reinterpret_cast<const InventoryList*>(
               &_InventoryList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(InventoryList& a, InventoryList& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InventoryList& from) {
    InventoryList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.InventoryList";
  }
  protected:
  explicit InventoryList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::Protocol::ItemInfo* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_list();
  private:
  const ::Protocol::ItemInfo& _internal_list(int index) const;
  ::Protocol::ItemInfo* _internal_add_list();
  public:
  const ::Protocol::ItemInfo& list(int index) const;
  ::Protocol::ItemInfo* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      list() const;

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.InventoryList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > list_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class EquipmentList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.EquipmentList) */ {
 public:
  inline EquipmentList() : EquipmentList(nullptr) {}
  ~EquipmentList() override;
  explicit PROTOBUF_CONSTEXPR EquipmentList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipmentList(const EquipmentList& from);
  EquipmentList(EquipmentList&& from) noexcept
    : EquipmentList() {
    *this = ::std::move(from);
  }

  inline EquipmentList& operator=(const EquipmentList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentList& operator=(EquipmentList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentList& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipmentList* internal_default_instance() {
    return reinterpret_cast<const EquipmentList*>(
               &_EquipmentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EquipmentList& a, EquipmentList& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipmentList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipmentList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EquipmentList& from) {
    EquipmentList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.EquipmentList";
  }
  protected:
  explicit EquipmentList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::Protocol::ItemInfo* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_list();
  private:
  const ::Protocol::ItemInfo& _internal_list(int index) const;
  ::Protocol::ItemInfo* _internal_add_list();
  public:
  const ::Protocol::ItemInfo& list(int index) const;
  ::Protocol::ItemInfo* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      list() const;

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.EquipmentList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > list_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemInfo& from) {
    ItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemNameFieldNumber = 9,
    kItemVisualNameFieldNumber = 10,
    kObjectIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
    kGoldFieldNumber = 3,
    kItemTypeFieldNumber = 4,
    kItemRarityFieldNumber = 5,
    kCustomTypeFieldNumber = 6,
    kEquipTypeFieldNumber = 7,
    kItemCountFieldNumber = 8,
    kAtkFieldNumber = 11,
    kDefFieldNumber = 12,
    kDelayFieldNumber = 13,
    kRangeFieldNumber = 14,
  };
  // string item_name = 9;
  void clear_item_name();
  const std::string& item_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_name();
  PROTOBUF_NODISCARD std::string* release_item_name();
  void set_allocated_item_name(std::string* item_name);
  private:
  const std::string& _internal_item_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_name(const std::string& value);
  std::string* _internal_mutable_item_name();
  public:

  // string item_visual_name = 10;
  void clear_item_visual_name();
  const std::string& item_visual_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_visual_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_visual_name();
  PROTOBUF_NODISCARD std::string* release_item_visual_name();
  void set_allocated_item_visual_name(std::string* item_visual_name);
  private:
  const std::string& _internal_item_visual_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_visual_name(const std::string& value);
  std::string* _internal_mutable_item_visual_name();
  public:

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 item_id = 2;
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // uint64 gold = 3;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // .Protocol.ItemType item_type = 4;
  void clear_item_type();
  ::Protocol::ItemType item_type() const;
  void set_item_type(::Protocol::ItemType value);
  private:
  ::Protocol::ItemType _internal_item_type() const;
  void _internal_set_item_type(::Protocol::ItemType value);
  public:

  // .Protocol.ItemRarity item_rarity = 5;
  void clear_item_rarity();
  ::Protocol::ItemRarity item_rarity() const;
  void set_item_rarity(::Protocol::ItemRarity value);
  private:
  ::Protocol::ItemRarity _internal_item_rarity() const;
  void _internal_set_item_rarity(::Protocol::ItemRarity value);
  public:

  // .Protocol.ItemCustomType custom_type = 6;
  void clear_custom_type();
  ::Protocol::ItemCustomType custom_type() const;
  void set_custom_type(::Protocol::ItemCustomType value);
  private:
  ::Protocol::ItemCustomType _internal_custom_type() const;
  void _internal_set_custom_type(::Protocol::ItemCustomType value);
  public:

  // .Protocol.EquipType equip_type = 7;
  void clear_equip_type();
  ::Protocol::EquipType equip_type() const;
  void set_equip_type(::Protocol::EquipType value);
  private:
  ::Protocol::EquipType _internal_equip_type() const;
  void _internal_set_equip_type(::Protocol::EquipType value);
  public:

  // uint64 item_count = 8;
  void clear_item_count();
  uint64_t item_count() const;
  void set_item_count(uint64_t value);
  private:
  uint64_t _internal_item_count() const;
  void _internal_set_item_count(uint64_t value);
  public:

  // float atk = 11;
  void clear_atk();
  float atk() const;
  void set_atk(float value);
  private:
  float _internal_atk() const;
  void _internal_set_atk(float value);
  public:

  // float def = 12;
  void clear_def();
  float def() const;
  void set_def(float value);
  private:
  float _internal_def() const;
  void _internal_set_def(float value);
  public:

  // float delay = 13;
  void clear_delay();
  float delay() const;
  void set_delay(float value);
  private:
  float _internal_delay() const;
  void _internal_set_delay(float value);
  public:

  // float range = 14;
  void clear_range();
  float range() const;
  void set_range(float value);
  private:
  float _internal_range() const;
  void _internal_set_range(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_visual_name_;
    uint64_t object_id_;
    uint64_t item_id_;
    uint64_t gold_;
    int item_type_;
    int item_rarity_;
    int custom_type_;
    int equip_type_;
    uint64_t item_count_;
    float atk_;
    float def_;
    float delay_;
    float range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ObjectItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ObjectItemInfo) */ {
 public:
  inline ObjectItemInfo() : ObjectItemInfo(nullptr) {}
  ~ObjectItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ObjectItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectItemInfo(const ObjectItemInfo& from);
  ObjectItemInfo(ObjectItemInfo&& from) noexcept
    : ObjectItemInfo() {
    *this = ::std::move(from);
  }

  inline ObjectItemInfo& operator=(const ObjectItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectItemInfo& operator=(ObjectItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectItemInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectItemInfo*>(
               &_ObjectItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ObjectItemInfo& a, ObjectItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectItemInfo& from) {
    ObjectItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ObjectItemInfo";
  }
  protected:
  explicit ObjectItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kPosInfoFieldNumber = 3,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.ItemInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ItemInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ItemInfo* release_info();
  ::Protocol::ItemInfo* mutable_info();
  void set_allocated_info(::Protocol::ItemInfo* info);
  private:
  const ::Protocol::ItemInfo& _internal_info() const;
  ::Protocol::ItemInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ItemInfo* info);
  ::Protocol::ItemInfo* unsafe_arena_release_info();

  // .Protocol.PosInfo pos_info = 3;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_pos_info();
  ::Protocol::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PosInfo* pos_info);
  private:
  const ::Protocol::PosInfo& _internal_pos_info() const;
  ::Protocol::PosInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PosInfo* pos_info);
  ::Protocol::PosInfo* unsafe_arena_release_pos_info();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ObjectItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ItemInfo* info_;
    ::Protocol::PosInfo* pos_info_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ItemBoxInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ItemBoxInfo) */ {
 public:
  inline ItemBoxInfo() : ItemBoxInfo(nullptr) {}
  ~ItemBoxInfo() override;
  explicit PROTOBUF_CONSTEXPR ItemBoxInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemBoxInfo(const ItemBoxInfo& from);
  ItemBoxInfo(ItemBoxInfo&& from) noexcept
    : ItemBoxInfo() {
    *this = ::std::move(from);
  }

  inline ItemBoxInfo& operator=(const ItemBoxInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemBoxInfo& operator=(ItemBoxInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemBoxInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemBoxInfo* internal_default_instance() {
    return reinterpret_cast<const ItemBoxInfo*>(
               &_ItemBoxInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ItemBoxInfo& a, ItemBoxInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemBoxInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemBoxInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemBoxInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemBoxInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemBoxInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemBoxInfo& from) {
    ItemBoxInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemBoxInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ItemBoxInfo";
  }
  protected:
  explicit ItemBoxInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 4,
    kPosInfoFieldNumber = 5,
    kObjectIdFieldNumber = 1,
    kBoxTypeFieldNumber = 2,
    kBoxStateFieldNumber = 3,
  };
  // .Protocol.InventoryList list = 4;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::Protocol::InventoryList& list() const;
  PROTOBUF_NODISCARD ::Protocol::InventoryList* release_list();
  ::Protocol::InventoryList* mutable_list();
  void set_allocated_list(::Protocol::InventoryList* list);
  private:
  const ::Protocol::InventoryList& _internal_list() const;
  ::Protocol::InventoryList* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::Protocol::InventoryList* list);
  ::Protocol::InventoryList* unsafe_arena_release_list();

  // .Protocol.PosInfo pos_info = 5;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PosInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_pos_info();
  ::Protocol::PosInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PosInfo* pos_info);
  private:
  const ::Protocol::PosInfo& _internal_pos_info() const;
  ::Protocol::PosInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PosInfo* pos_info);
  ::Protocol::PosInfo* unsafe_arena_release_pos_info();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // .Protocol.ItemBoxType box_type = 2;
  void clear_box_type();
  ::Protocol::ItemBoxType box_type() const;
  void set_box_type(::Protocol::ItemBoxType value);
  private:
  ::Protocol::ItemBoxType _internal_box_type() const;
  void _internal_set_box_type(::Protocol::ItemBoxType value);
  public:

  // .Protocol.ItemBoxState box_state = 3;
  void clear_box_state();
  ::Protocol::ItemBoxState box_state() const;
  void set_box_state(::Protocol::ItemBoxState value);
  private:
  ::Protocol::ItemBoxState _internal_box_state() const;
  void _internal_set_box_state(::Protocol::ItemBoxState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ItemBoxInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::InventoryList* list_;
    ::Protocol::PosInfo* pos_info_;
    uint64_t object_id_;
    int box_type_;
    int box_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class LevelPointInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.LevelPointInfo) */ {
 public:
  inline LevelPointInfo() : LevelPointInfo(nullptr) {}
  ~LevelPointInfo() override;
  explicit PROTOBUF_CONSTEXPR LevelPointInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LevelPointInfo(const LevelPointInfo& from);
  LevelPointInfo(LevelPointInfo&& from) noexcept
    : LevelPointInfo() {
    *this = ::std::move(from);
  }

  inline LevelPointInfo& operator=(const LevelPointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LevelPointInfo& operator=(LevelPointInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LevelPointInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LevelPointInfo* internal_default_instance() {
    return reinterpret_cast<const LevelPointInfo*>(
               &_LevelPointInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LevelPointInfo& a, LevelPointInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LevelPointInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LevelPointInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LevelPointInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LevelPointInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LevelPointInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LevelPointInfo& from) {
    LevelPointInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LevelPointInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.LevelPointInfo";
  }
  protected:
  explicit LevelPointInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kLevelFieldNumber = 2,
    kSkillPointFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 skill_point = 3;
  void clear_skill_point();
  uint32_t skill_point() const;
  void set_skill_point(uint32_t value);
  private:
  uint32_t _internal_skill_point() const;
  void _internal_set_skill_point(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.LevelPointInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint32_t level_;
    uint32_t skill_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ShopItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ShopItemInfo) */ {
 public:
  inline ShopItemInfo() : ShopItemInfo(nullptr) {}
  ~ShopItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ShopItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShopItemInfo(const ShopItemInfo& from);
  ShopItemInfo(ShopItemInfo&& from) noexcept
    : ShopItemInfo() {
    *this = ::std::move(from);
  }

  inline ShopItemInfo& operator=(const ShopItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShopItemInfo& operator=(ShopItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShopItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShopItemInfo* internal_default_instance() {
    return reinterpret_cast<const ShopItemInfo*>(
               &_ShopItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ShopItemInfo& a, ShopItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ShopItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShopItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShopItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShopItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShopItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShopItemInfo& from) {
    ShopItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShopItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ShopItemInfo";
  }
  protected:
  explicit ShopItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kCanBuyCountFieldNumber = 2,
  };
  // .Protocol.ItemInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::Protocol::ItemInfo& item() const;
  PROTOBUF_NODISCARD ::Protocol::ItemInfo* release_item();
  ::Protocol::ItemInfo* mutable_item();
  void set_allocated_item(::Protocol::ItemInfo* item);
  private:
  const ::Protocol::ItemInfo& _internal_item() const;
  ::Protocol::ItemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::Protocol::ItemInfo* item);
  ::Protocol::ItemInfo* unsafe_arena_release_item();

  // uint32 can_buy_count = 2;
  void clear_can_buy_count();
  uint32_t can_buy_count() const;
  void set_can_buy_count(uint32_t value);
  private:
  uint32_t _internal_can_buy_count() const;
  void _internal_set_can_buy_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ShopItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ItemInfo* item_;
    uint32_t can_buy_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class ShopInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ShopInfo) */ {
 public:
  inline ShopInfo() : ShopInfo(nullptr) {}
  ~ShopInfo() override;
  explicit PROTOBUF_CONSTEXPR ShopInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShopInfo(const ShopInfo& from);
  ShopInfo(ShopInfo&& from) noexcept
    : ShopInfo() {
    *this = ::std::move(from);
  }

  inline ShopInfo& operator=(const ShopInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShopInfo& operator=(ShopInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShopInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShopInfo* internal_default_instance() {
    return reinterpret_cast<const ShopInfo*>(
               &_ShopInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ShopInfo& a, ShopInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ShopInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShopInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShopInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShopInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShopInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShopInfo& from) {
    ShopInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShopInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ShopInfo";
  }
  protected:
  explicit ShopInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kListCountFieldNumber = 1,
    kRefreshCountFieldNumber = 3,
  };
  // repeated .Protocol.ShopItemInfo list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::Protocol::ShopItemInfo* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ShopItemInfo >*
      mutable_list();
  private:
  const ::Protocol::ShopItemInfo& _internal_list(int index) const;
  ::Protocol::ShopItemInfo* _internal_add_list();
  public:
  const ::Protocol::ShopItemInfo& list(int index) const;
  ::Protocol::ShopItemInfo* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ShopItemInfo >&
      list() const;

  // uint32 list_count = 1;
  void clear_list_count();
  uint32_t list_count() const;
  void set_list_count(uint32_t value);
  private:
  uint32_t _internal_list_count() const;
  void _internal_set_list_count(uint32_t value);
  public:

  // uint32 refresh_count = 3;
  void clear_refresh_count();
  uint32_t refresh_count() const;
  void set_refresh_count(uint32_t value);
  private:
  uint32_t _internal_refresh_count() const;
  void _internal_set_refresh_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ShopInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ShopItemInfo > list_;
    uint32_t list_count_;
    uint32_t refresh_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class MailInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MailInfo) */ {
 public:
  inline MailInfo() : MailInfo(nullptr) {}
  ~MailInfo() override;
  explicit PROTOBUF_CONSTEXPR MailInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailInfo(const MailInfo& from);
  MailInfo(MailInfo&& from) noexcept
    : MailInfo() {
    *this = ::std::move(from);
  }

  inline MailInfo& operator=(const MailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailInfo& operator=(MailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailInfo* internal_default_instance() {
    return reinterpret_cast<const MailInfo*>(
               &_MailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MailInfo& a, MailInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MailInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailInfo& from) {
    MailInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MailInfo";
  }
  protected:
  explicit MailInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 3,
    kMainTitleFieldNumber = 1,
    kTextFieldNumber = 2,
    kIsReadFieldNumber = 4,
  };
  // repeated .Protocol.ItemInfo item = 3;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::Protocol::ItemInfo* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_item();
  private:
  const ::Protocol::ItemInfo& _internal_item(int index) const;
  ::Protocol::ItemInfo* _internal_add_item();
  public:
  const ::Protocol::ItemInfo& item(int index) const;
  ::Protocol::ItemInfo* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      item() const;

  // string main_title = 1;
  void clear_main_title();
  const std::string& main_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_main_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_main_title();
  PROTOBUF_NODISCARD std::string* release_main_title();
  void set_allocated_main_title(std::string* main_title);
  private:
  const std::string& _internal_main_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_main_title(const std::string& value);
  std::string* _internal_mutable_main_title();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // bool is_read = 4;
  void clear_is_read();
  bool is_read() const;
  void set_is_read(bool value);
  private:
  bool _internal_is_read() const;
  void _internal_set_is_read(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MailInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > item_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr main_title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    bool is_read_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class MailBoxInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MailBoxInfo) */ {
 public:
  inline MailBoxInfo() : MailBoxInfo(nullptr) {}
  ~MailBoxInfo() override;
  explicit PROTOBUF_CONSTEXPR MailBoxInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailBoxInfo(const MailBoxInfo& from);
  MailBoxInfo(MailBoxInfo&& from) noexcept
    : MailBoxInfo() {
    *this = ::std::move(from);
  }

  inline MailBoxInfo& operator=(const MailBoxInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailBoxInfo& operator=(MailBoxInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailBoxInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailBoxInfo* internal_default_instance() {
    return reinterpret_cast<const MailBoxInfo*>(
               &_MailBoxInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MailBoxInfo& a, MailBoxInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MailBoxInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailBoxInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailBoxInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailBoxInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailBoxInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailBoxInfo& from) {
    MailBoxInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailBoxInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MailBoxInfo";
  }
  protected:
  explicit MailBoxInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailFieldNumber = 1,
  };
  // repeated .Protocol.MailInfo mail = 1;
  int mail_size() const;
  private:
  int _internal_mail_size() const;
  public:
  void clear_mail();
  ::Protocol::MailInfo* mutable_mail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MailInfo >*
      mutable_mail();
  private:
  const ::Protocol::MailInfo& _internal_mail(int index) const;
  ::Protocol::MailInfo* _internal_add_mail();
  public:
  const ::Protocol::MailInfo& mail(int index) const;
  ::Protocol::MailInfo* add_mail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MailInfo >&
      mail() const;

  // @@protoc_insertion_point(class_scope:Protocol.MailBoxInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MailInfo > mail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Struct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PosInfo

// uint64 object_id = 1;
inline void PosInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t PosInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t PosInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.object_id)
  return _internal_object_id();
}
inline void PosInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void PosInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.object_id)
}

// float x = 2;
inline void PosInfo::clear_x() {
  _impl_.x_ = 0;
}
inline float PosInfo::_internal_x() const {
  return _impl_.x_;
}
inline float PosInfo::x() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.x)
  return _internal_x();
}
inline void PosInfo::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void PosInfo::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.x)
}

// float y = 3;
inline void PosInfo::clear_y() {
  _impl_.y_ = 0;
}
inline float PosInfo::_internal_y() const {
  return _impl_.y_;
}
inline float PosInfo::y() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.y)
  return _internal_y();
}
inline void PosInfo::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void PosInfo::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.y)
}

// float z = 4;
inline void PosInfo::clear_z() {
  _impl_.z_ = 0;
}
inline float PosInfo::_internal_z() const {
  return _impl_.z_;
}
inline float PosInfo::z() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.z)
  return _internal_z();
}
inline void PosInfo::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void PosInfo::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.z)
}

// float yaw = 5;
inline void PosInfo::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float PosInfo::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float PosInfo::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.yaw)
  return _internal_yaw();
}
inline void PosInfo::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void PosInfo::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.yaw)
}

// float pitch = 6;
inline void PosInfo::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float PosInfo::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float PosInfo::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.pitch)
  return _internal_pitch();
}
inline void PosInfo::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void PosInfo::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.pitch)
}

// .Protocol.MoveState state = 7;
inline void PosInfo::clear_state() {
  _impl_.state_ = 0;
}
inline ::Protocol::MoveState PosInfo::_internal_state() const {
  return static_cast< ::Protocol::MoveState >(_impl_.state_);
}
inline ::Protocol::MoveState PosInfo::state() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.state)
  return _internal_state();
}
inline void PosInfo::_internal_set_state(::Protocol::MoveState value) {
  
  _impl_.state_ = value;
}
inline void PosInfo::set_state(::Protocol::MoveState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.state)
}

// .Protocol.SkillState skill = 8;
inline void PosInfo::clear_skill() {
  _impl_.skill_ = 0;
}
inline ::Protocol::SkillState PosInfo::_internal_skill() const {
  return static_cast< ::Protocol::SkillState >(_impl_.skill_);
}
inline ::Protocol::SkillState PosInfo::skill() const {
  // @@protoc_insertion_point(field_get:Protocol.PosInfo.skill)
  return _internal_skill();
}
inline void PosInfo::_internal_set_skill(::Protocol::SkillState value) {
  
  _impl_.skill_ = value;
}
inline void PosInfo::set_skill(::Protocol::SkillState value) {
  _internal_set_skill(value);
  // @@protoc_insertion_point(field_set:Protocol.PosInfo.skill)
}

// -------------------------------------------------------------------

// HitInfo

// uint64 object_id = 1;
inline void HitInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t HitInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t HitInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.HitInfo.object_id)
  return _internal_object_id();
}
inline void HitInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void HitInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.HitInfo.object_id)
}

// uint64 causer_id = 2;
inline void HitInfo::clear_causer_id() {
  _impl_.causer_id_ = uint64_t{0u};
}
inline uint64_t HitInfo::_internal_causer_id() const {
  return _impl_.causer_id_;
}
inline uint64_t HitInfo::causer_id() const {
  // @@protoc_insertion_point(field_get:Protocol.HitInfo.causer_id)
  return _internal_causer_id();
}
inline void HitInfo::_internal_set_causer_id(uint64_t value) {
  
  _impl_.causer_id_ = value;
}
inline void HitInfo::set_causer_id(uint64_t value) {
  _internal_set_causer_id(value);
  // @@protoc_insertion_point(field_set:Protocol.HitInfo.causer_id)
}

// float damage = 3;
inline void HitInfo::clear_damage() {
  _impl_.damage_ = 0;
}
inline float HitInfo::_internal_damage() const {
  return _impl_.damage_;
}
inline float HitInfo::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.HitInfo.damage)
  return _internal_damage();
}
inline void HitInfo::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void HitInfo::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.HitInfo.damage)
}

// float hit_yaw = 4;
inline void HitInfo::clear_hit_yaw() {
  _impl_.hit_yaw_ = 0;
}
inline float HitInfo::_internal_hit_yaw() const {
  return _impl_.hit_yaw_;
}
inline float HitInfo::hit_yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.HitInfo.hit_yaw)
  return _internal_hit_yaw();
}
inline void HitInfo::_internal_set_hit_yaw(float value) {
  
  _impl_.hit_yaw_ = value;
}
inline void HitInfo::set_hit_yaw(float value) {
  _internal_set_hit_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.HitInfo.hit_yaw)
}

// float hit_back = 5;
inline void HitInfo::clear_hit_back() {
  _impl_.hit_back_ = 0;
}
inline float HitInfo::_internal_hit_back() const {
  return _impl_.hit_back_;
}
inline float HitInfo::hit_back() const {
  // @@protoc_insertion_point(field_get:Protocol.HitInfo.hit_back)
  return _internal_hit_back();
}
inline void HitInfo::_internal_set_hit_back(float value) {
  
  _impl_.hit_back_ = value;
}
inline void HitInfo::set_hit_back(float value) {
  _internal_set_hit_back(value);
  // @@protoc_insertion_point(field_set:Protocol.HitInfo.hit_back)
}

// float hit_stun = 6;
inline void HitInfo::clear_hit_stun() {
  _impl_.hit_stun_ = 0;
}
inline float HitInfo::_internal_hit_stun() const {
  return _impl_.hit_stun_;
}
inline float HitInfo::hit_stun() const {
  // @@protoc_insertion_point(field_get:Protocol.HitInfo.hit_stun)
  return _internal_hit_stun();
}
inline void HitInfo::_internal_set_hit_stun(float value) {
  
  _impl_.hit_stun_ = value;
}
inline void HitInfo::set_hit_stun(float value) {
  _internal_set_hit_stun(value);
  // @@protoc_insertion_point(field_set:Protocol.HitInfo.hit_stun)
}

// -------------------------------------------------------------------

// MeleeAttackInfo

// uint64 object_id = 1;
inline void MeleeAttackInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t MeleeAttackInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t MeleeAttackInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MeleeAttackInfo.object_id)
  return _internal_object_id();
}
inline void MeleeAttackInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void MeleeAttackInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MeleeAttackInfo.object_id)
}

// float damage = 2;
inline void MeleeAttackInfo::clear_damage() {
  _impl_.damage_ = 0;
}
inline float MeleeAttackInfo::_internal_damage() const {
  return _impl_.damage_;
}
inline float MeleeAttackInfo::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.MeleeAttackInfo.damage)
  return _internal_damage();
}
inline void MeleeAttackInfo::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void MeleeAttackInfo::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.MeleeAttackInfo.damage)
}

// float yaw = 3;
inline void MeleeAttackInfo::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float MeleeAttackInfo::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float MeleeAttackInfo::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.MeleeAttackInfo.yaw)
  return _internal_yaw();
}
inline void MeleeAttackInfo::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void MeleeAttackInfo::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.MeleeAttackInfo.yaw)
}

// -------------------------------------------------------------------

// ProjectileInfo

// uint64 causer_id = 1;
inline void ProjectileInfo::clear_causer_id() {
  _impl_.causer_id_ = uint64_t{0u};
}
inline uint64_t ProjectileInfo::_internal_causer_id() const {
  return _impl_.causer_id_;
}
inline uint64_t ProjectileInfo::causer_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ProjectileInfo.causer_id)
  return _internal_causer_id();
}
inline void ProjectileInfo::_internal_set_causer_id(uint64_t value) {
  
  _impl_.causer_id_ = value;
}
inline void ProjectileInfo::set_causer_id(uint64_t value) {
  _internal_set_causer_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ProjectileInfo.causer_id)
}

// float spawn_x = 2;
inline void ProjectileInfo::clear_spawn_x() {
  _impl_.spawn_x_ = 0;
}
inline float ProjectileInfo::_internal_spawn_x() const {
  return _impl_.spawn_x_;
}
inline float ProjectileInfo::spawn_x() const {
  // @@protoc_insertion_point(field_get:Protocol.ProjectileInfo.spawn_x)
  return _internal_spawn_x();
}
inline void ProjectileInfo::_internal_set_spawn_x(float value) {
  
  _impl_.spawn_x_ = value;
}
inline void ProjectileInfo::set_spawn_x(float value) {
  _internal_set_spawn_x(value);
  // @@protoc_insertion_point(field_set:Protocol.ProjectileInfo.spawn_x)
}

// float spawn_y = 3;
inline void ProjectileInfo::clear_spawn_y() {
  _impl_.spawn_y_ = 0;
}
inline float ProjectileInfo::_internal_spawn_y() const {
  return _impl_.spawn_y_;
}
inline float ProjectileInfo::spawn_y() const {
  // @@protoc_insertion_point(field_get:Protocol.ProjectileInfo.spawn_y)
  return _internal_spawn_y();
}
inline void ProjectileInfo::_internal_set_spawn_y(float value) {
  
  _impl_.spawn_y_ = value;
}
inline void ProjectileInfo::set_spawn_y(float value) {
  _internal_set_spawn_y(value);
  // @@protoc_insertion_point(field_set:Protocol.ProjectileInfo.spawn_y)
}

// float spawn_z = 4;
inline void ProjectileInfo::clear_spawn_z() {
  _impl_.spawn_z_ = 0;
}
inline float ProjectileInfo::_internal_spawn_z() const {
  return _impl_.spawn_z_;
}
inline float ProjectileInfo::spawn_z() const {
  // @@protoc_insertion_point(field_get:Protocol.ProjectileInfo.spawn_z)
  return _internal_spawn_z();
}
inline void ProjectileInfo::_internal_set_spawn_z(float value) {
  
  _impl_.spawn_z_ = value;
}
inline void ProjectileInfo::set_spawn_z(float value) {
  _internal_set_spawn_z(value);
  // @@protoc_insertion_point(field_set:Protocol.ProjectileInfo.spawn_z)
}

// float damage = 5;
inline void ProjectileInfo::clear_damage() {
  _impl_.damage_ = 0;
}
inline float ProjectileInfo::_internal_damage() const {
  return _impl_.damage_;
}
inline float ProjectileInfo::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.ProjectileInfo.damage)
  return _internal_damage();
}
inline void ProjectileInfo::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void ProjectileInfo::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.ProjectileInfo.damage)
}

// float shoot_yaw = 6;
inline void ProjectileInfo::clear_shoot_yaw() {
  _impl_.shoot_yaw_ = 0;
}
inline float ProjectileInfo::_internal_shoot_yaw() const {
  return _impl_.shoot_yaw_;
}
inline float ProjectileInfo::shoot_yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.ProjectileInfo.shoot_yaw)
  return _internal_shoot_yaw();
}
inline void ProjectileInfo::_internal_set_shoot_yaw(float value) {
  
  _impl_.shoot_yaw_ = value;
}
inline void ProjectileInfo::set_shoot_yaw(float value) {
  _internal_set_shoot_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.ProjectileInfo.shoot_yaw)
}

// -------------------------------------------------------------------

// StatusInfo

// uint64 object_id = 1;
inline void StatusInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t StatusInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t StatusInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.object_id)
  return _internal_object_id();
}
inline void StatusInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void StatusInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.object_id)
}

// float maxhp = 2;
inline void StatusInfo::clear_maxhp() {
  _impl_.maxhp_ = 0;
}
inline float StatusInfo::_internal_maxhp() const {
  return _impl_.maxhp_;
}
inline float StatusInfo::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.maxhp)
  return _internal_maxhp();
}
inline void StatusInfo::_internal_set_maxhp(float value) {
  
  _impl_.maxhp_ = value;
}
inline void StatusInfo::set_maxhp(float value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.maxhp)
}

// float hp = 3;
inline void StatusInfo::clear_hp() {
  _impl_.hp_ = 0;
}
inline float StatusInfo::_internal_hp() const {
  return _impl_.hp_;
}
inline float StatusInfo::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.hp)
  return _internal_hp();
}
inline void StatusInfo::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void StatusInfo::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.hp)
}

// float maxmp = 4;
inline void StatusInfo::clear_maxmp() {
  _impl_.maxmp_ = 0;
}
inline float StatusInfo::_internal_maxmp() const {
  return _impl_.maxmp_;
}
inline float StatusInfo::maxmp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.maxmp)
  return _internal_maxmp();
}
inline void StatusInfo::_internal_set_maxmp(float value) {
  
  _impl_.maxmp_ = value;
}
inline void StatusInfo::set_maxmp(float value) {
  _internal_set_maxmp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.maxmp)
}

// float mp = 5;
inline void StatusInfo::clear_mp() {
  _impl_.mp_ = 0;
}
inline float StatusInfo::_internal_mp() const {
  return _impl_.mp_;
}
inline float StatusInfo::mp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.mp)
  return _internal_mp();
}
inline void StatusInfo::_internal_set_mp(float value) {
  
  _impl_.mp_ = value;
}
inline void StatusInfo::set_mp(float value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.mp)
}

// float atk = 6;
inline void StatusInfo::clear_atk() {
  _impl_.atk_ = 0;
}
inline float StatusInfo::_internal_atk() const {
  return _impl_.atk_;
}
inline float StatusInfo::atk() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.atk)
  return _internal_atk();
}
inline void StatusInfo::_internal_set_atk(float value) {
  
  _impl_.atk_ = value;
}
inline void StatusInfo::set_atk(float value) {
  _internal_set_atk(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.atk)
}

// float def = 7;
inline void StatusInfo::clear_def() {
  _impl_.def_ = 0;
}
inline float StatusInfo::_internal_def() const {
  return _impl_.def_;
}
inline float StatusInfo::def() const {
  // @@protoc_insertion_point(field_get:Protocol.StatusInfo.def)
  return _internal_def();
}
inline void StatusInfo::_internal_set_def(float value) {
  
  _impl_.def_ = value;
}
inline void StatusInfo::set_def(float value) {
  _internal_set_def(value);
  // @@protoc_insertion_point(field_set:Protocol.StatusInfo.def)
}

// -------------------------------------------------------------------

// ClassInfo

// uint64 object_id = 1;
inline void ClassInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t ClassInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t ClassInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ClassInfo.object_id)
  return _internal_object_id();
}
inline void ClassInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void ClassInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ClassInfo.object_id)
}

// .Protocol.PlayerType player_type = 2;
inline void ClassInfo::clear_player_type() {
  _impl_.player_type_ = 0;
}
inline ::Protocol::PlayerType ClassInfo::_internal_player_type() const {
  return static_cast< ::Protocol::PlayerType >(_impl_.player_type_);
}
inline ::Protocol::PlayerType ClassInfo::player_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ClassInfo.player_type)
  return _internal_player_type();
}
inline void ClassInfo::_internal_set_player_type(::Protocol::PlayerType value) {
  
  _impl_.player_type_ = value;
}
inline void ClassInfo::set_player_type(::Protocol::PlayerType value) {
  _internal_set_player_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ClassInfo.player_type)
}

// -------------------------------------------------------------------

// ObjectInfo

// uint64 object_id = 1;
inline void ObjectInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t ObjectInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t ObjectInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.object_id)
  return _internal_object_id();
}
inline void ObjectInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void ObjectInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ObjectInfo.object_id)
}

// .Protocol.ObjectType object_type = 2;
inline void ObjectInfo::clear_object_type() {
  _impl_.object_type_ = 0;
}
inline ::Protocol::ObjectType ObjectInfo::_internal_object_type() const {
  return static_cast< ::Protocol::ObjectType >(_impl_.object_type_);
}
inline ::Protocol::ObjectType ObjectInfo::object_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.object_type)
  return _internal_object_type();
}
inline void ObjectInfo::_internal_set_object_type(::Protocol::ObjectType value) {
  
  _impl_.object_type_ = value;
}
inline void ObjectInfo::set_object_type(::Protocol::ObjectType value) {
  _internal_set_object_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ObjectInfo.object_type)
}

// .Protocol.ClassInfo player_type = 3;
inline bool ObjectInfo::_internal_has_player_type() const {
  return this != internal_default_instance() && _impl_.player_type_ != nullptr;
}
inline bool ObjectInfo::has_player_type() const {
  return _internal_has_player_type();
}
inline void ObjectInfo::clear_player_type() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_type_ != nullptr) {
    delete _impl_.player_type_;
  }
  _impl_.player_type_ = nullptr;
}
inline const ::Protocol::ClassInfo& ObjectInfo::_internal_player_type() const {
  const ::Protocol::ClassInfo* p = _impl_.player_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ClassInfo&>(
      ::Protocol::_ClassInfo_default_instance_);
}
inline const ::Protocol::ClassInfo& ObjectInfo::player_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.player_type)
  return _internal_player_type();
}
inline void ObjectInfo::unsafe_arena_set_allocated_player_type(
    ::Protocol::ClassInfo* player_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_type_);
  }
  _impl_.player_type_ = player_type;
  if (player_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.player_type)
}
inline ::Protocol::ClassInfo* ObjectInfo::release_player_type() {
  
  ::Protocol::ClassInfo* temp = _impl_.player_type_;
  _impl_.player_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ClassInfo* ObjectInfo::unsafe_arena_release_player_type() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.player_type)
  
  ::Protocol::ClassInfo* temp = _impl_.player_type_;
  _impl_.player_type_ = nullptr;
  return temp;
}
inline ::Protocol::ClassInfo* ObjectInfo::_internal_mutable_player_type() {
  
  if (_impl_.player_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ClassInfo>(GetArenaForAllocation());
    _impl_.player_type_ = p;
  }
  return _impl_.player_type_;
}
inline ::Protocol::ClassInfo* ObjectInfo::mutable_player_type() {
  ::Protocol::ClassInfo* _msg = _internal_mutable_player_type();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.player_type)
  return _msg;
}
inline void ObjectInfo::set_allocated_player_type(::Protocol::ClassInfo* player_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_type_;
  }
  if (player_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_type);
    if (message_arena != submessage_arena) {
      player_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_type, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_type_ = player_type;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.player_type)
}

// .Protocol.CreatureType creature_type = 4;
inline void ObjectInfo::clear_creature_type() {
  _impl_.creature_type_ = 0;
}
inline ::Protocol::CreatureType ObjectInfo::_internal_creature_type() const {
  return static_cast< ::Protocol::CreatureType >(_impl_.creature_type_);
}
inline ::Protocol::CreatureType ObjectInfo::creature_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.creature_type)
  return _internal_creature_type();
}
inline void ObjectInfo::_internal_set_creature_type(::Protocol::CreatureType value) {
  
  _impl_.creature_type_ = value;
}
inline void ObjectInfo::set_creature_type(::Protocol::CreatureType value) {
  _internal_set_creature_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ObjectInfo.creature_type)
}

// .Protocol.PosInfo pos_info = 5;
inline bool ObjectInfo::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool ObjectInfo::has_pos_info() const {
  return _internal_has_pos_info();
}
inline void ObjectInfo::clear_pos_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_info_ != nullptr) {
    delete _impl_.pos_info_;
  }
  _impl_.pos_info_ = nullptr;
}
inline const ::Protocol::PosInfo& ObjectInfo::_internal_pos_info() const {
  const ::Protocol::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& ObjectInfo::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.pos_info)
  return _internal_pos_info();
}
inline void ObjectInfo::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PosInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.pos_info)
}
inline ::Protocol::PosInfo* ObjectInfo::release_pos_info() {
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* ObjectInfo::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.pos_info)
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* ObjectInfo::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PosInfo* ObjectInfo::mutable_pos_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.pos_info)
  return _msg;
}
inline void ObjectInfo::set_allocated_pos_info(::Protocol::PosInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_info_;
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos_info);
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.pos_info)
}

// .Protocol.StatusInfo status_info = 6;
inline bool ObjectInfo::_internal_has_status_info() const {
  return this != internal_default_instance() && _impl_.status_info_ != nullptr;
}
inline bool ObjectInfo::has_status_info() const {
  return _internal_has_status_info();
}
inline void ObjectInfo::clear_status_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_info_ != nullptr) {
    delete _impl_.status_info_;
  }
  _impl_.status_info_ = nullptr;
}
inline const ::Protocol::StatusInfo& ObjectInfo::_internal_status_info() const {
  const ::Protocol::StatusInfo* p = _impl_.status_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatusInfo&>(
      ::Protocol::_StatusInfo_default_instance_);
}
inline const ::Protocol::StatusInfo& ObjectInfo::status_info() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.status_info)
  return _internal_status_info();
}
inline void ObjectInfo::unsafe_arena_set_allocated_status_info(
    ::Protocol::StatusInfo* status_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_info_);
  }
  _impl_.status_info_ = status_info;
  if (status_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.status_info)
}
inline ::Protocol::StatusInfo* ObjectInfo::release_status_info() {
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatusInfo* ObjectInfo::unsafe_arena_release_status_info() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.status_info)
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
  return temp;
}
inline ::Protocol::StatusInfo* ObjectInfo::_internal_mutable_status_info() {
  
  if (_impl_.status_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatusInfo>(GetArenaForAllocation());
    _impl_.status_info_ = p;
  }
  return _impl_.status_info_;
}
inline ::Protocol::StatusInfo* ObjectInfo::mutable_status_info() {
  ::Protocol::StatusInfo* _msg = _internal_mutable_status_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.status_info)
  return _msg;
}
inline void ObjectInfo::set_allocated_status_info(::Protocol::StatusInfo* status_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_info_;
  }
  if (status_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_info);
    if (message_arena != submessage_arena) {
      status_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_info_ = status_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.status_info)
}

// .Protocol.AbilityInputInfo input_info = 7;
inline bool ObjectInfo::_internal_has_input_info() const {
  return this != internal_default_instance() && _impl_.input_info_ != nullptr;
}
inline bool ObjectInfo::has_input_info() const {
  return _internal_has_input_info();
}
inline void ObjectInfo::clear_input_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_info_ != nullptr) {
    delete _impl_.input_info_;
  }
  _impl_.input_info_ = nullptr;
}
inline const ::Protocol::AbilityInputInfo& ObjectInfo::_internal_input_info() const {
  const ::Protocol::AbilityInputInfo* p = _impl_.input_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::AbilityInputInfo&>(
      ::Protocol::_AbilityInputInfo_default_instance_);
}
inline const ::Protocol::AbilityInputInfo& ObjectInfo::input_info() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.input_info)
  return _internal_input_info();
}
inline void ObjectInfo::unsafe_arena_set_allocated_input_info(
    ::Protocol::AbilityInputInfo* input_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_info_);
  }
  _impl_.input_info_ = input_info;
  if (input_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.input_info)
}
inline ::Protocol::AbilityInputInfo* ObjectInfo::release_input_info() {
  
  ::Protocol::AbilityInputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::AbilityInputInfo* ObjectInfo::unsafe_arena_release_input_info() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.input_info)
  
  ::Protocol::AbilityInputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
  return temp;
}
inline ::Protocol::AbilityInputInfo* ObjectInfo::_internal_mutable_input_info() {
  
  if (_impl_.input_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::AbilityInputInfo>(GetArenaForAllocation());
    _impl_.input_info_ = p;
  }
  return _impl_.input_info_;
}
inline ::Protocol::AbilityInputInfo* ObjectInfo::mutable_input_info() {
  ::Protocol::AbilityInputInfo* _msg = _internal_mutable_input_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.input_info)
  return _msg;
}
inline void ObjectInfo::set_allocated_input_info(::Protocol::AbilityInputInfo* input_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_info_;
  }
  if (input_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_info);
    if (message_arena != submessage_arena) {
      input_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_info_ = input_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.input_info)
}

// .Protocol.LevelPointInfo level_info = 8;
inline bool ObjectInfo::_internal_has_level_info() const {
  return this != internal_default_instance() && _impl_.level_info_ != nullptr;
}
inline bool ObjectInfo::has_level_info() const {
  return _internal_has_level_info();
}
inline void ObjectInfo::clear_level_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.level_info_ != nullptr) {
    delete _impl_.level_info_;
  }
  _impl_.level_info_ = nullptr;
}
inline const ::Protocol::LevelPointInfo& ObjectInfo::_internal_level_info() const {
  const ::Protocol::LevelPointInfo* p = _impl_.level_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::LevelPointInfo&>(
      ::Protocol::_LevelPointInfo_default_instance_);
}
inline const ::Protocol::LevelPointInfo& ObjectInfo::level_info() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.level_info)
  return _internal_level_info();
}
inline void ObjectInfo::unsafe_arena_set_allocated_level_info(
    ::Protocol::LevelPointInfo* level_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.level_info_);
  }
  _impl_.level_info_ = level_info;
  if (level_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.level_info)
}
inline ::Protocol::LevelPointInfo* ObjectInfo::release_level_info() {
  
  ::Protocol::LevelPointInfo* temp = _impl_.level_info_;
  _impl_.level_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::LevelPointInfo* ObjectInfo::unsafe_arena_release_level_info() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.level_info)
  
  ::Protocol::LevelPointInfo* temp = _impl_.level_info_;
  _impl_.level_info_ = nullptr;
  return temp;
}
inline ::Protocol::LevelPointInfo* ObjectInfo::_internal_mutable_level_info() {
  
  if (_impl_.level_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::LevelPointInfo>(GetArenaForAllocation());
    _impl_.level_info_ = p;
  }
  return _impl_.level_info_;
}
inline ::Protocol::LevelPointInfo* ObjectInfo::mutable_level_info() {
  ::Protocol::LevelPointInfo* _msg = _internal_mutable_level_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.level_info)
  return _msg;
}
inline void ObjectInfo::set_allocated_level_info(::Protocol::LevelPointInfo* level_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.level_info_;
  }
  if (level_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(level_info);
    if (message_arena != submessage_arena) {
      level_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, level_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.level_info_ = level_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.level_info)
}

// -------------------------------------------------------------------

// CreatureInfo

// uint64 object_id = 1;
inline void CreatureInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t CreatureInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t CreatureInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.object_id)
  return _internal_object_id();
}
inline void CreatureInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void CreatureInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.CreatureInfo.object_id)
}

// uint32 level = 2;
inline void CreatureInfo::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t CreatureInfo::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t CreatureInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.level)
  return _internal_level();
}
inline void CreatureInfo::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void CreatureInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.CreatureInfo.level)
}

// .Protocol.PosInfo pos_info = 3;
inline bool CreatureInfo::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool CreatureInfo::has_pos_info() const {
  return _internal_has_pos_info();
}
inline void CreatureInfo::clear_pos_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_info_ != nullptr) {
    delete _impl_.pos_info_;
  }
  _impl_.pos_info_ = nullptr;
}
inline const ::Protocol::PosInfo& CreatureInfo::_internal_pos_info() const {
  const ::Protocol::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& CreatureInfo::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.pos_info)
  return _internal_pos_info();
}
inline void CreatureInfo::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PosInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.CreatureInfo.pos_info)
}
inline ::Protocol::PosInfo* CreatureInfo::release_pos_info() {
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* CreatureInfo::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.CreatureInfo.pos_info)
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* CreatureInfo::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PosInfo* CreatureInfo::mutable_pos_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.CreatureInfo.pos_info)
  return _msg;
}
inline void CreatureInfo::set_allocated_pos_info(::Protocol::PosInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_info_;
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos_info);
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.CreatureInfo.pos_info)
}

// .Protocol.StatusInfo status_info = 4;
inline bool CreatureInfo::_internal_has_status_info() const {
  return this != internal_default_instance() && _impl_.status_info_ != nullptr;
}
inline bool CreatureInfo::has_status_info() const {
  return _internal_has_status_info();
}
inline void CreatureInfo::clear_status_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_info_ != nullptr) {
    delete _impl_.status_info_;
  }
  _impl_.status_info_ = nullptr;
}
inline const ::Protocol::StatusInfo& CreatureInfo::_internal_status_info() const {
  const ::Protocol::StatusInfo* p = _impl_.status_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatusInfo&>(
      ::Protocol::_StatusInfo_default_instance_);
}
inline const ::Protocol::StatusInfo& CreatureInfo::status_info() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.status_info)
  return _internal_status_info();
}
inline void CreatureInfo::unsafe_arena_set_allocated_status_info(
    ::Protocol::StatusInfo* status_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_info_);
  }
  _impl_.status_info_ = status_info;
  if (status_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.CreatureInfo.status_info)
}
inline ::Protocol::StatusInfo* CreatureInfo::release_status_info() {
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatusInfo* CreatureInfo::unsafe_arena_release_status_info() {
  // @@protoc_insertion_point(field_release:Protocol.CreatureInfo.status_info)
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
  return temp;
}
inline ::Protocol::StatusInfo* CreatureInfo::_internal_mutable_status_info() {
  
  if (_impl_.status_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatusInfo>(GetArenaForAllocation());
    _impl_.status_info_ = p;
  }
  return _impl_.status_info_;
}
inline ::Protocol::StatusInfo* CreatureInfo::mutable_status_info() {
  ::Protocol::StatusInfo* _msg = _internal_mutable_status_info();
  // @@protoc_insertion_point(field_mutable:Protocol.CreatureInfo.status_info)
  return _msg;
}
inline void CreatureInfo::set_allocated_status_info(::Protocol::StatusInfo* status_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_info_;
  }
  if (status_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_info);
    if (message_arena != submessage_arena) {
      status_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_info_ = status_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.CreatureInfo.status_info)
}

// .Protocol.CreatureType creature_type = 5;
inline void CreatureInfo::clear_creature_type() {
  _impl_.creature_type_ = 0;
}
inline ::Protocol::CreatureType CreatureInfo::_internal_creature_type() const {
  return static_cast< ::Protocol::CreatureType >(_impl_.creature_type_);
}
inline ::Protocol::CreatureType CreatureInfo::creature_type() const {
  // @@protoc_insertion_point(field_get:Protocol.CreatureInfo.creature_type)
  return _internal_creature_type();
}
inline void CreatureInfo::_internal_set_creature_type(::Protocol::CreatureType value) {
  
  _impl_.creature_type_ = value;
}
inline void CreatureInfo::set_creature_type(::Protocol::CreatureType value) {
  _internal_set_creature_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CreatureInfo.creature_type)
}

// -------------------------------------------------------------------

// PlayerInfo

// uint64 object_id = 1;
inline void PlayerInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t PlayerInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t PlayerInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.object_id)
  return _internal_object_id();
}
inline void PlayerInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void PlayerInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.object_id)
}

// uint32 level = 2;
inline void PlayerInfo::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t PlayerInfo::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t PlayerInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.level)
  return _internal_level();
}
inline void PlayerInfo::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void PlayerInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.level)
}

// .Protocol.ClassInfo player_type = 3;
inline bool PlayerInfo::_internal_has_player_type() const {
  return this != internal_default_instance() && _impl_.player_type_ != nullptr;
}
inline bool PlayerInfo::has_player_type() const {
  return _internal_has_player_type();
}
inline void PlayerInfo::clear_player_type() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_type_ != nullptr) {
    delete _impl_.player_type_;
  }
  _impl_.player_type_ = nullptr;
}
inline const ::Protocol::ClassInfo& PlayerInfo::_internal_player_type() const {
  const ::Protocol::ClassInfo* p = _impl_.player_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ClassInfo&>(
      ::Protocol::_ClassInfo_default_instance_);
}
inline const ::Protocol::ClassInfo& PlayerInfo::player_type() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.player_type)
  return _internal_player_type();
}
inline void PlayerInfo::unsafe_arena_set_allocated_player_type(
    ::Protocol::ClassInfo* player_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_type_);
  }
  _impl_.player_type_ = player_type;
  if (player_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.player_type)
}
inline ::Protocol::ClassInfo* PlayerInfo::release_player_type() {
  
  ::Protocol::ClassInfo* temp = _impl_.player_type_;
  _impl_.player_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ClassInfo* PlayerInfo::unsafe_arena_release_player_type() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.player_type)
  
  ::Protocol::ClassInfo* temp = _impl_.player_type_;
  _impl_.player_type_ = nullptr;
  return temp;
}
inline ::Protocol::ClassInfo* PlayerInfo::_internal_mutable_player_type() {
  
  if (_impl_.player_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ClassInfo>(GetArenaForAllocation());
    _impl_.player_type_ = p;
  }
  return _impl_.player_type_;
}
inline ::Protocol::ClassInfo* PlayerInfo::mutable_player_type() {
  ::Protocol::ClassInfo* _msg = _internal_mutable_player_type();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.player_type)
  return _msg;
}
inline void PlayerInfo::set_allocated_player_type(::Protocol::ClassInfo* player_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_type_;
  }
  if (player_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_type);
    if (message_arena != submessage_arena) {
      player_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_type, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_type_ = player_type;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.player_type)
}

// .Protocol.PosInfo pos_info = 4;
inline bool PlayerInfo::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool PlayerInfo::has_pos_info() const {
  return _internal_has_pos_info();
}
inline void PlayerInfo::clear_pos_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_info_ != nullptr) {
    delete _impl_.pos_info_;
  }
  _impl_.pos_info_ = nullptr;
}
inline const ::Protocol::PosInfo& PlayerInfo::_internal_pos_info() const {
  const ::Protocol::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& PlayerInfo::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.pos_info)
  return _internal_pos_info();
}
inline void PlayerInfo::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PosInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.pos_info)
}
inline ::Protocol::PosInfo* PlayerInfo::release_pos_info() {
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* PlayerInfo::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.pos_info)
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* PlayerInfo::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PosInfo* PlayerInfo::mutable_pos_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.pos_info)
  return _msg;
}
inline void PlayerInfo::set_allocated_pos_info(::Protocol::PosInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_info_;
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos_info);
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.pos_info)
}

// .Protocol.StatusInfo status_info = 5;
inline bool PlayerInfo::_internal_has_status_info() const {
  return this != internal_default_instance() && _impl_.status_info_ != nullptr;
}
inline bool PlayerInfo::has_status_info() const {
  return _internal_has_status_info();
}
inline void PlayerInfo::clear_status_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_info_ != nullptr) {
    delete _impl_.status_info_;
  }
  _impl_.status_info_ = nullptr;
}
inline const ::Protocol::StatusInfo& PlayerInfo::_internal_status_info() const {
  const ::Protocol::StatusInfo* p = _impl_.status_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatusInfo&>(
      ::Protocol::_StatusInfo_default_instance_);
}
inline const ::Protocol::StatusInfo& PlayerInfo::status_info() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.status_info)
  return _internal_status_info();
}
inline void PlayerInfo::unsafe_arena_set_allocated_status_info(
    ::Protocol::StatusInfo* status_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_info_);
  }
  _impl_.status_info_ = status_info;
  if (status_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.status_info)
}
inline ::Protocol::StatusInfo* PlayerInfo::release_status_info() {
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatusInfo* PlayerInfo::unsafe_arena_release_status_info() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.status_info)
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
  return temp;
}
inline ::Protocol::StatusInfo* PlayerInfo::_internal_mutable_status_info() {
  
  if (_impl_.status_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatusInfo>(GetArenaForAllocation());
    _impl_.status_info_ = p;
  }
  return _impl_.status_info_;
}
inline ::Protocol::StatusInfo* PlayerInfo::mutable_status_info() {
  ::Protocol::StatusInfo* _msg = _internal_mutable_status_info();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.status_info)
  return _msg;
}
inline void PlayerInfo::set_allocated_status_info(::Protocol::StatusInfo* status_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_info_;
  }
  if (status_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_info);
    if (message_arena != submessage_arena) {
      status_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_info_ = status_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.status_info)
}

// .Protocol.LevelPointInfo level_info = 6;
inline bool PlayerInfo::_internal_has_level_info() const {
  return this != internal_default_instance() && _impl_.level_info_ != nullptr;
}
inline bool PlayerInfo::has_level_info() const {
  return _internal_has_level_info();
}
inline void PlayerInfo::clear_level_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.level_info_ != nullptr) {
    delete _impl_.level_info_;
  }
  _impl_.level_info_ = nullptr;
}
inline const ::Protocol::LevelPointInfo& PlayerInfo::_internal_level_info() const {
  const ::Protocol::LevelPointInfo* p = _impl_.level_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::LevelPointInfo&>(
      ::Protocol::_LevelPointInfo_default_instance_);
}
inline const ::Protocol::LevelPointInfo& PlayerInfo::level_info() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.level_info)
  return _internal_level_info();
}
inline void PlayerInfo::unsafe_arena_set_allocated_level_info(
    ::Protocol::LevelPointInfo* level_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.level_info_);
  }
  _impl_.level_info_ = level_info;
  if (level_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.level_info)
}
inline ::Protocol::LevelPointInfo* PlayerInfo::release_level_info() {
  
  ::Protocol::LevelPointInfo* temp = _impl_.level_info_;
  _impl_.level_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::LevelPointInfo* PlayerInfo::unsafe_arena_release_level_info() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.level_info)
  
  ::Protocol::LevelPointInfo* temp = _impl_.level_info_;
  _impl_.level_info_ = nullptr;
  return temp;
}
inline ::Protocol::LevelPointInfo* PlayerInfo::_internal_mutable_level_info() {
  
  if (_impl_.level_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::LevelPointInfo>(GetArenaForAllocation());
    _impl_.level_info_ = p;
  }
  return _impl_.level_info_;
}
inline ::Protocol::LevelPointInfo* PlayerInfo::mutable_level_info() {
  ::Protocol::LevelPointInfo* _msg = _internal_mutable_level_info();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.level_info)
  return _msg;
}
inline void PlayerInfo::set_allocated_level_info(::Protocol::LevelPointInfo* level_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.level_info_;
  }
  if (level_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(level_info);
    if (message_arena != submessage_arena) {
      level_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, level_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.level_info_ = level_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.level_info)
}

// .Protocol.AbilityInputInfo input_info = 7;
inline bool PlayerInfo::_internal_has_input_info() const {
  return this != internal_default_instance() && _impl_.input_info_ != nullptr;
}
inline bool PlayerInfo::has_input_info() const {
  return _internal_has_input_info();
}
inline void PlayerInfo::clear_input_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_info_ != nullptr) {
    delete _impl_.input_info_;
  }
  _impl_.input_info_ = nullptr;
}
inline const ::Protocol::AbilityInputInfo& PlayerInfo::_internal_input_info() const {
  const ::Protocol::AbilityInputInfo* p = _impl_.input_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::AbilityInputInfo&>(
      ::Protocol::_AbilityInputInfo_default_instance_);
}
inline const ::Protocol::AbilityInputInfo& PlayerInfo::input_info() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.input_info)
  return _internal_input_info();
}
inline void PlayerInfo::unsafe_arena_set_allocated_input_info(
    ::Protocol::AbilityInputInfo* input_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_info_);
  }
  _impl_.input_info_ = input_info;
  if (input_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.input_info)
}
inline ::Protocol::AbilityInputInfo* PlayerInfo::release_input_info() {
  
  ::Protocol::AbilityInputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::AbilityInputInfo* PlayerInfo::unsafe_arena_release_input_info() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.input_info)
  
  ::Protocol::AbilityInputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
  return temp;
}
inline ::Protocol::AbilityInputInfo* PlayerInfo::_internal_mutable_input_info() {
  
  if (_impl_.input_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::AbilityInputInfo>(GetArenaForAllocation());
    _impl_.input_info_ = p;
  }
  return _impl_.input_info_;
}
inline ::Protocol::AbilityInputInfo* PlayerInfo::mutable_input_info() {
  ::Protocol::AbilityInputInfo* _msg = _internal_mutable_input_info();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.input_info)
  return _msg;
}
inline void PlayerInfo::set_allocated_input_info(::Protocol::AbilityInputInfo* input_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_info_;
  }
  if (input_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_info);
    if (message_arena != submessage_arena) {
      input_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_info_ = input_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.input_info)
}

// .Protocol.InventoryList inventory_list = 8;
inline bool PlayerInfo::_internal_has_inventory_list() const {
  return this != internal_default_instance() && _impl_.inventory_list_ != nullptr;
}
inline bool PlayerInfo::has_inventory_list() const {
  return _internal_has_inventory_list();
}
inline void PlayerInfo::clear_inventory_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.inventory_list_ != nullptr) {
    delete _impl_.inventory_list_;
  }
  _impl_.inventory_list_ = nullptr;
}
inline const ::Protocol::InventoryList& PlayerInfo::_internal_inventory_list() const {
  const ::Protocol::InventoryList* p = _impl_.inventory_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::InventoryList&>(
      ::Protocol::_InventoryList_default_instance_);
}
inline const ::Protocol::InventoryList& PlayerInfo::inventory_list() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.inventory_list)
  return _internal_inventory_list();
}
inline void PlayerInfo::unsafe_arena_set_allocated_inventory_list(
    ::Protocol::InventoryList* inventory_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_list_);
  }
  _impl_.inventory_list_ = inventory_list;
  if (inventory_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.inventory_list)
}
inline ::Protocol::InventoryList* PlayerInfo::release_inventory_list() {
  
  ::Protocol::InventoryList* temp = _impl_.inventory_list_;
  _impl_.inventory_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::InventoryList* PlayerInfo::unsafe_arena_release_inventory_list() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.inventory_list)
  
  ::Protocol::InventoryList* temp = _impl_.inventory_list_;
  _impl_.inventory_list_ = nullptr;
  return temp;
}
inline ::Protocol::InventoryList* PlayerInfo::_internal_mutable_inventory_list() {
  
  if (_impl_.inventory_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::InventoryList>(GetArenaForAllocation());
    _impl_.inventory_list_ = p;
  }
  return _impl_.inventory_list_;
}
inline ::Protocol::InventoryList* PlayerInfo::mutable_inventory_list() {
  ::Protocol::InventoryList* _msg = _internal_mutable_inventory_list();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.inventory_list)
  return _msg;
}
inline void PlayerInfo::set_allocated_inventory_list(::Protocol::InventoryList* inventory_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inventory_list_;
  }
  if (inventory_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inventory_list);
    if (message_arena != submessage_arena) {
      inventory_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inventory_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inventory_list_ = inventory_list;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.inventory_list)
}

// .Protocol.EquipmentList equipment_list = 9;
inline bool PlayerInfo::_internal_has_equipment_list() const {
  return this != internal_default_instance() && _impl_.equipment_list_ != nullptr;
}
inline bool PlayerInfo::has_equipment_list() const {
  return _internal_has_equipment_list();
}
inline void PlayerInfo::clear_equipment_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.equipment_list_ != nullptr) {
    delete _impl_.equipment_list_;
  }
  _impl_.equipment_list_ = nullptr;
}
inline const ::Protocol::EquipmentList& PlayerInfo::_internal_equipment_list() const {
  const ::Protocol::EquipmentList* p = _impl_.equipment_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::EquipmentList&>(
      ::Protocol::_EquipmentList_default_instance_);
}
inline const ::Protocol::EquipmentList& PlayerInfo::equipment_list() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.equipment_list)
  return _internal_equipment_list();
}
inline void PlayerInfo::unsafe_arena_set_allocated_equipment_list(
    ::Protocol::EquipmentList* equipment_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equipment_list_);
  }
  _impl_.equipment_list_ = equipment_list;
  if (equipment_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.equipment_list)
}
inline ::Protocol::EquipmentList* PlayerInfo::release_equipment_list() {
  
  ::Protocol::EquipmentList* temp = _impl_.equipment_list_;
  _impl_.equipment_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::EquipmentList* PlayerInfo::unsafe_arena_release_equipment_list() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.equipment_list)
  
  ::Protocol::EquipmentList* temp = _impl_.equipment_list_;
  _impl_.equipment_list_ = nullptr;
  return temp;
}
inline ::Protocol::EquipmentList* PlayerInfo::_internal_mutable_equipment_list() {
  
  if (_impl_.equipment_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::EquipmentList>(GetArenaForAllocation());
    _impl_.equipment_list_ = p;
  }
  return _impl_.equipment_list_;
}
inline ::Protocol::EquipmentList* PlayerInfo::mutable_equipment_list() {
  ::Protocol::EquipmentList* _msg = _internal_mutable_equipment_list();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.equipment_list)
  return _msg;
}
inline void PlayerInfo::set_allocated_equipment_list(::Protocol::EquipmentList* equipment_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.equipment_list_;
  }
  if (equipment_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(equipment_list);
    if (message_arena != submessage_arena) {
      equipment_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equipment_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.equipment_list_ = equipment_list;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.equipment_list)
}

// string player_id = 10;
inline void PlayerInfo::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& PlayerInfo::player_id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.player_id)
}
inline std::string* PlayerInfo::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.player_id)
  return _s;
}
inline const std::string& PlayerInfo::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void PlayerInfo::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_player_id() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.player_id)
  return _impl_.player_id_.Release();
}
inline void PlayerInfo::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.player_id)
}

// string player_name = 11;
inline void PlayerInfo::clear_player_name() {
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& PlayerInfo::player_name() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.player_name)
}
inline std::string* PlayerInfo::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.player_name)
  return _s;
}
inline const std::string& PlayerInfo::_internal_player_name() const {
  return _impl_.player_name_.Get();
}
inline void PlayerInfo::_internal_set_player_name(const std::string& value) {
  
  _impl_.player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_player_name() {
  
  return _impl_.player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_player_name() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.player_name)
  return _impl_.player_name_.Release();
}
inline void PlayerInfo::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  _impl_.player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.player_name)
}

// .Protocol.EquipStateInfo equip_state = 12;
inline bool PlayerInfo::_internal_has_equip_state() const {
  return this != internal_default_instance() && _impl_.equip_state_ != nullptr;
}
inline bool PlayerInfo::has_equip_state() const {
  return _internal_has_equip_state();
}
inline void PlayerInfo::clear_equip_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.equip_state_ != nullptr) {
    delete _impl_.equip_state_;
  }
  _impl_.equip_state_ = nullptr;
}
inline const ::Protocol::EquipStateInfo& PlayerInfo::_internal_equip_state() const {
  const ::Protocol::EquipStateInfo* p = _impl_.equip_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::EquipStateInfo&>(
      ::Protocol::_EquipStateInfo_default_instance_);
}
inline const ::Protocol::EquipStateInfo& PlayerInfo::equip_state() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.equip_state)
  return _internal_equip_state();
}
inline void PlayerInfo::unsafe_arena_set_allocated_equip_state(
    ::Protocol::EquipStateInfo* equip_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.equip_state_);
  }
  _impl_.equip_state_ = equip_state;
  if (equip_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.equip_state)
}
inline ::Protocol::EquipStateInfo* PlayerInfo::release_equip_state() {
  
  ::Protocol::EquipStateInfo* temp = _impl_.equip_state_;
  _impl_.equip_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::EquipStateInfo* PlayerInfo::unsafe_arena_release_equip_state() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.equip_state)
  
  ::Protocol::EquipStateInfo* temp = _impl_.equip_state_;
  _impl_.equip_state_ = nullptr;
  return temp;
}
inline ::Protocol::EquipStateInfo* PlayerInfo::_internal_mutable_equip_state() {
  
  if (_impl_.equip_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::EquipStateInfo>(GetArenaForAllocation());
    _impl_.equip_state_ = p;
  }
  return _impl_.equip_state_;
}
inline ::Protocol::EquipStateInfo* PlayerInfo::mutable_equip_state() {
  ::Protocol::EquipStateInfo* _msg = _internal_mutable_equip_state();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.equip_state)
  return _msg;
}
inline void PlayerInfo::set_allocated_equip_state(::Protocol::EquipStateInfo* equip_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.equip_state_;
  }
  if (equip_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(equip_state);
    if (message_arena != submessage_arena) {
      equip_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equip_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.equip_state_ = equip_state;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.equip_state)
}

// uint64 gold = 13;
inline void PlayerInfo::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t PlayerInfo::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t PlayerInfo::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.gold)
  return _internal_gold();
}
inline void PlayerInfo::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void PlayerInfo::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.gold)
}

// -------------------------------------------------------------------

// MonsterInfo

// uint64 object_id = 1;
inline void MonsterInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t MonsterInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t MonsterInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MonsterInfo.object_id)
  return _internal_object_id();
}
inline void MonsterInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void MonsterInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MonsterInfo.object_id)
}

// uint32 level = 2;
inline void MonsterInfo::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t MonsterInfo::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t MonsterInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.MonsterInfo.level)
  return _internal_level();
}
inline void MonsterInfo::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void MonsterInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.MonsterInfo.level)
}

// .Protocol.PosInfo pos_info = 4;
inline bool MonsterInfo::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool MonsterInfo::has_pos_info() const {
  return _internal_has_pos_info();
}
inline void MonsterInfo::clear_pos_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_info_ != nullptr) {
    delete _impl_.pos_info_;
  }
  _impl_.pos_info_ = nullptr;
}
inline const ::Protocol::PosInfo& MonsterInfo::_internal_pos_info() const {
  const ::Protocol::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& MonsterInfo::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.MonsterInfo.pos_info)
  return _internal_pos_info();
}
inline void MonsterInfo::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PosInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MonsterInfo.pos_info)
}
inline ::Protocol::PosInfo* MonsterInfo::release_pos_info() {
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* MonsterInfo::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.MonsterInfo.pos_info)
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* MonsterInfo::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PosInfo* MonsterInfo::mutable_pos_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.MonsterInfo.pos_info)
  return _msg;
}
inline void MonsterInfo::set_allocated_pos_info(::Protocol::PosInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_info_;
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos_info);
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MonsterInfo.pos_info)
}

// .Protocol.StatusInfo status_info = 5;
inline bool MonsterInfo::_internal_has_status_info() const {
  return this != internal_default_instance() && _impl_.status_info_ != nullptr;
}
inline bool MonsterInfo::has_status_info() const {
  return _internal_has_status_info();
}
inline void MonsterInfo::clear_status_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_info_ != nullptr) {
    delete _impl_.status_info_;
  }
  _impl_.status_info_ = nullptr;
}
inline const ::Protocol::StatusInfo& MonsterInfo::_internal_status_info() const {
  const ::Protocol::StatusInfo* p = _impl_.status_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatusInfo&>(
      ::Protocol::_StatusInfo_default_instance_);
}
inline const ::Protocol::StatusInfo& MonsterInfo::status_info() const {
  // @@protoc_insertion_point(field_get:Protocol.MonsterInfo.status_info)
  return _internal_status_info();
}
inline void MonsterInfo::unsafe_arena_set_allocated_status_info(
    ::Protocol::StatusInfo* status_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_info_);
  }
  _impl_.status_info_ = status_info;
  if (status_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MonsterInfo.status_info)
}
inline ::Protocol::StatusInfo* MonsterInfo::release_status_info() {
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatusInfo* MonsterInfo::unsafe_arena_release_status_info() {
  // @@protoc_insertion_point(field_release:Protocol.MonsterInfo.status_info)
  
  ::Protocol::StatusInfo* temp = _impl_.status_info_;
  _impl_.status_info_ = nullptr;
  return temp;
}
inline ::Protocol::StatusInfo* MonsterInfo::_internal_mutable_status_info() {
  
  if (_impl_.status_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatusInfo>(GetArenaForAllocation());
    _impl_.status_info_ = p;
  }
  return _impl_.status_info_;
}
inline ::Protocol::StatusInfo* MonsterInfo::mutable_status_info() {
  ::Protocol::StatusInfo* _msg = _internal_mutable_status_info();
  // @@protoc_insertion_point(field_mutable:Protocol.MonsterInfo.status_info)
  return _msg;
}
inline void MonsterInfo::set_allocated_status_info(::Protocol::StatusInfo* status_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_info_;
  }
  if (status_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_info);
    if (message_arena != submessage_arena) {
      status_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_info_ = status_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MonsterInfo.status_info)
}

// .Protocol.AbilityInputInfo input_info = 6;
inline bool MonsterInfo::_internal_has_input_info() const {
  return this != internal_default_instance() && _impl_.input_info_ != nullptr;
}
inline bool MonsterInfo::has_input_info() const {
  return _internal_has_input_info();
}
inline void MonsterInfo::clear_input_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_info_ != nullptr) {
    delete _impl_.input_info_;
  }
  _impl_.input_info_ = nullptr;
}
inline const ::Protocol::AbilityInputInfo& MonsterInfo::_internal_input_info() const {
  const ::Protocol::AbilityInputInfo* p = _impl_.input_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::AbilityInputInfo&>(
      ::Protocol::_AbilityInputInfo_default_instance_);
}
inline const ::Protocol::AbilityInputInfo& MonsterInfo::input_info() const {
  // @@protoc_insertion_point(field_get:Protocol.MonsterInfo.input_info)
  return _internal_input_info();
}
inline void MonsterInfo::unsafe_arena_set_allocated_input_info(
    ::Protocol::AbilityInputInfo* input_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_info_);
  }
  _impl_.input_info_ = input_info;
  if (input_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MonsterInfo.input_info)
}
inline ::Protocol::AbilityInputInfo* MonsterInfo::release_input_info() {
  
  ::Protocol::AbilityInputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::AbilityInputInfo* MonsterInfo::unsafe_arena_release_input_info() {
  // @@protoc_insertion_point(field_release:Protocol.MonsterInfo.input_info)
  
  ::Protocol::AbilityInputInfo* temp = _impl_.input_info_;
  _impl_.input_info_ = nullptr;
  return temp;
}
inline ::Protocol::AbilityInputInfo* MonsterInfo::_internal_mutable_input_info() {
  
  if (_impl_.input_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::AbilityInputInfo>(GetArenaForAllocation());
    _impl_.input_info_ = p;
  }
  return _impl_.input_info_;
}
inline ::Protocol::AbilityInputInfo* MonsterInfo::mutable_input_info() {
  ::Protocol::AbilityInputInfo* _msg = _internal_mutable_input_info();
  // @@protoc_insertion_point(field_mutable:Protocol.MonsterInfo.input_info)
  return _msg;
}
inline void MonsterInfo::set_allocated_input_info(::Protocol::AbilityInputInfo* input_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_info_;
  }
  if (input_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_info);
    if (message_arena != submessage_arena) {
      input_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_info_ = input_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MonsterInfo.input_info)
}

// .Protocol.MonsterType type = 7;
inline void MonsterInfo::clear_type() {
  _impl_.type_ = 0;
}
inline ::Protocol::MonsterType MonsterInfo::_internal_type() const {
  return static_cast< ::Protocol::MonsterType >(_impl_.type_);
}
inline ::Protocol::MonsterType MonsterInfo::type() const {
  // @@protoc_insertion_point(field_get:Protocol.MonsterInfo.type)
  return _internal_type();
}
inline void MonsterInfo::_internal_set_type(::Protocol::MonsterType value) {
  
  _impl_.type_ = value;
}
inline void MonsterInfo::set_type(::Protocol::MonsterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.MonsterInfo.type)
}

// -------------------------------------------------------------------

// AbilityInputInfo

// uint64 object_id = 1;
inline void AbilityInputInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t AbilityInputInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t AbilityInputInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.AbilityInputInfo.object_id)
  return _internal_object_id();
}
inline void AbilityInputInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void AbilityInputInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.AbilityInputInfo.object_id)
}

// string tag = 2;
inline void AbilityInputInfo::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& AbilityInputInfo::tag() const {
  // @@protoc_insertion_point(field_get:Protocol.AbilityInputInfo.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbilityInputInfo::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.AbilityInputInfo.tag)
}
inline std::string* AbilityInputInfo::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:Protocol.AbilityInputInfo.tag)
  return _s;
}
inline const std::string& AbilityInputInfo::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void AbilityInputInfo::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* AbilityInputInfo::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* AbilityInputInfo::release_tag() {
  // @@protoc_insertion_point(field_release:Protocol.AbilityInputInfo.tag)
  return _impl_.tag_.Release();
}
inline void AbilityInputInfo::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.AbilityInputInfo.tag)
}

// .Protocol.InputState input = 3;
inline void AbilityInputInfo::clear_input() {
  _impl_.input_ = 0;
}
inline ::Protocol::InputState AbilityInputInfo::_internal_input() const {
  return static_cast< ::Protocol::InputState >(_impl_.input_);
}
inline ::Protocol::InputState AbilityInputInfo::input() const {
  // @@protoc_insertion_point(field_get:Protocol.AbilityInputInfo.input)
  return _internal_input();
}
inline void AbilityInputInfo::_internal_set_input(::Protocol::InputState value) {
  
  _impl_.input_ = value;
}
inline void AbilityInputInfo::set_input(::Protocol::InputState value) {
  _internal_set_input(value);
  // @@protoc_insertion_point(field_set:Protocol.AbilityInputInfo.input)
}

// -------------------------------------------------------------------

// EquipStateInfo

// uint64 object_id = 1;
inline void EquipStateInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t EquipStateInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t EquipStateInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.EquipStateInfo.object_id)
  return _internal_object_id();
}
inline void EquipStateInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void EquipStateInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.EquipStateInfo.object_id)
}

// .Protocol.EquipState equip_state = 2;
inline void EquipStateInfo::clear_equip_state() {
  _impl_.equip_state_ = 0;
}
inline ::Protocol::EquipState EquipStateInfo::_internal_equip_state() const {
  return static_cast< ::Protocol::EquipState >(_impl_.equip_state_);
}
inline ::Protocol::EquipState EquipStateInfo::equip_state() const {
  // @@protoc_insertion_point(field_get:Protocol.EquipStateInfo.equip_state)
  return _internal_equip_state();
}
inline void EquipStateInfo::_internal_set_equip_state(::Protocol::EquipState value) {
  
  _impl_.equip_state_ = value;
}
inline void EquipStateInfo::set_equip_state(::Protocol::EquipState value) {
  _internal_set_equip_state(value);
  // @@protoc_insertion_point(field_set:Protocol.EquipStateInfo.equip_state)
}

// -------------------------------------------------------------------

// AIInfo

// uint64 object_id = 1;
inline void AIInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t AIInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t AIInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.AIInfo.object_id)
  return _internal_object_id();
}
inline void AIInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void AIInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.AIInfo.object_id)
}

// uint64 targetId_id = 2;
inline void AIInfo::clear_targetid_id() {
  _impl_.targetid_id_ = uint64_t{0u};
}
inline uint64_t AIInfo::_internal_targetid_id() const {
  return _impl_.targetid_id_;
}
inline uint64_t AIInfo::targetid_id() const {
  // @@protoc_insertion_point(field_get:Protocol.AIInfo.targetId_id)
  return _internal_targetid_id();
}
inline void AIInfo::_internal_set_targetid_id(uint64_t value) {
  
  _impl_.targetid_id_ = value;
}
inline void AIInfo::set_targetid_id(uint64_t value) {
  _internal_set_targetid_id(value);
  // @@protoc_insertion_point(field_set:Protocol.AIInfo.targetId_id)
}

// bool can_attack = 3;
inline void AIInfo::clear_can_attack() {
  _impl_.can_attack_ = false;
}
inline bool AIInfo::_internal_can_attack() const {
  return _impl_.can_attack_;
}
inline bool AIInfo::can_attack() const {
  // @@protoc_insertion_point(field_get:Protocol.AIInfo.can_attack)
  return _internal_can_attack();
}
inline void AIInfo::_internal_set_can_attack(bool value) {
  
  _impl_.can_attack_ = value;
}
inline void AIInfo::set_can_attack(bool value) {
  _internal_set_can_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.AIInfo.can_attack)
}

// float Patrol_x = 4;
inline void AIInfo::clear_patrol_x() {
  _impl_.patrol_x_ = 0;
}
inline float AIInfo::_internal_patrol_x() const {
  return _impl_.patrol_x_;
}
inline float AIInfo::patrol_x() const {
  // @@protoc_insertion_point(field_get:Protocol.AIInfo.Patrol_x)
  return _internal_patrol_x();
}
inline void AIInfo::_internal_set_patrol_x(float value) {
  
  _impl_.patrol_x_ = value;
}
inline void AIInfo::set_patrol_x(float value) {
  _internal_set_patrol_x(value);
  // @@protoc_insertion_point(field_set:Protocol.AIInfo.Patrol_x)
}

// float Patrol_y = 5;
inline void AIInfo::clear_patrol_y() {
  _impl_.patrol_y_ = 0;
}
inline float AIInfo::_internal_patrol_y() const {
  return _impl_.patrol_y_;
}
inline float AIInfo::patrol_y() const {
  // @@protoc_insertion_point(field_get:Protocol.AIInfo.Patrol_y)
  return _internal_patrol_y();
}
inline void AIInfo::_internal_set_patrol_y(float value) {
  
  _impl_.patrol_y_ = value;
}
inline void AIInfo::set_patrol_y(float value) {
  _internal_set_patrol_y(value);
  // @@protoc_insertion_point(field_set:Protocol.AIInfo.Patrol_y)
}

// float Patrol_z = 6;
inline void AIInfo::clear_patrol_z() {
  _impl_.patrol_z_ = 0;
}
inline float AIInfo::_internal_patrol_z() const {
  return _impl_.patrol_z_;
}
inline float AIInfo::patrol_z() const {
  // @@protoc_insertion_point(field_get:Protocol.AIInfo.Patrol_z)
  return _internal_patrol_z();
}
inline void AIInfo::_internal_set_patrol_z(float value) {
  
  _impl_.patrol_z_ = value;
}
inline void AIInfo::set_patrol_z(float value) {
  _internal_set_patrol_z(value);
  // @@protoc_insertion_point(field_set:Protocol.AIInfo.Patrol_z)
}

// -------------------------------------------------------------------

// InventoryList

// uint64 object_id = 1;
inline void InventoryList::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t InventoryList::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t InventoryList::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.InventoryList.object_id)
  return _internal_object_id();
}
inline void InventoryList::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void InventoryList::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.InventoryList.object_id)
}

// repeated .Protocol.ItemInfo list = 2;
inline int InventoryList::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int InventoryList::list_size() const {
  return _internal_list_size();
}
inline void InventoryList::clear_list() {
  _impl_.list_.Clear();
}
inline ::Protocol::ItemInfo* InventoryList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.InventoryList.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
InventoryList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.InventoryList.list)
  return &_impl_.list_;
}
inline const ::Protocol::ItemInfo& InventoryList::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::Protocol::ItemInfo& InventoryList::list(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.InventoryList.list)
  return _internal_list(index);
}
inline ::Protocol::ItemInfo* InventoryList::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::Protocol::ItemInfo* InventoryList::add_list() {
  ::Protocol::ItemInfo* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:Protocol.InventoryList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
InventoryList::list() const {
  // @@protoc_insertion_point(field_list:Protocol.InventoryList.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// EquipmentList

// uint64 object_id = 1;
inline void EquipmentList::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t EquipmentList::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t EquipmentList::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.EquipmentList.object_id)
  return _internal_object_id();
}
inline void EquipmentList::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void EquipmentList::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.EquipmentList.object_id)
}

// repeated .Protocol.ItemInfo list = 2;
inline int EquipmentList::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int EquipmentList::list_size() const {
  return _internal_list_size();
}
inline void EquipmentList::clear_list() {
  _impl_.list_.Clear();
}
inline ::Protocol::ItemInfo* EquipmentList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.EquipmentList.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
EquipmentList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.EquipmentList.list)
  return &_impl_.list_;
}
inline const ::Protocol::ItemInfo& EquipmentList::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::Protocol::ItemInfo& EquipmentList::list(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.EquipmentList.list)
  return _internal_list(index);
}
inline ::Protocol::ItemInfo* EquipmentList::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::Protocol::ItemInfo* EquipmentList::add_list() {
  ::Protocol::ItemInfo* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:Protocol.EquipmentList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
EquipmentList::list() const {
  // @@protoc_insertion_point(field_list:Protocol.EquipmentList.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// ItemInfo

// uint64 object_id = 1;
inline void ItemInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t ItemInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t ItemInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.object_id)
  return _internal_object_id();
}
inline void ItemInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void ItemInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.object_id)
}

// uint64 item_id = 2;
inline void ItemInfo::clear_item_id() {
  _impl_.item_id_ = uint64_t{0u};
}
inline uint64_t ItemInfo::_internal_item_id() const {
  return _impl_.item_id_;
}
inline uint64_t ItemInfo::item_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.item_id)
  return _internal_item_id();
}
inline void ItemInfo::_internal_set_item_id(uint64_t value) {
  
  _impl_.item_id_ = value;
}
inline void ItemInfo::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.item_id)
}

// uint64 gold = 3;
inline void ItemInfo::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t ItemInfo::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t ItemInfo::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.gold)
  return _internal_gold();
}
inline void ItemInfo::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void ItemInfo::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.gold)
}

// .Protocol.ItemType item_type = 4;
inline void ItemInfo::clear_item_type() {
  _impl_.item_type_ = 0;
}
inline ::Protocol::ItemType ItemInfo::_internal_item_type() const {
  return static_cast< ::Protocol::ItemType >(_impl_.item_type_);
}
inline ::Protocol::ItemType ItemInfo::item_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.item_type)
  return _internal_item_type();
}
inline void ItemInfo::_internal_set_item_type(::Protocol::ItemType value) {
  
  _impl_.item_type_ = value;
}
inline void ItemInfo::set_item_type(::Protocol::ItemType value) {
  _internal_set_item_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.item_type)
}

// .Protocol.ItemRarity item_rarity = 5;
inline void ItemInfo::clear_item_rarity() {
  _impl_.item_rarity_ = 0;
}
inline ::Protocol::ItemRarity ItemInfo::_internal_item_rarity() const {
  return static_cast< ::Protocol::ItemRarity >(_impl_.item_rarity_);
}
inline ::Protocol::ItemRarity ItemInfo::item_rarity() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.item_rarity)
  return _internal_item_rarity();
}
inline void ItemInfo::_internal_set_item_rarity(::Protocol::ItemRarity value) {
  
  _impl_.item_rarity_ = value;
}
inline void ItemInfo::set_item_rarity(::Protocol::ItemRarity value) {
  _internal_set_item_rarity(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.item_rarity)
}

// .Protocol.ItemCustomType custom_type = 6;
inline void ItemInfo::clear_custom_type() {
  _impl_.custom_type_ = 0;
}
inline ::Protocol::ItemCustomType ItemInfo::_internal_custom_type() const {
  return static_cast< ::Protocol::ItemCustomType >(_impl_.custom_type_);
}
inline ::Protocol::ItemCustomType ItemInfo::custom_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.custom_type)
  return _internal_custom_type();
}
inline void ItemInfo::_internal_set_custom_type(::Protocol::ItemCustomType value) {
  
  _impl_.custom_type_ = value;
}
inline void ItemInfo::set_custom_type(::Protocol::ItemCustomType value) {
  _internal_set_custom_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.custom_type)
}

// .Protocol.EquipType equip_type = 7;
inline void ItemInfo::clear_equip_type() {
  _impl_.equip_type_ = 0;
}
inline ::Protocol::EquipType ItemInfo::_internal_equip_type() const {
  return static_cast< ::Protocol::EquipType >(_impl_.equip_type_);
}
inline ::Protocol::EquipType ItemInfo::equip_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.equip_type)
  return _internal_equip_type();
}
inline void ItemInfo::_internal_set_equip_type(::Protocol::EquipType value) {
  
  _impl_.equip_type_ = value;
}
inline void ItemInfo::set_equip_type(::Protocol::EquipType value) {
  _internal_set_equip_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.equip_type)
}

// uint64 item_count = 8;
inline void ItemInfo::clear_item_count() {
  _impl_.item_count_ = uint64_t{0u};
}
inline uint64_t ItemInfo::_internal_item_count() const {
  return _impl_.item_count_;
}
inline uint64_t ItemInfo::item_count() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.item_count)
  return _internal_item_count();
}
inline void ItemInfo::_internal_set_item_count(uint64_t value) {
  
  _impl_.item_count_ = value;
}
inline void ItemInfo::set_item_count(uint64_t value) {
  _internal_set_item_count(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.item_count)
}

// string item_name = 9;
inline void ItemInfo::clear_item_name() {
  _impl_.item_name_.ClearToEmpty();
}
inline const std::string& ItemInfo::item_name() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.item_name)
  return _internal_item_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_item_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.item_name)
}
inline std::string* ItemInfo::mutable_item_name() {
  std::string* _s = _internal_mutable_item_name();
  // @@protoc_insertion_point(field_mutable:Protocol.ItemInfo.item_name)
  return _s;
}
inline const std::string& ItemInfo::_internal_item_name() const {
  return _impl_.item_name_.Get();
}
inline void ItemInfo::_internal_set_item_name(const std::string& value) {
  
  _impl_.item_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_item_name() {
  
  return _impl_.item_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_item_name() {
  // @@protoc_insertion_point(field_release:Protocol.ItemInfo.item_name)
  return _impl_.item_name_.Release();
}
inline void ItemInfo::set_allocated_item_name(std::string* item_name) {
  if (item_name != nullptr) {
    
  } else {
    
  }
  _impl_.item_name_.SetAllocated(item_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_name_.IsDefault()) {
    _impl_.item_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ItemInfo.item_name)
}

// string item_visual_name = 10;
inline void ItemInfo::clear_item_visual_name() {
  _impl_.item_visual_name_.ClearToEmpty();
}
inline const std::string& ItemInfo::item_visual_name() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.item_visual_name)
  return _internal_item_visual_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_item_visual_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_visual_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.item_visual_name)
}
inline std::string* ItemInfo::mutable_item_visual_name() {
  std::string* _s = _internal_mutable_item_visual_name();
  // @@protoc_insertion_point(field_mutable:Protocol.ItemInfo.item_visual_name)
  return _s;
}
inline const std::string& ItemInfo::_internal_item_visual_name() const {
  return _impl_.item_visual_name_.Get();
}
inline void ItemInfo::_internal_set_item_visual_name(const std::string& value) {
  
  _impl_.item_visual_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_item_visual_name() {
  
  return _impl_.item_visual_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_item_visual_name() {
  // @@protoc_insertion_point(field_release:Protocol.ItemInfo.item_visual_name)
  return _impl_.item_visual_name_.Release();
}
inline void ItemInfo::set_allocated_item_visual_name(std::string* item_visual_name) {
  if (item_visual_name != nullptr) {
    
  } else {
    
  }
  _impl_.item_visual_name_.SetAllocated(item_visual_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_visual_name_.IsDefault()) {
    _impl_.item_visual_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ItemInfo.item_visual_name)
}

// float atk = 11;
inline void ItemInfo::clear_atk() {
  _impl_.atk_ = 0;
}
inline float ItemInfo::_internal_atk() const {
  return _impl_.atk_;
}
inline float ItemInfo::atk() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.atk)
  return _internal_atk();
}
inline void ItemInfo::_internal_set_atk(float value) {
  
  _impl_.atk_ = value;
}
inline void ItemInfo::set_atk(float value) {
  _internal_set_atk(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.atk)
}

// float def = 12;
inline void ItemInfo::clear_def() {
  _impl_.def_ = 0;
}
inline float ItemInfo::_internal_def() const {
  return _impl_.def_;
}
inline float ItemInfo::def() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.def)
  return _internal_def();
}
inline void ItemInfo::_internal_set_def(float value) {
  
  _impl_.def_ = value;
}
inline void ItemInfo::set_def(float value) {
  _internal_set_def(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.def)
}

// float delay = 13;
inline void ItemInfo::clear_delay() {
  _impl_.delay_ = 0;
}
inline float ItemInfo::_internal_delay() const {
  return _impl_.delay_;
}
inline float ItemInfo::delay() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.delay)
  return _internal_delay();
}
inline void ItemInfo::_internal_set_delay(float value) {
  
  _impl_.delay_ = value;
}
inline void ItemInfo::set_delay(float value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.delay)
}

// float range = 14;
inline void ItemInfo::clear_range() {
  _impl_.range_ = 0;
}
inline float ItemInfo::_internal_range() const {
  return _impl_.range_;
}
inline float ItemInfo::range() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.range)
  return _internal_range();
}
inline void ItemInfo::_internal_set_range(float value) {
  
  _impl_.range_ = value;
}
inline void ItemInfo::set_range(float value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.range)
}

// -------------------------------------------------------------------

// ObjectItemInfo

// uint64 object_id = 1;
inline void ObjectItemInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t ObjectItemInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t ObjectItemInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectItemInfo.object_id)
  return _internal_object_id();
}
inline void ObjectItemInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void ObjectItemInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ObjectItemInfo.object_id)
}

// .Protocol.ItemInfo info = 2;
inline bool ObjectItemInfo::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool ObjectItemInfo::has_info() const {
  return _internal_has_info();
}
inline void ObjectItemInfo::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::Protocol::ItemInfo& ObjectItemInfo::_internal_info() const {
  const ::Protocol::ItemInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemInfo&>(
      ::Protocol::_ItemInfo_default_instance_);
}
inline const ::Protocol::ItemInfo& ObjectItemInfo::info() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectItemInfo.info)
  return _internal_info();
}
inline void ObjectItemInfo::unsafe_arena_set_allocated_info(
    ::Protocol::ItemInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectItemInfo.info)
}
inline ::Protocol::ItemInfo* ObjectItemInfo::release_info() {
  
  ::Protocol::ItemInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemInfo* ObjectItemInfo::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectItemInfo.info)
  
  ::Protocol::ItemInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ItemInfo* ObjectItemInfo::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ItemInfo* ObjectItemInfo::mutable_info() {
  ::Protocol::ItemInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectItemInfo.info)
  return _msg;
}
inline void ObjectItemInfo::set_allocated_info(::Protocol::ItemInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectItemInfo.info)
}

// .Protocol.PosInfo pos_info = 3;
inline bool ObjectItemInfo::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool ObjectItemInfo::has_pos_info() const {
  return _internal_has_pos_info();
}
inline void ObjectItemInfo::clear_pos_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_info_ != nullptr) {
    delete _impl_.pos_info_;
  }
  _impl_.pos_info_ = nullptr;
}
inline const ::Protocol::PosInfo& ObjectItemInfo::_internal_pos_info() const {
  const ::Protocol::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& ObjectItemInfo::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectItemInfo.pos_info)
  return _internal_pos_info();
}
inline void ObjectItemInfo::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PosInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectItemInfo.pos_info)
}
inline ::Protocol::PosInfo* ObjectItemInfo::release_pos_info() {
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* ObjectItemInfo::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectItemInfo.pos_info)
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* ObjectItemInfo::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PosInfo* ObjectItemInfo::mutable_pos_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectItemInfo.pos_info)
  return _msg;
}
inline void ObjectItemInfo::set_allocated_pos_info(::Protocol::PosInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_info_;
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos_info);
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectItemInfo.pos_info)
}

// -------------------------------------------------------------------

// ItemBoxInfo

// uint64 object_id = 1;
inline void ItemBoxInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t ItemBoxInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t ItemBoxInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemBoxInfo.object_id)
  return _internal_object_id();
}
inline void ItemBoxInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void ItemBoxInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemBoxInfo.object_id)
}

// .Protocol.ItemBoxType box_type = 2;
inline void ItemBoxInfo::clear_box_type() {
  _impl_.box_type_ = 0;
}
inline ::Protocol::ItemBoxType ItemBoxInfo::_internal_box_type() const {
  return static_cast< ::Protocol::ItemBoxType >(_impl_.box_type_);
}
inline ::Protocol::ItemBoxType ItemBoxInfo::box_type() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemBoxInfo.box_type)
  return _internal_box_type();
}
inline void ItemBoxInfo::_internal_set_box_type(::Protocol::ItemBoxType value) {
  
  _impl_.box_type_ = value;
}
inline void ItemBoxInfo::set_box_type(::Protocol::ItemBoxType value) {
  _internal_set_box_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemBoxInfo.box_type)
}

// .Protocol.ItemBoxState box_state = 3;
inline void ItemBoxInfo::clear_box_state() {
  _impl_.box_state_ = 0;
}
inline ::Protocol::ItemBoxState ItemBoxInfo::_internal_box_state() const {
  return static_cast< ::Protocol::ItemBoxState >(_impl_.box_state_);
}
inline ::Protocol::ItemBoxState ItemBoxInfo::box_state() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemBoxInfo.box_state)
  return _internal_box_state();
}
inline void ItemBoxInfo::_internal_set_box_state(::Protocol::ItemBoxState value) {
  
  _impl_.box_state_ = value;
}
inline void ItemBoxInfo::set_box_state(::Protocol::ItemBoxState value) {
  _internal_set_box_state(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemBoxInfo.box_state)
}

// .Protocol.InventoryList list = 4;
inline bool ItemBoxInfo::_internal_has_list() const {
  return this != internal_default_instance() && _impl_.list_ != nullptr;
}
inline bool ItemBoxInfo::has_list() const {
  return _internal_has_list();
}
inline void ItemBoxInfo::clear_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_ != nullptr) {
    delete _impl_.list_;
  }
  _impl_.list_ = nullptr;
}
inline const ::Protocol::InventoryList& ItemBoxInfo::_internal_list() const {
  const ::Protocol::InventoryList* p = _impl_.list_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::InventoryList&>(
      ::Protocol::_InventoryList_default_instance_);
}
inline const ::Protocol::InventoryList& ItemBoxInfo::list() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemBoxInfo.list)
  return _internal_list();
}
inline void ItemBoxInfo::unsafe_arena_set_allocated_list(
    ::Protocol::InventoryList* list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_);
  }
  _impl_.list_ = list;
  if (list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ItemBoxInfo.list)
}
inline ::Protocol::InventoryList* ItemBoxInfo::release_list() {
  
  ::Protocol::InventoryList* temp = _impl_.list_;
  _impl_.list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::InventoryList* ItemBoxInfo::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_release:Protocol.ItemBoxInfo.list)
  
  ::Protocol::InventoryList* temp = _impl_.list_;
  _impl_.list_ = nullptr;
  return temp;
}
inline ::Protocol::InventoryList* ItemBoxInfo::_internal_mutable_list() {
  
  if (_impl_.list_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::InventoryList>(GetArenaForAllocation());
    _impl_.list_ = p;
  }
  return _impl_.list_;
}
inline ::Protocol::InventoryList* ItemBoxInfo::mutable_list() {
  ::Protocol::InventoryList* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:Protocol.ItemBoxInfo.list)
  return _msg;
}
inline void ItemBoxInfo::set_allocated_list(::Protocol::InventoryList* list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_;
  }
  if (list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list);
    if (message_arena != submessage_arena) {
      list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_ = list;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ItemBoxInfo.list)
}

// .Protocol.PosInfo pos_info = 5;
inline bool ItemBoxInfo::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool ItemBoxInfo::has_pos_info() const {
  return _internal_has_pos_info();
}
inline void ItemBoxInfo::clear_pos_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_info_ != nullptr) {
    delete _impl_.pos_info_;
  }
  _impl_.pos_info_ = nullptr;
}
inline const ::Protocol::PosInfo& ItemBoxInfo::_internal_pos_info() const {
  const ::Protocol::PosInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& ItemBoxInfo::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemBoxInfo.pos_info)
  return _internal_pos_info();
}
inline void ItemBoxInfo::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PosInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ItemBoxInfo.pos_info)
}
inline ::Protocol::PosInfo* ItemBoxInfo::release_pos_info() {
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* ItemBoxInfo::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.ItemBoxInfo.pos_info)
  
  ::Protocol::PosInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* ItemBoxInfo::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PosInfo* ItemBoxInfo::mutable_pos_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.ItemBoxInfo.pos_info)
  return _msg;
}
inline void ItemBoxInfo::set_allocated_pos_info(::Protocol::PosInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_info_;
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos_info);
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ItemBoxInfo.pos_info)
}

// -------------------------------------------------------------------

// LevelPointInfo

// uint64 object_id = 1;
inline void LevelPointInfo::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t LevelPointInfo::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t LevelPointInfo::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.LevelPointInfo.object_id)
  return _internal_object_id();
}
inline void LevelPointInfo::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void LevelPointInfo::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.LevelPointInfo.object_id)
}

// uint32 level = 2;
inline void LevelPointInfo::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t LevelPointInfo::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t LevelPointInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.LevelPointInfo.level)
  return _internal_level();
}
inline void LevelPointInfo::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void LevelPointInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.LevelPointInfo.level)
}

// uint32 skill_point = 3;
inline void LevelPointInfo::clear_skill_point() {
  _impl_.skill_point_ = 0u;
}
inline uint32_t LevelPointInfo::_internal_skill_point() const {
  return _impl_.skill_point_;
}
inline uint32_t LevelPointInfo::skill_point() const {
  // @@protoc_insertion_point(field_get:Protocol.LevelPointInfo.skill_point)
  return _internal_skill_point();
}
inline void LevelPointInfo::_internal_set_skill_point(uint32_t value) {
  
  _impl_.skill_point_ = value;
}
inline void LevelPointInfo::set_skill_point(uint32_t value) {
  _internal_set_skill_point(value);
  // @@protoc_insertion_point(field_set:Protocol.LevelPointInfo.skill_point)
}

// -------------------------------------------------------------------

// ShopItemInfo

// .Protocol.ItemInfo item = 1;
inline bool ShopItemInfo::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool ShopItemInfo::has_item() const {
  return _internal_has_item();
}
inline void ShopItemInfo::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::Protocol::ItemInfo& ShopItemInfo::_internal_item() const {
  const ::Protocol::ItemInfo* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemInfo&>(
      ::Protocol::_ItemInfo_default_instance_);
}
inline const ::Protocol::ItemInfo& ShopItemInfo::item() const {
  // @@protoc_insertion_point(field_get:Protocol.ShopItemInfo.item)
  return _internal_item();
}
inline void ShopItemInfo::unsafe_arena_set_allocated_item(
    ::Protocol::ItemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ShopItemInfo.item)
}
inline ::Protocol::ItemInfo* ShopItemInfo::release_item() {
  
  ::Protocol::ItemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemInfo* ShopItemInfo::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:Protocol.ShopItemInfo.item)
  
  ::Protocol::ItemInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::Protocol::ItemInfo* ShopItemInfo::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemInfo>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::Protocol::ItemInfo* ShopItemInfo::mutable_item() {
  ::Protocol::ItemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:Protocol.ShopItemInfo.item)
  return _msg;
}
inline void ShopItemInfo::set_allocated_item(::Protocol::ItemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ShopItemInfo.item)
}

// uint32 can_buy_count = 2;
inline void ShopItemInfo::clear_can_buy_count() {
  _impl_.can_buy_count_ = 0u;
}
inline uint32_t ShopItemInfo::_internal_can_buy_count() const {
  return _impl_.can_buy_count_;
}
inline uint32_t ShopItemInfo::can_buy_count() const {
  // @@protoc_insertion_point(field_get:Protocol.ShopItemInfo.can_buy_count)
  return _internal_can_buy_count();
}
inline void ShopItemInfo::_internal_set_can_buy_count(uint32_t value) {
  
  _impl_.can_buy_count_ = value;
}
inline void ShopItemInfo::set_can_buy_count(uint32_t value) {
  _internal_set_can_buy_count(value);
  // @@protoc_insertion_point(field_set:Protocol.ShopItemInfo.can_buy_count)
}

// -------------------------------------------------------------------

// ShopInfo

// uint32 list_count = 1;
inline void ShopInfo::clear_list_count() {
  _impl_.list_count_ = 0u;
}
inline uint32_t ShopInfo::_internal_list_count() const {
  return _impl_.list_count_;
}
inline uint32_t ShopInfo::list_count() const {
  // @@protoc_insertion_point(field_get:Protocol.ShopInfo.list_count)
  return _internal_list_count();
}
inline void ShopInfo::_internal_set_list_count(uint32_t value) {
  
  _impl_.list_count_ = value;
}
inline void ShopInfo::set_list_count(uint32_t value) {
  _internal_set_list_count(value);
  // @@protoc_insertion_point(field_set:Protocol.ShopInfo.list_count)
}

// repeated .Protocol.ShopItemInfo list = 2;
inline int ShopInfo::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int ShopInfo::list_size() const {
  return _internal_list_size();
}
inline void ShopInfo::clear_list() {
  _impl_.list_.Clear();
}
inline ::Protocol::ShopItemInfo* ShopInfo::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.ShopInfo.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ShopItemInfo >*
ShopInfo::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.ShopInfo.list)
  return &_impl_.list_;
}
inline const ::Protocol::ShopItemInfo& ShopInfo::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::Protocol::ShopItemInfo& ShopInfo::list(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.ShopInfo.list)
  return _internal_list(index);
}
inline ::Protocol::ShopItemInfo* ShopInfo::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::Protocol::ShopItemInfo* ShopInfo::add_list() {
  ::Protocol::ShopItemInfo* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:Protocol.ShopInfo.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ShopItemInfo >&
ShopInfo::list() const {
  // @@protoc_insertion_point(field_list:Protocol.ShopInfo.list)
  return _impl_.list_;
}

// uint32 refresh_count = 3;
inline void ShopInfo::clear_refresh_count() {
  _impl_.refresh_count_ = 0u;
}
inline uint32_t ShopInfo::_internal_refresh_count() const {
  return _impl_.refresh_count_;
}
inline uint32_t ShopInfo::refresh_count() const {
  // @@protoc_insertion_point(field_get:Protocol.ShopInfo.refresh_count)
  return _internal_refresh_count();
}
inline void ShopInfo::_internal_set_refresh_count(uint32_t value) {
  
  _impl_.refresh_count_ = value;
}
inline void ShopInfo::set_refresh_count(uint32_t value) {
  _internal_set_refresh_count(value);
  // @@protoc_insertion_point(field_set:Protocol.ShopInfo.refresh_count)
}

// -------------------------------------------------------------------

// MailInfo

// string main_title = 1;
inline void MailInfo::clear_main_title() {
  _impl_.main_title_.ClearToEmpty();
}
inline const std::string& MailInfo::main_title() const {
  // @@protoc_insertion_point(field_get:Protocol.MailInfo.main_title)
  return _internal_main_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailInfo::set_main_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.main_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.MailInfo.main_title)
}
inline std::string* MailInfo::mutable_main_title() {
  std::string* _s = _internal_mutable_main_title();
  // @@protoc_insertion_point(field_mutable:Protocol.MailInfo.main_title)
  return _s;
}
inline const std::string& MailInfo::_internal_main_title() const {
  return _impl_.main_title_.Get();
}
inline void MailInfo::_internal_set_main_title(const std::string& value) {
  
  _impl_.main_title_.Set(value, GetArenaForAllocation());
}
inline std::string* MailInfo::_internal_mutable_main_title() {
  
  return _impl_.main_title_.Mutable(GetArenaForAllocation());
}
inline std::string* MailInfo::release_main_title() {
  // @@protoc_insertion_point(field_release:Protocol.MailInfo.main_title)
  return _impl_.main_title_.Release();
}
inline void MailInfo::set_allocated_main_title(std::string* main_title) {
  if (main_title != nullptr) {
    
  } else {
    
  }
  _impl_.main_title_.SetAllocated(main_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.main_title_.IsDefault()) {
    _impl_.main_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.MailInfo.main_title)
}

// string text = 2;
inline void MailInfo::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& MailInfo::text() const {
  // @@protoc_insertion_point(field_get:Protocol.MailInfo.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailInfo::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.MailInfo.text)
}
inline std::string* MailInfo::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Protocol.MailInfo.text)
  return _s;
}
inline const std::string& MailInfo::_internal_text() const {
  return _impl_.text_.Get();
}
inline void MailInfo::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* MailInfo::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* MailInfo::release_text() {
  // @@protoc_insertion_point(field_release:Protocol.MailInfo.text)
  return _impl_.text_.Release();
}
inline void MailInfo::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.MailInfo.text)
}

// repeated .Protocol.ItemInfo item = 3;
inline int MailInfo::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int MailInfo::item_size() const {
  return _internal_item_size();
}
inline void MailInfo::clear_item() {
  _impl_.item_.Clear();
}
inline ::Protocol::ItemInfo* MailInfo::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MailInfo.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
MailInfo::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MailInfo.item)
  return &_impl_.item_;
}
inline const ::Protocol::ItemInfo& MailInfo::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::Protocol::ItemInfo& MailInfo::item(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MailInfo.item)
  return _internal_item(index);
}
inline ::Protocol::ItemInfo* MailInfo::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::Protocol::ItemInfo* MailInfo::add_item() {
  ::Protocol::ItemInfo* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:Protocol.MailInfo.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
MailInfo::item() const {
  // @@protoc_insertion_point(field_list:Protocol.MailInfo.item)
  return _impl_.item_;
}

// bool is_read = 4;
inline void MailInfo::clear_is_read() {
  _impl_.is_read_ = false;
}
inline bool MailInfo::_internal_is_read() const {
  return _impl_.is_read_;
}
inline bool MailInfo::is_read() const {
  // @@protoc_insertion_point(field_get:Protocol.MailInfo.is_read)
  return _internal_is_read();
}
inline void MailInfo::_internal_set_is_read(bool value) {
  
  _impl_.is_read_ = value;
}
inline void MailInfo::set_is_read(bool value) {
  _internal_set_is_read(value);
  // @@protoc_insertion_point(field_set:Protocol.MailInfo.is_read)
}

// -------------------------------------------------------------------

// MailBoxInfo

// repeated .Protocol.MailInfo mail = 1;
inline int MailBoxInfo::_internal_mail_size() const {
  return _impl_.mail_.size();
}
inline int MailBoxInfo::mail_size() const {
  return _internal_mail_size();
}
inline void MailBoxInfo::clear_mail() {
  _impl_.mail_.Clear();
}
inline ::Protocol::MailInfo* MailBoxInfo::mutable_mail(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MailBoxInfo.mail)
  return _impl_.mail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MailInfo >*
MailBoxInfo::mutable_mail() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MailBoxInfo.mail)
  return &_impl_.mail_;
}
inline const ::Protocol::MailInfo& MailBoxInfo::_internal_mail(int index) const {
  return _impl_.mail_.Get(index);
}
inline const ::Protocol::MailInfo& MailBoxInfo::mail(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MailBoxInfo.mail)
  return _internal_mail(index);
}
inline ::Protocol::MailInfo* MailBoxInfo::_internal_add_mail() {
  return _impl_.mail_.Add();
}
inline ::Protocol::MailInfo* MailBoxInfo::add_mail() {
  ::Protocol::MailInfo* _add = _internal_add_mail();
  // @@protoc_insertion_point(field_add:Protocol.MailBoxInfo.mail)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MailInfo >&
MailBoxInfo::mail() const {
  // @@protoc_insertion_point(field_list:Protocol.MailBoxInfo.mail)
  return _impl_.mail_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
